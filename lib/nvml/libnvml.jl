# This file is automatically generated. Do not edit!
# To re-generate, execute res/wrap/wrap.jl

using CEnum: CEnum, @cenum

# outlined functionality to avoid GC frame allocation
@noinline function throw_api_error(res)
    throw(NVMLError(res))
end

const initialized = Ref(false)
function initialize_context()
    if !initialized[]
        res = unchecked_nvmlInitWithFlags(0)
        if res !== NVML_SUCCESS
            # NOTE: we can't call nvmlErrorString during initialization
            error("NVML could not be initialized ($res)")
        end
        atexit() do
            return nvmlShutdown()
        end
        initialized[] = true
    end
end

@inline function check(f)
    res = f()
    if res != NVML_SUCCESS
        throw_api_error(res)
    end

    return
end

macro NVML_STRUCT_VERSION(typename, version)
    struct_typename = Symbol("nvml$(String(typename))_v$(version)_t")
    struct_type = getfield(__module__, struct_typename)
    struct_version = UInt32(sizeof(struct_type)) | (UInt32(version) << 24)
    return :($struct_version)
end

@cenum nvmlMemoryErrorType_enum::UInt32 begin
    NVML_MEMORY_ERROR_TYPE_CORRECTED = 0
    NVML_MEMORY_ERROR_TYPE_UNCORRECTED = 1
    NVML_MEMORY_ERROR_TYPE_COUNT = 2
end

const nvmlMemoryErrorType_t = nvmlMemoryErrorType_enum

mutable struct nvmlDevice_st end

const nvmlDevice_t = Ptr{nvmlDevice_st}

mutable struct nvmlGpuInstance_st end

const nvmlGpuInstance_t = Ptr{nvmlGpuInstance_st}

struct nvmlPciInfoExt_v1_t
    version::Cuint
    domain::Cuint
    bus::Cuint
    device::Cuint
    pciDeviceId::Cuint
    pciSubSystemId::Cuint
    baseClass::Cuint
    subClass::Cuint
    busId::NTuple{32,Cchar}
end

const nvmlPciInfoExt_t = nvmlPciInfoExt_v1_t

struct nvmlPciInfo_st
    busIdLegacy::NTuple{16,Cchar}
    domain::Cuint
    bus::Cuint
    device::Cuint
    pciDeviceId::Cuint
    pciSubSystemId::Cuint
    busId::NTuple{32,Cchar}
end

const nvmlPciInfo_t = nvmlPciInfo_st

struct nvmlEccErrorCounts_st
    l1Cache::Culonglong
    l2Cache::Culonglong
    deviceMemory::Culonglong
    registerFile::Culonglong
end

const nvmlEccErrorCounts_t = nvmlEccErrorCounts_st

struct nvmlUtilization_st
    gpu::Cuint
    memory::Cuint
end

const nvmlUtilization_t = nvmlUtilization_st

struct nvmlMemory_st
    total::Culonglong
    free::Culonglong
    used::Culonglong
end

const nvmlMemory_t = nvmlMemory_st

struct nvmlMemory_v2_st
    version::Cuint
    total::Culonglong
    reserved::Culonglong
    free::Culonglong
    used::Culonglong
end

const nvmlMemory_v2_t = nvmlMemory_v2_st

struct nvmlBAR1Memory_st
    bar1Total::Culonglong
    bar1Free::Culonglong
    bar1Used::Culonglong
end

const nvmlBAR1Memory_t = nvmlBAR1Memory_st

struct nvmlProcessInfo_v1_st
    pid::Cuint
    usedGpuMemory::Culonglong
end

const nvmlProcessInfo_v1_t = nvmlProcessInfo_v1_st

struct nvmlProcessInfo_v2_st
    pid::Cuint
    usedGpuMemory::Culonglong
    gpuInstanceId::Cuint
    computeInstanceId::Cuint
end

const nvmlProcessInfo_v2_t = nvmlProcessInfo_v2_st

const nvmlProcessInfo_t = nvmlProcessInfo_v2_st

struct nvmlProcessDetail_v1_t
    pid::Cuint
    usedGpuMemory::Culonglong
    gpuInstanceId::Cuint
    computeInstanceId::Cuint
    usedGpuCcProtectedMemory::Culonglong
end

struct nvmlProcessDetailList_v1_t
    version::Cuint
    mode::Cuint
    numProcArrayEntries::Cuint
    procArray::Ptr{nvmlProcessDetail_v1_t}
end

const nvmlProcessDetailList_t = nvmlProcessDetailList_v1_t

struct nvmlDeviceAttributes_st
    multiprocessorCount::Cuint
    sharedCopyEngineCount::Cuint
    sharedDecoderCount::Cuint
    sharedEncoderCount::Cuint
    sharedJpegCount::Cuint
    sharedOfaCount::Cuint
    gpuInstanceSliceCount::Cuint
    computeInstanceSliceCount::Cuint
    memorySizeMB::Culonglong
end

const nvmlDeviceAttributes_t = nvmlDeviceAttributes_st

struct nvmlC2cModeInfo_v1_t
    isC2cEnabled::Cuint
end

@cenum nvmlDeviceAddressingModeType_t::UInt32 begin
    NVML_DEVICE_ADDRESSING_MODE_NONE = 0
    NVML_DEVICE_ADDRESSING_MODE_HMM = 1
    NVML_DEVICE_ADDRESSING_MODE_ATS = 2
end

struct nvmlDeviceAddressingMode_v1_t
    version::Cuint
    value::Cuint
end

const nvmlDeviceAddressingMode_t = nvmlDeviceAddressingMode_v1_t

struct nvmlRepairStatus_v1_t
    version::Cuint
    bChannelRepairPending::Cuint
    bTpcRepairPending::Cuint
end

const nvmlRepairStatus_t = nvmlRepairStatus_v1_t

struct nvmlRowRemapperHistogramValues_st
    max::Cuint
    high::Cuint
    partial::Cuint
    low::Cuint
    none::Cuint
end

const nvmlRowRemapperHistogramValues_t = nvmlRowRemapperHistogramValues_st

@cenum nvmlBridgeChipType_enum::UInt32 begin
    NVML_BRIDGE_CHIP_PLX = 0
    NVML_BRIDGE_CHIP_BRO4 = 1
end

const nvmlBridgeChipType_t = nvmlBridgeChipType_enum

@cenum nvmlNvLinkUtilizationCountUnits_enum::UInt32 begin
    NVML_NVLINK_COUNTER_UNIT_CYCLES = 0
    NVML_NVLINK_COUNTER_UNIT_PACKETS = 1
    NVML_NVLINK_COUNTER_UNIT_BYTES = 2
    NVML_NVLINK_COUNTER_UNIT_RESERVED = 3
    NVML_NVLINK_COUNTER_UNIT_COUNT = 4
end

const nvmlNvLinkUtilizationCountUnits_t = nvmlNvLinkUtilizationCountUnits_enum

@cenum nvmlNvLinkUtilizationCountPktTypes_enum::UInt32 begin
    NVML_NVLINK_COUNTER_PKTFILTER_NOP = 1
    NVML_NVLINK_COUNTER_PKTFILTER_READ = 2
    NVML_NVLINK_COUNTER_PKTFILTER_WRITE = 4
    NVML_NVLINK_COUNTER_PKTFILTER_RATOM = 8
    NVML_NVLINK_COUNTER_PKTFILTER_NRATOM = 16
    NVML_NVLINK_COUNTER_PKTFILTER_FLUSH = 32
    NVML_NVLINK_COUNTER_PKTFILTER_RESPDATA = 64
    NVML_NVLINK_COUNTER_PKTFILTER_RESPNODATA = 128
    NVML_NVLINK_COUNTER_PKTFILTER_ALL = 255
end

const nvmlNvLinkUtilizationCountPktTypes_t = nvmlNvLinkUtilizationCountPktTypes_enum

struct nvmlNvLinkUtilizationControl_st
    units::nvmlNvLinkUtilizationCountUnits_t
    pktfilter::nvmlNvLinkUtilizationCountPktTypes_t
end

const nvmlNvLinkUtilizationControl_t = nvmlNvLinkUtilizationControl_st

@cenum nvmlNvLinkCapability_enum::UInt32 begin
    NVML_NVLINK_CAP_P2P_SUPPORTED = 0
    NVML_NVLINK_CAP_SYSMEM_ACCESS = 1
    NVML_NVLINK_CAP_P2P_ATOMICS = 2
    NVML_NVLINK_CAP_SYSMEM_ATOMICS = 3
    NVML_NVLINK_CAP_SLI_BRIDGE = 4
    NVML_NVLINK_CAP_VALID = 5
    NVML_NVLINK_CAP_COUNT = 6
end

const nvmlNvLinkCapability_t = nvmlNvLinkCapability_enum

@cenum nvmlNvLinkErrorCounter_enum::UInt32 begin
    NVML_NVLINK_ERROR_DL_REPLAY = 0
    NVML_NVLINK_ERROR_DL_RECOVERY = 1
    NVML_NVLINK_ERROR_DL_CRC_FLIT = 2
    NVML_NVLINK_ERROR_DL_CRC_DATA = 3
    NVML_NVLINK_ERROR_DL_ECC_DATA = 4
    NVML_NVLINK_ERROR_COUNT = 5
end

const nvmlNvLinkErrorCounter_t = nvmlNvLinkErrorCounter_enum

@cenum nvmlIntNvLinkDeviceType_enum::UInt32 begin
    NVML_NVLINK_DEVICE_TYPE_GPU = 0
    NVML_NVLINK_DEVICE_TYPE_IBMNPU = 1
    NVML_NVLINK_DEVICE_TYPE_SWITCH = 2
    NVML_NVLINK_DEVICE_TYPE_UNKNOWN = 255
end

const nvmlIntNvLinkDeviceType_t = nvmlIntNvLinkDeviceType_enum

@cenum nvmlGpuLevel_enum::UInt32 begin
    NVML_TOPOLOGY_INTERNAL = 0
    NVML_TOPOLOGY_SINGLE = 10
    NVML_TOPOLOGY_MULTIPLE = 20
    NVML_TOPOLOGY_HOSTBRIDGE = 30
    NVML_TOPOLOGY_NODE = 40
    NVML_TOPOLOGY_SYSTEM = 50
end

const nvmlGpuTopologyLevel_t = nvmlGpuLevel_enum

@cenum nvmlGpuP2PStatus_enum::UInt32 begin
    NVML_P2P_STATUS_OK = 0
    NVML_P2P_STATUS_CHIPSET_NOT_SUPPORED = 1
    NVML_P2P_STATUS_CHIPSET_NOT_SUPPORTED = 1
    NVML_P2P_STATUS_GPU_NOT_SUPPORTED = 2
    NVML_P2P_STATUS_IOH_TOPOLOGY_NOT_SUPPORTED = 3
    NVML_P2P_STATUS_DISABLED_BY_REGKEY = 4
    NVML_P2P_STATUS_NOT_SUPPORTED = 5
    NVML_P2P_STATUS_UNKNOWN = 6
end

const nvmlGpuP2PStatus_t = nvmlGpuP2PStatus_enum

@cenum nvmlGpuP2PCapsIndex_enum::UInt32 begin
    NVML_P2P_CAPS_INDEX_READ = 0
    NVML_P2P_CAPS_INDEX_WRITE = 1
    NVML_P2P_CAPS_INDEX_NVLINK = 2
    NVML_P2P_CAPS_INDEX_ATOMICS = 3
    NVML_P2P_CAPS_INDEX_PCI = 4
    NVML_P2P_CAPS_INDEX_PROP = 4
    NVML_P2P_CAPS_INDEX_UNKNOWN = 5
end

const nvmlGpuP2PCapsIndex_t = nvmlGpuP2PCapsIndex_enum

struct nvmlBridgeChipInfo_st
    type::nvmlBridgeChipType_t
    fwVersion::Cuint
end

const nvmlBridgeChipInfo_t = nvmlBridgeChipInfo_st

struct nvmlBridgeChipHierarchy_st
    bridgeCount::Cuchar
    bridgeChipInfo::NTuple{128,nvmlBridgeChipInfo_t}
end

const nvmlBridgeChipHierarchy_t = nvmlBridgeChipHierarchy_st

@cenum nvmlSamplingType_enum::UInt32 begin
    NVML_TOTAL_POWER_SAMPLES = 0
    NVML_GPU_UTILIZATION_SAMPLES = 1
    NVML_MEMORY_UTILIZATION_SAMPLES = 2
    NVML_ENC_UTILIZATION_SAMPLES = 3
    NVML_DEC_UTILIZATION_SAMPLES = 4
    NVML_PROCESSOR_CLK_SAMPLES = 5
    NVML_MEMORY_CLK_SAMPLES = 6
    NVML_MODULE_POWER_SAMPLES = 7
    NVML_JPG_UTILIZATION_SAMPLES = 8
    NVML_OFA_UTILIZATION_SAMPLES = 9
    NVML_SAMPLINGTYPE_COUNT = 10
end

const nvmlSamplingType_t = nvmlSamplingType_enum

@cenum nvmlPcieUtilCounter_enum::UInt32 begin
    NVML_PCIE_UTIL_TX_BYTES = 0
    NVML_PCIE_UTIL_RX_BYTES = 1
    NVML_PCIE_UTIL_COUNT = 2
end

const nvmlPcieUtilCounter_t = nvmlPcieUtilCounter_enum

@cenum nvmlValueType_enum::UInt32 begin
    NVML_VALUE_TYPE_DOUBLE = 0
    NVML_VALUE_TYPE_UNSIGNED_INT = 1
    NVML_VALUE_TYPE_UNSIGNED_LONG = 2
    NVML_VALUE_TYPE_UNSIGNED_LONG_LONG = 3
    NVML_VALUE_TYPE_SIGNED_LONG_LONG = 4
    NVML_VALUE_TYPE_SIGNED_INT = 5
    NVML_VALUE_TYPE_UNSIGNED_SHORT = 6
    NVML_VALUE_TYPE_COUNT = 7
end

const nvmlValueType_t = nvmlValueType_enum

struct nvmlValue_st
    data::NTuple{8,UInt8}
end

function Base.getproperty(x::Ptr{nvmlValue_st}, f::Symbol)
    f === :dVal && return Ptr{Cdouble}(x + 0)
    f === :siVal && return Ptr{Cint}(x + 0)
    f === :uiVal && return Ptr{Cuint}(x + 0)
    f === :ulVal && return Ptr{Culong}(x + 0)
    f === :ullVal && return Ptr{Culonglong}(x + 0)
    f === :sllVal && return Ptr{Clonglong}(x + 0)
    f === :usVal && return Ptr{Cushort}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::nvmlValue_st, f::Symbol)
    r = Ref{nvmlValue_st}(x)
    ptr = Base.unsafe_convert(Ptr{nvmlValue_st}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{nvmlValue_st}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::nvmlValue_st, private::Bool=false)
    return (:dVal, :siVal, :uiVal, :ulVal, :ullVal, :sllVal, :usVal,
            if private
                fieldnames(typeof(x))
            else
                ()
            end...)
end

const nvmlValue_t = nvmlValue_st

struct nvmlSample_st
    data::NTuple{16,UInt8}
end

function Base.getproperty(x::Ptr{nvmlSample_st}, f::Symbol)
    f === :timeStamp && return Ptr{Culonglong}(x + 0)
    f === :sampleValue && return Ptr{nvmlValue_t}(x + 8)
    return getfield(x, f)
end

function Base.getproperty(x::nvmlSample_st, f::Symbol)
    r = Ref{nvmlSample_st}(x)
    ptr = Base.unsafe_convert(Ptr{nvmlSample_st}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{nvmlSample_st}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::nvmlSample_st, private::Bool=false)
    return (:timeStamp, :sampleValue, if private
                fieldnames(typeof(x))
            else
                ()
            end...)
end

const nvmlSample_t = nvmlSample_st

@cenum nvmlPerfPolicyType_enum::UInt32 begin
    NVML_PERF_POLICY_POWER = 0
    NVML_PERF_POLICY_THERMAL = 1
    NVML_PERF_POLICY_SYNC_BOOST = 2
    NVML_PERF_POLICY_BOARD_LIMIT = 3
    NVML_PERF_POLICY_LOW_UTILIZATION = 4
    NVML_PERF_POLICY_RELIABILITY = 5
    NVML_PERF_POLICY_TOTAL_APP_CLOCKS = 10
    NVML_PERF_POLICY_TOTAL_BASE_CLOCKS = 11
    NVML_PERF_POLICY_COUNT = 12
end

const nvmlPerfPolicyType_t = nvmlPerfPolicyType_enum

struct nvmlViolationTime_st
    referenceTime::Culonglong
    violationTime::Culonglong
end

const nvmlViolationTime_t = nvmlViolationTime_st

@cenum nvmlThermalTarget_t::Int32 begin
    NVML_THERMAL_TARGET_NONE = 0
    NVML_THERMAL_TARGET_GPU = 1
    NVML_THERMAL_TARGET_MEMORY = 2
    NVML_THERMAL_TARGET_POWER_SUPPLY = 4
    NVML_THERMAL_TARGET_BOARD = 8
    NVML_THERMAL_TARGET_VCD_BOARD = 9
    NVML_THERMAL_TARGET_VCD_INLET = 10
    NVML_THERMAL_TARGET_VCD_OUTLET = 11
    NVML_THERMAL_TARGET_ALL = 15
    NVML_THERMAL_TARGET_UNKNOWN = -1
end

@cenum nvmlThermalController_t::Int32 begin
    NVML_THERMAL_CONTROLLER_NONE = 0
    NVML_THERMAL_CONTROLLER_GPU_INTERNAL = 1
    NVML_THERMAL_CONTROLLER_ADM1032 = 2
    NVML_THERMAL_CONTROLLER_ADT7461 = 3
    NVML_THERMAL_CONTROLLER_MAX6649 = 4
    NVML_THERMAL_CONTROLLER_MAX1617 = 5
    NVML_THERMAL_CONTROLLER_LM99 = 6
    NVML_THERMAL_CONTROLLER_LM89 = 7
    NVML_THERMAL_CONTROLLER_LM64 = 8
    NVML_THERMAL_CONTROLLER_G781 = 9
    NVML_THERMAL_CONTROLLER_ADT7473 = 10
    NVML_THERMAL_CONTROLLER_SBMAX6649 = 11
    NVML_THERMAL_CONTROLLER_VBIOSEVT = 12
    NVML_THERMAL_CONTROLLER_OS = 13
    NVML_THERMAL_CONTROLLER_NVSYSCON_CANOAS = 14
    NVML_THERMAL_CONTROLLER_NVSYSCON_E551 = 15
    NVML_THERMAL_CONTROLLER_MAX6649R = 16
    NVML_THERMAL_CONTROLLER_ADT7473S = 17
    NVML_THERMAL_CONTROLLER_UNKNOWN = -1
end

struct var"##Ctag#272"
    controller::nvmlThermalController_t
    defaultMinTemp::Cint
    defaultMaxTemp::Cint
    currentTemp::Cint
    target::nvmlThermalTarget_t
end
function Base.getproperty(x::Ptr{var"##Ctag#272"}, f::Symbol)
    f === :controller && return Ptr{nvmlThermalController_t}(x + 0)
    f === :defaultMinTemp && return Ptr{Cint}(x + 4)
    f === :defaultMaxTemp && return Ptr{Cint}(x + 8)
    f === :currentTemp && return Ptr{Cint}(x + 12)
    f === :target && return Ptr{nvmlThermalTarget_t}(x + 16)
    return getfield(x, f)
end

function Base.getproperty(x::var"##Ctag#272", f::Symbol)
    r = Ref{var"##Ctag#272"}(x)
    ptr = Base.unsafe_convert(Ptr{var"##Ctag#272"}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{var"##Ctag#272"}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

struct nvmlGpuThermalSettings_t
    data::NTuple{64,UInt8}
end

function Base.getproperty(x::Ptr{nvmlGpuThermalSettings_t}, f::Symbol)
    f === :count && return Ptr{Cuint}(x + 0)
    f === :sensor && return Ptr{NTuple{3,var"##Ctag#272"}}(x + 4)
    return getfield(x, f)
end

function Base.getproperty(x::nvmlGpuThermalSettings_t, f::Symbol)
    r = Ref{nvmlGpuThermalSettings_t}(x)
    ptr = Base.unsafe_convert(Ptr{nvmlGpuThermalSettings_t}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{nvmlGpuThermalSettings_t}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::nvmlGpuThermalSettings_t, private::Bool=false)
    return (:count, :sensor, if private
                fieldnames(typeof(x))
            else
                ()
            end...)
end

@cenum nvmlCoolerControl_enum::UInt32 begin
    NVML_THERMAL_COOLER_SIGNAL_NONE = 0
    NVML_THERMAL_COOLER_SIGNAL_TOGGLE = 1
    NVML_THERMAL_COOLER_SIGNAL_VARIABLE = 2
    NVML_THERMAL_COOLER_SIGNAL_COUNT = 3
end

const nvmlCoolerControl_t = nvmlCoolerControl_enum

@cenum nvmlCoolerTarget_enum::UInt32 begin
    NVML_THERMAL_COOLER_TARGET_NONE = 1
    NVML_THERMAL_COOLER_TARGET_GPU = 2
    NVML_THERMAL_COOLER_TARGET_MEMORY = 4
    NVML_THERMAL_COOLER_TARGET_POWER_SUPPLY = 8
    NVML_THERMAL_COOLER_TARGET_GPU_RELATED = 14
end

const nvmlCoolerTarget_t = nvmlCoolerTarget_enum

struct nvmlCoolerInfo_v1_t
    version::Cuint
    index::Cuint
    signalType::nvmlCoolerControl_t
    target::nvmlCoolerTarget_t
end

const nvmlCoolerInfo_t = nvmlCoolerInfo_v1_t

@cenum nvmlUUIDType_t::UInt32 begin
    NVML_UUID_TYPE_NONE = 0
    NVML_UUID_TYPE_ASCII = 1
    NVML_UUID_TYPE_BINARY = 2
end

struct nvmlUUIDValue_t
    data::NTuple{41,UInt8}
end

function Base.getproperty(x::Ptr{nvmlUUIDValue_t}, f::Symbol)
    f === :str && return Ptr{NTuple{41,Cchar}}(x + 0)
    f === :bytes && return Ptr{NTuple{16,Cuchar}}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::nvmlUUIDValue_t, f::Symbol)
    r = Ref{nvmlUUIDValue_t}(x)
    ptr = Base.unsafe_convert(Ptr{nvmlUUIDValue_t}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{nvmlUUIDValue_t}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::nvmlUUIDValue_t, private::Bool=false)
    return (:str, :bytes, if private
                fieldnames(typeof(x))
            else
                ()
            end...)
end

struct nvmlUUID_v1_t
    data::NTuple{52,UInt8}
end

function Base.getproperty(x::Ptr{nvmlUUID_v1_t}, f::Symbol)
    f === :version && return Ptr{Cuint}(x + 0)
    f === :type && return Ptr{Cuint}(x + 4)
    f === :value && return Ptr{nvmlUUIDValue_t}(x + 8)
    return getfield(x, f)
end

function Base.getproperty(x::nvmlUUID_v1_t, f::Symbol)
    r = Ref{nvmlUUID_v1_t}(x)
    ptr = Base.unsafe_convert(Ptr{nvmlUUID_v1_t}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{nvmlUUID_v1_t}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::nvmlUUID_v1_t, private::Bool=false)
    return (:version, :type, :value, if private
                fieldnames(typeof(x))
            else
                ()
            end...)
end

const nvmlUUID_t = nvmlUUID_v1_t

struct nvmlPdi_v1_t
    version::Cuint
    value::Culonglong
end

const nvmlPdi_t = nvmlPdi_v1_t

@cenum nvmlEnableState_enum::UInt32 begin
    NVML_FEATURE_DISABLED = 0
    NVML_FEATURE_ENABLED = 1
end

const nvmlEnableState_t = nvmlEnableState_enum

struct nvmlDramEncryptionInfo_v1_t
    version::Cuint
    encryptionState::nvmlEnableState_t
end

const nvmlDramEncryptionInfo_t = nvmlDramEncryptionInfo_v1_t

@cenum nvmlBrandType_enum::UInt32 begin
    NVML_BRAND_UNKNOWN = 0
    NVML_BRAND_QUADRO = 1
    NVML_BRAND_TESLA = 2
    NVML_BRAND_NVS = 3
    NVML_BRAND_GRID = 4
    NVML_BRAND_GEFORCE = 5
    NVML_BRAND_TITAN = 6
    NVML_BRAND_NVIDIA_VAPPS = 7
    NVML_BRAND_NVIDIA_VPC = 8
    NVML_BRAND_NVIDIA_VCS = 9
    NVML_BRAND_NVIDIA_VWS = 10
    NVML_BRAND_NVIDIA_CLOUD_GAMING = 11
    NVML_BRAND_NVIDIA_VGAMING = 11
    NVML_BRAND_QUADRO_RTX = 12
    NVML_BRAND_NVIDIA_RTX = 13
    NVML_BRAND_NVIDIA = 14
    NVML_BRAND_GEFORCE_RTX = 15
    NVML_BRAND_TITAN_RTX = 16
    NVML_BRAND_COUNT = 18
end

const nvmlBrandType_t = nvmlBrandType_enum

@cenum nvmlTemperatureThresholds_enum::UInt32 begin
    NVML_TEMPERATURE_THRESHOLD_SHUTDOWN = 0
    NVML_TEMPERATURE_THRESHOLD_SLOWDOWN = 1
    NVML_TEMPERATURE_THRESHOLD_MEM_MAX = 2
    NVML_TEMPERATURE_THRESHOLD_GPU_MAX = 3
    NVML_TEMPERATURE_THRESHOLD_ACOUSTIC_MIN = 4
    NVML_TEMPERATURE_THRESHOLD_ACOUSTIC_CURR = 5
    NVML_TEMPERATURE_THRESHOLD_ACOUSTIC_MAX = 6
    NVML_TEMPERATURE_THRESHOLD_GPS_CURR = 7
    NVML_TEMPERATURE_THRESHOLD_COUNT = 8
end

const nvmlTemperatureThresholds_t = nvmlTemperatureThresholds_enum

@cenum nvmlTemperatureSensors_enum::UInt32 begin
    NVML_TEMPERATURE_GPU = 0
    NVML_TEMPERATURE_COUNT = 1
end

const nvmlTemperatureSensors_t = nvmlTemperatureSensors_enum

struct nvmlMarginTemperature_v1_t
    version::Cuint
    marginTemperature::Cint
end

const nvmlMarginTemperature_t = nvmlMarginTemperature_v1_t

@cenum nvmlComputeMode_enum::UInt32 begin
    NVML_COMPUTEMODE_DEFAULT = 0
    NVML_COMPUTEMODE_EXCLUSIVE_THREAD = 1
    NVML_COMPUTEMODE_PROHIBITED = 2
    NVML_COMPUTEMODE_EXCLUSIVE_PROCESS = 3
    NVML_COMPUTEMODE_COUNT = 4
end

const nvmlComputeMode_t = nvmlComputeMode_enum

struct nvmlClkMonFaultInfo_struct
    clkApiDomain::Cuint
    clkDomainFaultMask::Cuint
end

const nvmlClkMonFaultInfo_t = nvmlClkMonFaultInfo_struct

struct nvmlClkMonStatus_status
    bGlobalStatus::Cuint
    clkMonListSize::Cuint
    clkMonList::NTuple{32,nvmlClkMonFaultInfo_t}
end

const nvmlClkMonStatus_t = nvmlClkMonStatus_status

@cenum nvmlNvlinkVersion_enum::UInt32 begin
    NVML_NVLINK_VERSION_INVALID = 0
    NVML_NVLINK_VERSION_1_0 = 1
    NVML_NVLINK_VERSION_2_0 = 2
    NVML_NVLINK_VERSION_2_2 = 3
    NVML_NVLINK_VERSION_3_0 = 4
    NVML_NVLINK_VERSION_3_1 = 5
    NVML_NVLINK_VERSION_4_0 = 6
    NVML_NVLINK_VERSION_5_0 = 7
end

const nvmlNvlinkVersion_t = nvmlNvlinkVersion_enum

@cenum nvmlEccCounterType_enum::UInt32 begin
    NVML_VOLATILE_ECC = 0
    NVML_AGGREGATE_ECC = 1
    NVML_ECC_COUNTER_TYPE_COUNT = 2
end

const nvmlEccCounterType_t = nvmlEccCounterType_enum

@cenum nvmlClockType_enum::UInt32 begin
    NVML_CLOCK_GRAPHICS = 0
    NVML_CLOCK_SM = 1
    NVML_CLOCK_MEM = 2
    NVML_CLOCK_VIDEO = 3
    NVML_CLOCK_COUNT = 4
end

const nvmlClockType_t = nvmlClockType_enum

@cenum nvmlClockId_enum::UInt32 begin
    NVML_CLOCK_ID_CURRENT = 0
    NVML_CLOCK_ID_APP_CLOCK_TARGET = 1
    NVML_CLOCK_ID_APP_CLOCK_DEFAULT = 2
    NVML_CLOCK_ID_CUSTOMER_BOOST_MAX = 3
    NVML_CLOCK_ID_COUNT = 4
end

const nvmlClockId_t = nvmlClockId_enum

@cenum nvmlDriverModel_enum::UInt32 begin
    NVML_DRIVER_WDDM = 0
    NVML_DRIVER_WDM = 1
    NVML_DRIVER_MCDM = 2
end

const nvmlDriverModel_t = nvmlDriverModel_enum

@cenum nvmlPStates_enum::UInt32 begin
    NVML_PSTATE_0 = 0
    NVML_PSTATE_1 = 1
    NVML_PSTATE_2 = 2
    NVML_PSTATE_3 = 3
    NVML_PSTATE_4 = 4
    NVML_PSTATE_5 = 5
    NVML_PSTATE_6 = 6
    NVML_PSTATE_7 = 7
    NVML_PSTATE_8 = 8
    NVML_PSTATE_9 = 9
    NVML_PSTATE_10 = 10
    NVML_PSTATE_11 = 11
    NVML_PSTATE_12 = 12
    NVML_PSTATE_13 = 13
    NVML_PSTATE_14 = 14
    NVML_PSTATE_15 = 15
    NVML_PSTATE_UNKNOWN = 32
end

const nvmlPstates_t = nvmlPStates_enum

struct nvmlClockOffset_v1_t
    version::Cuint
    type::nvmlClockType_t
    pstate::nvmlPstates_t
    clockOffsetMHz::Cint
    minClockOffsetMHz::Cint
    maxClockOffsetMHz::Cint
end

const nvmlClockOffset_t = nvmlClockOffset_v1_t

struct nvmlFanSpeedInfo_v1_t
    version::Cuint
    fan::Cuint
    speed::Cuint
end

const nvmlFanSpeedInfo_t = nvmlFanSpeedInfo_v1_t

struct nvmlDevicePerfModes_v1_t
    version::Cuint
    str::NTuple{2048,Cchar}
end

const nvmlDevicePerfModes_t = nvmlDevicePerfModes_v1_t

struct nvmlDeviceCurrentClockFreqs_v1_t
    version::Cuint
    str::NTuple{2048,Cchar}
end

const nvmlDeviceCurrentClockFreqs_t = nvmlDeviceCurrentClockFreqs_v1_t

struct nvmlDevicePowerMizerModes_v1_t
    currentMode::Cuint
    mode::Cuint
    supportedPowerMizerModes::Cuint
end

@cenum nvmlGom_enum::UInt32 begin
    NVML_GOM_ALL_ON = 0
    NVML_GOM_COMPUTE = 1
    NVML_GOM_LOW_DP = 2
end

const nvmlGpuOperationMode_t = nvmlGom_enum

@cenum nvmlInforomObject_enum::UInt32 begin
    NVML_INFOROM_OEM = 0
    NVML_INFOROM_ECC = 1
    NVML_INFOROM_POWER = 2
    NVML_INFOROM_DEN = 3
    NVML_INFOROM_COUNT = 4
end

const nvmlInforomObject_t = nvmlInforomObject_enum

@cenum nvmlReturn_enum::UInt32 begin
    NVML_SUCCESS = 0
    NVML_ERROR_UNINITIALIZED = 1
    NVML_ERROR_INVALID_ARGUMENT = 2
    NVML_ERROR_NOT_SUPPORTED = 3
    NVML_ERROR_NO_PERMISSION = 4
    NVML_ERROR_ALREADY_INITIALIZED = 5
    NVML_ERROR_NOT_FOUND = 6
    NVML_ERROR_INSUFFICIENT_SIZE = 7
    NVML_ERROR_INSUFFICIENT_POWER = 8
    NVML_ERROR_DRIVER_NOT_LOADED = 9
    NVML_ERROR_TIMEOUT = 10
    NVML_ERROR_IRQ_ISSUE = 11
    NVML_ERROR_LIBRARY_NOT_FOUND = 12
    NVML_ERROR_FUNCTION_NOT_FOUND = 13
    NVML_ERROR_CORRUPTED_INFOROM = 14
    NVML_ERROR_GPU_IS_LOST = 15
    NVML_ERROR_RESET_REQUIRED = 16
    NVML_ERROR_OPERATING_SYSTEM = 17
    NVML_ERROR_LIB_RM_VERSION_MISMATCH = 18
    NVML_ERROR_IN_USE = 19
    NVML_ERROR_MEMORY = 20
    NVML_ERROR_NO_DATA = 21
    NVML_ERROR_VGPU_ECC_NOT_SUPPORTED = 22
    NVML_ERROR_INSUFFICIENT_RESOURCES = 23
    NVML_ERROR_FREQ_NOT_SUPPORTED = 24
    NVML_ERROR_ARGUMENT_VERSION_MISMATCH = 25
    NVML_ERROR_DEPRECATED = 26
    NVML_ERROR_NOT_READY = 27
    NVML_ERROR_GPU_NOT_FOUND = 28
    NVML_ERROR_INVALID_STATE = 29
    NVML_ERROR_RESET_TYPE_NOT_SUPPORTED = 30
    NVML_ERROR_UNKNOWN = 999
end

const nvmlReturn_t = nvmlReturn_enum

@cenum nvmlMemoryLocation_enum::UInt32 begin
    NVML_MEMORY_LOCATION_L1_CACHE = 0
    NVML_MEMORY_LOCATION_L2_CACHE = 1
    NVML_MEMORY_LOCATION_DRAM = 2
    NVML_MEMORY_LOCATION_DEVICE_MEMORY = 2
    NVML_MEMORY_LOCATION_REGISTER_FILE = 3
    NVML_MEMORY_LOCATION_TEXTURE_MEMORY = 4
    NVML_MEMORY_LOCATION_TEXTURE_SHM = 5
    NVML_MEMORY_LOCATION_CBU = 6
    NVML_MEMORY_LOCATION_SRAM = 7
    NVML_MEMORY_LOCATION_COUNT = 8
end

const nvmlMemoryLocation_t = nvmlMemoryLocation_enum

@cenum nvmlPageRetirementCause_enum::UInt32 begin
    NVML_PAGE_RETIREMENT_CAUSE_MULTIPLE_SINGLE_BIT_ECC_ERRORS = 0
    NVML_PAGE_RETIREMENT_CAUSE_DOUBLE_BIT_ECC_ERROR = 1
    NVML_PAGE_RETIREMENT_CAUSE_COUNT = 2
end

const nvmlPageRetirementCause_t = nvmlPageRetirementCause_enum

@cenum nvmlRestrictedAPI_enum::UInt32 begin
    NVML_RESTRICTED_API_SET_APPLICATION_CLOCKS = 0
    NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS = 1
    NVML_RESTRICTED_API_COUNT = 2
end

const nvmlRestrictedAPI_t = nvmlRestrictedAPI_enum

struct nvmlProcessUtilizationSample_st
    pid::Cuint
    timeStamp::Culonglong
    smUtil::Cuint
    memUtil::Cuint
    encUtil::Cuint
    decUtil::Cuint
end

const nvmlProcessUtilizationSample_t = nvmlProcessUtilizationSample_st

struct nvmlProcessUtilizationInfo_v1_t
    timeStamp::Culonglong
    pid::Cuint
    smUtil::Cuint
    memUtil::Cuint
    encUtil::Cuint
    decUtil::Cuint
    jpgUtil::Cuint
    ofaUtil::Cuint
end

struct nvmlProcessesUtilizationInfo_v1_t
    version::Cuint
    processSamplesCount::Cuint
    lastSeenTimeStamp::Culonglong
    procUtilArray::Ptr{nvmlProcessUtilizationInfo_v1_t}
end

const nvmlProcessesUtilizationInfo_t = nvmlProcessesUtilizationInfo_v1_t

struct nvmlEccSramErrorStatus_v1_t
    version::Cuint
    aggregateUncParity::Culonglong
    aggregateUncSecDed::Culonglong
    aggregateCor::Culonglong
    volatileUncParity::Culonglong
    volatileUncSecDed::Culonglong
    volatileCor::Culonglong
    aggregateUncBucketL2::Culonglong
    aggregateUncBucketSm::Culonglong
    aggregateUncBucketPcie::Culonglong
    aggregateUncBucketMcu::Culonglong
    aggregateUncBucketOther::Culonglong
    bThresholdExceeded::Cuint
end

const nvmlEccSramErrorStatus_t = nvmlEccSramErrorStatus_v1_t

struct nvmlPlatformInfo_v1_t
    version::Cuint
    ibGuid::NTuple{16,Cuchar}
    rackGuid::NTuple{16,Cuchar}
    chassisPhysicalSlotNumber::Cuchar
    computeSlotIndex::Cuchar
    nodeIndex::Cuchar
    peerType::Cuchar
    moduleId::Cuchar
end

struct nvmlPlatformInfo_v2_t
    version::Cuint
    ibGuid::NTuple{16,Cuchar}
    chassisSerialNumber::NTuple{16,Cuchar}
    slotNumber::Cuchar
    trayIndex::Cuchar
    hostId::Cuchar
    peerType::Cuchar
    moduleId::Cuchar
end

const nvmlPlatformInfo_t = nvmlPlatformInfo_v2_t

struct nvmlHostname_v1_t
    value::NTuple{64,Cchar}
end

struct nvmlEccSramUniqueUncorrectedErrorEntry_v1_t
    unit::Cuint
    location::Cuint
    sublocation::Cuint
    extlocation::Cuint
    address::Cuint
    isParity::Cuint
    count::Cuint
end

struct nvmlEccSramUniqueUncorrectedErrorCounts_v1_t
    version::Cuint
    entryCount::Cuint
    entries::Ptr{nvmlEccSramUniqueUncorrectedErrorEntry_v1_t}
end

const nvmlEccSramUniqueUncorrectedErrorCounts_t = nvmlEccSramUniqueUncorrectedErrorCounts_v1_t

const nvmlDeviceArchitecture_t = Cuint

const nvmlBusType_t = Cuint

const nvmlFanControlPolicy_t = Cuint

const nvmlPowerSource_t = Cuint

@cenum nvmlGpuUtilizationDomainId_t::UInt32 begin
    NVML_GPU_UTILIZATION_DOMAIN_GPU = 0
    NVML_GPU_UTILIZATION_DOMAIN_FB = 1
    NVML_GPU_UTILIZATION_DOMAIN_VID = 2
    NVML_GPU_UTILIZATION_DOMAIN_BUS = 3
end

struct var"##Ctag#270"
    bIsPresent::Cuint
    percentage::Cuint
    incThreshold::Cuint
    decThreshold::Cuint
end
function Base.getproperty(x::Ptr{var"##Ctag#270"}, f::Symbol)
    f === :bIsPresent && return Ptr{Cuint}(x + 0)
    f === :percentage && return Ptr{Cuint}(x + 4)
    f === :incThreshold && return Ptr{Cuint}(x + 8)
    f === :decThreshold && return Ptr{Cuint}(x + 12)
    return getfield(x, f)
end

function Base.getproperty(x::var"##Ctag#270", f::Symbol)
    r = Ref{var"##Ctag#270"}(x)
    ptr = Base.unsafe_convert(Ptr{var"##Ctag#270"}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{var"##Ctag#270"}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

struct nvmlGpuDynamicPstatesInfo_st
    data::NTuple{132,UInt8}
end

function Base.getproperty(x::Ptr{nvmlGpuDynamicPstatesInfo_st}, f::Symbol)
    f === :flags && return Ptr{Cuint}(x + 0)
    f === :utilization && return Ptr{NTuple{8,var"##Ctag#270"}}(x + 4)
    return getfield(x, f)
end

function Base.getproperty(x::nvmlGpuDynamicPstatesInfo_st, f::Symbol)
    r = Ref{nvmlGpuDynamicPstatesInfo_st}(x)
    ptr = Base.unsafe_convert(Ptr{nvmlGpuDynamicPstatesInfo_st}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{nvmlGpuDynamicPstatesInfo_st}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::nvmlGpuDynamicPstatesInfo_st, private::Bool=false)
    return (:flags, :utilization, if private
                fieldnames(typeof(x))
            else
                ()
            end...)
end

const nvmlGpuDynamicPstatesInfo_t = nvmlGpuDynamicPstatesInfo_st

const nvmlPowerScopeType_t = Cuchar

struct nvmlPowerValue_v2_t
    version::Cuint
    powerScope::nvmlPowerScopeType_t
    powerValueMw::Cuint
end

@cenum nvmlGpuVirtualizationMode::UInt32 begin
    NVML_GPU_VIRTUALIZATION_MODE_NONE = 0
    NVML_GPU_VIRTUALIZATION_MODE_PASSTHROUGH = 1
    NVML_GPU_VIRTUALIZATION_MODE_VGPU = 2
    NVML_GPU_VIRTUALIZATION_MODE_HOST_VGPU = 3
    NVML_GPU_VIRTUALIZATION_MODE_HOST_VSGA = 4
end

const nvmlGpuVirtualizationMode_t = nvmlGpuVirtualizationMode

@cenum nvmlHostVgpuMode_enum::UInt32 begin
    NVML_HOST_VGPU_MODE_NON_SRIOV = 0
    NVML_HOST_VGPU_MODE_SRIOV = 1
end

const nvmlHostVgpuMode_t = nvmlHostVgpuMode_enum

@cenum nvmlVgpuVmIdType::UInt32 begin
    NVML_VGPU_VM_ID_DOMAIN_ID = 0
    NVML_VGPU_VM_ID_UUID = 1
end

const nvmlVgpuVmIdType_t = nvmlVgpuVmIdType

@cenum nvmlVgpuGuestInfoState_enum::UInt32 begin
    NVML_VGPU_INSTANCE_GUEST_INFO_STATE_UNINITIALIZED = 0
    NVML_VGPU_INSTANCE_GUEST_INFO_STATE_INITIALIZED = 1
end

const nvmlVgpuGuestInfoState_t = nvmlVgpuGuestInfoState_enum

@cenum nvmlGridLicenseFeatureCode_t::UInt32 begin
    NVML_GRID_LICENSE_FEATURE_CODE_UNKNOWN = 0
    NVML_GRID_LICENSE_FEATURE_CODE_VGPU = 1
    NVML_GRID_LICENSE_FEATURE_CODE_NVIDIA_RTX = 2
    NVML_GRID_LICENSE_FEATURE_CODE_VWORKSTATION = 2
    NVML_GRID_LICENSE_FEATURE_CODE_GAMING = 3
    NVML_GRID_LICENSE_FEATURE_CODE_COMPUTE = 4
end

@cenum nvmlVgpuCapability_enum::UInt32 begin
    NVML_VGPU_CAP_NVLINK_P2P = 0
    NVML_VGPU_CAP_GPUDIRECT = 1
    NVML_VGPU_CAP_MULTI_VGPU_EXCLUSIVE = 2
    NVML_VGPU_CAP_EXCLUSIVE_TYPE = 3
    NVML_VGPU_CAP_EXCLUSIVE_SIZE = 4
    NVML_VGPU_CAP_COUNT = 5
end

const nvmlVgpuCapability_t = nvmlVgpuCapability_enum

@cenum nvmlVgpuDriverCapability_enum::UInt32 begin
    NVML_VGPU_DRIVER_CAP_HETEROGENEOUS_MULTI_VGPU = 0
    NVML_VGPU_DRIVER_CAP_WARM_UPDATE = 1
    NVML_VGPU_DRIVER_CAP_COUNT = 2
end

const nvmlVgpuDriverCapability_t = nvmlVgpuDriverCapability_enum

@cenum nvmlDeviceVgpuCapability_enum::UInt32 begin
    NVML_DEVICE_VGPU_CAP_FRACTIONAL_MULTI_VGPU = 0
    NVML_DEVICE_VGPU_CAP_HETEROGENEOUS_TIMESLICE_PROFILES = 1
    NVML_DEVICE_VGPU_CAP_HETEROGENEOUS_TIMESLICE_SIZES = 2
    NVML_DEVICE_VGPU_CAP_READ_DEVICE_BUFFER_BW = 3
    NVML_DEVICE_VGPU_CAP_WRITE_DEVICE_BUFFER_BW = 4
    NVML_DEVICE_VGPU_CAP_DEVICE_STREAMING = 5
    NVML_DEVICE_VGPU_CAP_MINI_QUARTER_GPU = 6
    NVML_DEVICE_VGPU_CAP_COMPUTE_MEDIA_ENGINE_GPU = 7
    NVML_DEVICE_VGPU_CAP_WARM_UPDATE = 8
    NVML_DEVICE_VGPU_CAP_HOMOGENEOUS_PLACEMENTS = 9
    NVML_DEVICE_VGPU_CAP_MIG_TIMESLICING_SUPPORTED = 10
    NVML_DEVICE_VGPU_CAP_MIG_TIMESLICING_ENABLED = 11
    NVML_DEVICE_VGPU_CAP_COUNT = 12
end

const nvmlDeviceVgpuCapability_t = nvmlDeviceVgpuCapability_enum

const nvmlVgpuTypeId_t = Cuint

const nvmlVgpuInstance_t = Cuint

struct nvmlVgpuHeterogeneousMode_v1_t
    version::Cuint
    mode::Cuint
end

const nvmlVgpuHeterogeneousMode_t = nvmlVgpuHeterogeneousMode_v1_t

struct nvmlVgpuPlacementId_v1_t
    version::Cuint
    placementId::Cuint
end

const nvmlVgpuPlacementId_t = nvmlVgpuPlacementId_v1_t

struct nvmlVgpuPlacementList_v1_t
    version::Cuint
    placementSize::Cuint
    count::Cuint
    placementIds::Ptr{Cuint}
end

struct nvmlVgpuPlacementList_v2_t
    version::Cuint
    placementSize::Cuint
    count::Cuint
    placementIds::Ptr{Cuint}
    mode::Cuint
end

const nvmlVgpuPlacementList_t = nvmlVgpuPlacementList_v2_t

struct nvmlVgpuTypeBar1Info_v1_t
    version::Cuint
    bar1Size::Culonglong
end

const nvmlVgpuTypeBar1Info_t = nvmlVgpuTypeBar1Info_v1_t

struct nvmlVgpuInstanceUtilizationSample_st
    data::NTuple{48,UInt8}
end

function Base.getproperty(x::Ptr{nvmlVgpuInstanceUtilizationSample_st}, f::Symbol)
    f === :vgpuInstance && return Ptr{nvmlVgpuInstance_t}(x + 0)
    f === :timeStamp && return Ptr{Culonglong}(x + 8)
    f === :smUtil && return Ptr{nvmlValue_t}(x + 16)
    f === :memUtil && return Ptr{nvmlValue_t}(x + 24)
    f === :encUtil && return Ptr{nvmlValue_t}(x + 32)
    f === :decUtil && return Ptr{nvmlValue_t}(x + 40)
    return getfield(x, f)
end

function Base.getproperty(x::nvmlVgpuInstanceUtilizationSample_st, f::Symbol)
    r = Ref{nvmlVgpuInstanceUtilizationSample_st}(x)
    ptr = Base.unsafe_convert(Ptr{nvmlVgpuInstanceUtilizationSample_st}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{nvmlVgpuInstanceUtilizationSample_st}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::nvmlVgpuInstanceUtilizationSample_st, private::Bool=false)
    return (:vgpuInstance, :timeStamp, :smUtil, :memUtil, :encUtil, :decUtil,
            if private
                fieldnames(typeof(x))
            else
                ()
            end...)
end

const nvmlVgpuInstanceUtilizationSample_t = nvmlVgpuInstanceUtilizationSample_st

struct nvmlVgpuInstanceUtilizationInfo_v1_t
    data::NTuple{64,UInt8}
end

function Base.getproperty(x::Ptr{nvmlVgpuInstanceUtilizationInfo_v1_t}, f::Symbol)
    f === :timeStamp && return Ptr{Culonglong}(x + 0)
    f === :vgpuInstance && return Ptr{nvmlVgpuInstance_t}(x + 8)
    f === :smUtil && return Ptr{nvmlValue_t}(x + 16)
    f === :memUtil && return Ptr{nvmlValue_t}(x + 24)
    f === :encUtil && return Ptr{nvmlValue_t}(x + 32)
    f === :decUtil && return Ptr{nvmlValue_t}(x + 40)
    f === :jpgUtil && return Ptr{nvmlValue_t}(x + 48)
    f === :ofaUtil && return Ptr{nvmlValue_t}(x + 56)
    return getfield(x, f)
end

function Base.getproperty(x::nvmlVgpuInstanceUtilizationInfo_v1_t, f::Symbol)
    r = Ref{nvmlVgpuInstanceUtilizationInfo_v1_t}(x)
    ptr = Base.unsafe_convert(Ptr{nvmlVgpuInstanceUtilizationInfo_v1_t}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{nvmlVgpuInstanceUtilizationInfo_v1_t}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::nvmlVgpuInstanceUtilizationInfo_v1_t, private::Bool=false)
    return (:timeStamp, :vgpuInstance, :smUtil, :memUtil, :encUtil, :decUtil, :jpgUtil,
            :ofaUtil, if private
                fieldnames(typeof(x))
            else
                ()
            end...)
end

struct nvmlVgpuInstancesUtilizationInfo_v1_t
    version::Cuint
    sampleValType::nvmlValueType_t
    vgpuInstanceCount::Cuint
    lastSeenTimeStamp::Culonglong
    vgpuUtilArray::Ptr{nvmlVgpuInstanceUtilizationInfo_v1_t}
end

const nvmlVgpuInstancesUtilizationInfo_t = nvmlVgpuInstancesUtilizationInfo_v1_t

struct nvmlVgpuProcessUtilizationSample_st
    vgpuInstance::nvmlVgpuInstance_t
    pid::Cuint
    processName::NTuple{64,Cchar}
    timeStamp::Culonglong
    smUtil::Cuint
    memUtil::Cuint
    encUtil::Cuint
    decUtil::Cuint
end

const nvmlVgpuProcessUtilizationSample_t = nvmlVgpuProcessUtilizationSample_st

struct nvmlVgpuProcessUtilizationInfo_v1_t
    processName::NTuple{64,Cchar}
    timeStamp::Culonglong
    vgpuInstance::nvmlVgpuInstance_t
    pid::Cuint
    smUtil::Cuint
    memUtil::Cuint
    encUtil::Cuint
    decUtil::Cuint
    jpgUtil::Cuint
    ofaUtil::Cuint
end

struct nvmlVgpuProcessesUtilizationInfo_v1_t
    version::Cuint
    vgpuProcessCount::Cuint
    lastSeenTimeStamp::Culonglong
    vgpuProcUtilArray::Ptr{nvmlVgpuProcessUtilizationInfo_v1_t}
end

const nvmlVgpuProcessesUtilizationInfo_t = nvmlVgpuProcessesUtilizationInfo_v1_t

struct nvmlVgpuRuntimeState_v1_t
    version::Cuint
    size::Culonglong
end

const nvmlVgpuRuntimeState_t = nvmlVgpuRuntimeState_v1_t

struct nvmlVgpuSchedulerParams_t
    data::NTuple{8,UInt8}
end

function Base.getproperty(x::Ptr{nvmlVgpuSchedulerParams_t}, f::Symbol)
    f === :vgpuSchedDataWithARR && return Ptr{var"##Ctag#268"}(x + 0)
    f === :vgpuSchedData && return Ptr{var"##Ctag#269"}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::nvmlVgpuSchedulerParams_t, f::Symbol)
    r = Ref{nvmlVgpuSchedulerParams_t}(x)
    ptr = Base.unsafe_convert(Ptr{nvmlVgpuSchedulerParams_t}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{nvmlVgpuSchedulerParams_t}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::nvmlVgpuSchedulerParams_t, private::Bool=false)
    return (:vgpuSchedDataWithARR, :vgpuSchedData, if private
                fieldnames(typeof(x))
            else
                ()
            end...)
end

struct nvmlVgpuSchedulerLogEntries_st
    timestamp::Culonglong
    timeRunTotal::Culonglong
    timeRun::Culonglong
    swRunlistId::Cuint
    targetTimeSlice::Culonglong
    cumulativePreemptionTime::Culonglong
end

const nvmlVgpuSchedulerLogEntry_t = nvmlVgpuSchedulerLogEntries_st

struct nvmlVgpuSchedulerLog_st
    data::NTuple{9624,UInt8}
end

function Base.getproperty(x::Ptr{nvmlVgpuSchedulerLog_st}, f::Symbol)
    f === :engineId && return Ptr{Cuint}(x + 0)
    f === :schedulerPolicy && return Ptr{Cuint}(x + 4)
    f === :arrMode && return Ptr{Cuint}(x + 8)
    f === :schedulerParams && return Ptr{nvmlVgpuSchedulerParams_t}(x + 12)
    f === :entriesCount && return Ptr{Cuint}(x + 20)
    f === :logEntries && return Ptr{NTuple{200,nvmlVgpuSchedulerLogEntry_t}}(x + 24)
    return getfield(x, f)
end

function Base.getproperty(x::nvmlVgpuSchedulerLog_st, f::Symbol)
    r = Ref{nvmlVgpuSchedulerLog_st}(x)
    ptr = Base.unsafe_convert(Ptr{nvmlVgpuSchedulerLog_st}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{nvmlVgpuSchedulerLog_st}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::nvmlVgpuSchedulerLog_st, private::Bool=false)
    return (:engineId, :schedulerPolicy, :arrMode, :schedulerParams, :entriesCount,
            :logEntries, if private
                fieldnames(typeof(x))
            else
                ()
            end...)
end

const nvmlVgpuSchedulerLog_t = nvmlVgpuSchedulerLog_st

struct nvmlVgpuSchedulerGetState_st
    data::NTuple{16,UInt8}
end

function Base.getproperty(x::Ptr{nvmlVgpuSchedulerGetState_st}, f::Symbol)
    f === :schedulerPolicy && return Ptr{Cuint}(x + 0)
    f === :arrMode && return Ptr{Cuint}(x + 4)
    f === :schedulerParams && return Ptr{nvmlVgpuSchedulerParams_t}(x + 8)
    return getfield(x, f)
end

function Base.getproperty(x::nvmlVgpuSchedulerGetState_st, f::Symbol)
    r = Ref{nvmlVgpuSchedulerGetState_st}(x)
    ptr = Base.unsafe_convert(Ptr{nvmlVgpuSchedulerGetState_st}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{nvmlVgpuSchedulerGetState_st}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::nvmlVgpuSchedulerGetState_st, private::Bool=false)
    return (:schedulerPolicy, :arrMode, :schedulerParams, if private
                fieldnames(typeof(x))
            else
                ()
            end...)
end

const nvmlVgpuSchedulerGetState_t = nvmlVgpuSchedulerGetState_st

struct nvmlVgpuSchedulerSetParams_t
    data::NTuple{8,UInt8}
end

function Base.getproperty(x::Ptr{nvmlVgpuSchedulerSetParams_t}, f::Symbol)
    f === :vgpuSchedDataWithARR && return Ptr{var"##Ctag#273"}(x + 0)
    f === :vgpuSchedData && return Ptr{var"##Ctag#274"}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::nvmlVgpuSchedulerSetParams_t, f::Symbol)
    r = Ref{nvmlVgpuSchedulerSetParams_t}(x)
    ptr = Base.unsafe_convert(Ptr{nvmlVgpuSchedulerSetParams_t}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{nvmlVgpuSchedulerSetParams_t}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::nvmlVgpuSchedulerSetParams_t, private::Bool=false)
    return (:vgpuSchedDataWithARR, :vgpuSchedData, if private
                fieldnames(typeof(x))
            else
                ()
            end...)
end

struct nvmlVgpuSchedulerSetState_st
    data::NTuple{16,UInt8}
end

function Base.getproperty(x::Ptr{nvmlVgpuSchedulerSetState_st}, f::Symbol)
    f === :schedulerPolicy && return Ptr{Cuint}(x + 0)
    f === :enableARRMode && return Ptr{Cuint}(x + 4)
    f === :schedulerParams && return Ptr{nvmlVgpuSchedulerSetParams_t}(x + 8)
    return getfield(x, f)
end

function Base.getproperty(x::nvmlVgpuSchedulerSetState_st, f::Symbol)
    r = Ref{nvmlVgpuSchedulerSetState_st}(x)
    ptr = Base.unsafe_convert(Ptr{nvmlVgpuSchedulerSetState_st}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{nvmlVgpuSchedulerSetState_st}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::nvmlVgpuSchedulerSetState_st, private::Bool=false)
    return (:schedulerPolicy, :enableARRMode, :schedulerParams,
            if private
                fieldnames(typeof(x))
            else
                ()
            end...)
end

const nvmlVgpuSchedulerSetState_t = nvmlVgpuSchedulerSetState_st

struct nvmlVgpuSchedulerCapabilities_st
    supportedSchedulers::NTuple{3,Cuint}
    maxTimeslice::Cuint
    minTimeslice::Cuint
    isArrModeSupported::Cuint
    maxFrequencyForARR::Cuint
    minFrequencyForARR::Cuint
    maxAvgFactorForARR::Cuint
    minAvgFactorForARR::Cuint
end

const nvmlVgpuSchedulerCapabilities_t = nvmlVgpuSchedulerCapabilities_st

struct nvmlVgpuLicenseExpiry_st
    year::Cuint
    month::Cushort
    day::Cushort
    hour::Cushort
    min::Cushort
    sec::Cushort
    status::Cuchar
end

const nvmlVgpuLicenseExpiry_t = nvmlVgpuLicenseExpiry_st

struct nvmlVgpuLicenseInfo_st
    isLicensed::Cuchar
    licenseExpiry::nvmlVgpuLicenseExpiry_t
    currentState::Cuint
end

const nvmlVgpuLicenseInfo_t = nvmlVgpuLicenseInfo_st

struct nvmlGridLicenseExpiry_st
    year::Cuint
    month::Cushort
    day::Cushort
    hour::Cushort
    min::Cushort
    sec::Cushort
    status::Cuchar
end

const nvmlGridLicenseExpiry_t = nvmlGridLicenseExpiry_st

struct nvmlGridLicensableFeature_st
    featureCode::nvmlGridLicenseFeatureCode_t
    featureState::Cuint
    licenseInfo::NTuple{128,Cchar}
    productName::NTuple{128,Cchar}
    featureEnabled::Cuint
    licenseExpiry::nvmlGridLicenseExpiry_t
end

const nvmlGridLicensableFeature_t = nvmlGridLicensableFeature_st

struct nvmlGridLicensableFeatures_st
    isGridLicenseSupported::Cint
    licensableFeaturesCount::Cuint
    gridLicensableFeatures::NTuple{3,nvmlGridLicensableFeature_t}
end

const nvmlGridLicensableFeatures_t = nvmlGridLicensableFeatures_st

@cenum nvmlDeviceGpuRecoveryAction_s::UInt32 begin
    NVML_GPU_RECOVERY_ACTION_NONE = 0
    NVML_GPU_RECOVERY_ACTION_GPU_RESET = 1
    NVML_GPU_RECOVERY_ACTION_NODE_REBOOT = 2
    NVML_GPU_RECOVERY_ACTION_DRAIN_P2P = 3
    NVML_GPU_RECOVERY_ACTION_DRAIN_AND_RESET = 4
end

const nvmlDeviceGpuRecoveryAction_t = nvmlDeviceGpuRecoveryAction_s

struct nvmlVgpuTypeIdInfo_v1_t
    version::Cuint
    vgpuCount::Cuint
    vgpuTypeIds::Ptr{nvmlVgpuTypeId_t}
end

const nvmlVgpuTypeIdInfo_t = nvmlVgpuTypeIdInfo_v1_t

struct nvmlVgpuTypeMaxInstance_v1_t
    version::Cuint
    vgpuTypeId::nvmlVgpuTypeId_t
    maxInstancePerGI::Cuint
end

const nvmlVgpuTypeMaxInstance_t = nvmlVgpuTypeMaxInstance_v1_t

struct nvmlActiveVgpuInstanceInfo_v1_t
    version::Cuint
    vgpuCount::Cuint
    vgpuInstances::Ptr{nvmlVgpuInstance_t}
end

const nvmlActiveVgpuInstanceInfo_t = nvmlActiveVgpuInstanceInfo_v1_t

struct nvmlVgpuSchedulerState_v1_t
    data::NTuple{24,UInt8}
end

function Base.getproperty(x::Ptr{nvmlVgpuSchedulerState_v1_t}, f::Symbol)
    f === :version && return Ptr{Cuint}(x + 0)
    f === :engineId && return Ptr{Cuint}(x + 4)
    f === :schedulerPolicy && return Ptr{Cuint}(x + 8)
    f === :enableARRMode && return Ptr{Cuint}(x + 12)
    f === :schedulerParams && return Ptr{nvmlVgpuSchedulerSetParams_t}(x + 16)
    return getfield(x, f)
end

function Base.getproperty(x::nvmlVgpuSchedulerState_v1_t, f::Symbol)
    r = Ref{nvmlVgpuSchedulerState_v1_t}(x)
    ptr = Base.unsafe_convert(Ptr{nvmlVgpuSchedulerState_v1_t}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{nvmlVgpuSchedulerState_v1_t}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::nvmlVgpuSchedulerState_v1_t, private::Bool=false)
    return (:version, :engineId, :schedulerPolicy, :enableARRMode, :schedulerParams,
            if private
                fieldnames(typeof(x))
            else
                ()
            end...)
end

const nvmlVgpuSchedulerState_t = nvmlVgpuSchedulerState_v1_t

struct nvmlVgpuSchedulerStateInfo_v1_t
    data::NTuple{24,UInt8}
end

function Base.getproperty(x::Ptr{nvmlVgpuSchedulerStateInfo_v1_t}, f::Symbol)
    f === :version && return Ptr{Cuint}(x + 0)
    f === :engineId && return Ptr{Cuint}(x + 4)
    f === :schedulerPolicy && return Ptr{Cuint}(x + 8)
    f === :arrMode && return Ptr{Cuint}(x + 12)
    f === :schedulerParams && return Ptr{nvmlVgpuSchedulerParams_t}(x + 16)
    return getfield(x, f)
end

function Base.getproperty(x::nvmlVgpuSchedulerStateInfo_v1_t, f::Symbol)
    r = Ref{nvmlVgpuSchedulerStateInfo_v1_t}(x)
    ptr = Base.unsafe_convert(Ptr{nvmlVgpuSchedulerStateInfo_v1_t}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{nvmlVgpuSchedulerStateInfo_v1_t}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::nvmlVgpuSchedulerStateInfo_v1_t, private::Bool=false)
    return (:version, :engineId, :schedulerPolicy, :arrMode, :schedulerParams,
            if private
                fieldnames(typeof(x))
            else
                ()
            end...)
end

const nvmlVgpuSchedulerStateInfo_t = nvmlVgpuSchedulerStateInfo_v1_t

struct nvmlVgpuSchedulerLogInfo_v1_t
    data::NTuple{9632,UInt8}
end

function Base.getproperty(x::Ptr{nvmlVgpuSchedulerLogInfo_v1_t}, f::Symbol)
    f === :version && return Ptr{Cuint}(x + 0)
    f === :engineId && return Ptr{Cuint}(x + 4)
    f === :schedulerPolicy && return Ptr{Cuint}(x + 8)
    f === :arrMode && return Ptr{Cuint}(x + 12)
    f === :schedulerParams && return Ptr{nvmlVgpuSchedulerParams_t}(x + 16)
    f === :entriesCount && return Ptr{Cuint}(x + 24)
    f === :logEntries && return Ptr{NTuple{200,nvmlVgpuSchedulerLogEntry_t}}(x + 32)
    return getfield(x, f)
end

function Base.getproperty(x::nvmlVgpuSchedulerLogInfo_v1_t, f::Symbol)
    r = Ref{nvmlVgpuSchedulerLogInfo_v1_t}(x)
    ptr = Base.unsafe_convert(Ptr{nvmlVgpuSchedulerLogInfo_v1_t}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{nvmlVgpuSchedulerLogInfo_v1_t}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::nvmlVgpuSchedulerLogInfo_v1_t, private::Bool=false)
    return (:version, :engineId, :schedulerPolicy, :arrMode, :schedulerParams,
            :entriesCount, :logEntries, if private
                fieldnames(typeof(x))
            else
                ()
            end...)
end

const nvmlVgpuSchedulerLogInfo_t = nvmlVgpuSchedulerLogInfo_v1_t

struct nvmlVgpuCreatablePlacementInfo_v1_t
    version::Cuint
    vgpuTypeId::nvmlVgpuTypeId_t
    count::Cuint
    placementIds::Ptr{Cuint}
    placementSize::Cuint
end

const nvmlVgpuCreatablePlacementInfo_t = nvmlVgpuCreatablePlacementInfo_v1_t

struct nvmlNvLinkPowerThres_st
    lowPwrThreshold::Cuint
end

const nvmlNvLinkPowerThres_t = nvmlNvLinkPowerThres_st

struct nvmlFieldValue_st
    data::NTuple{40,UInt8}
end

function Base.getproperty(x::Ptr{nvmlFieldValue_st}, f::Symbol)
    f === :fieldId && return Ptr{Cuint}(x + 0)
    f === :scopeId && return Ptr{Cuint}(x + 4)
    f === :timestamp && return Ptr{Clonglong}(x + 8)
    f === :latencyUsec && return Ptr{Clonglong}(x + 16)
    f === :valueType && return Ptr{nvmlValueType_t}(x + 24)
    f === :nvmlReturn && return Ptr{nvmlReturn_t}(x + 28)
    f === :value && return Ptr{nvmlValue_t}(x + 32)
    return getfield(x, f)
end

function Base.getproperty(x::nvmlFieldValue_st, f::Symbol)
    r = Ref{nvmlFieldValue_st}(x)
    ptr = Base.unsafe_convert(Ptr{nvmlFieldValue_st}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{nvmlFieldValue_st}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::nvmlFieldValue_st, private::Bool=false)
    return (:fieldId, :scopeId, :timestamp, :latencyUsec, :valueType, :nvmlReturn, :value,
            if private
                fieldnames(typeof(x))
            else
                ()
            end...)
end

const nvmlFieldValue_t = nvmlFieldValue_st

mutable struct nvmlUnit_st end

const nvmlUnit_t = Ptr{nvmlUnit_st}

struct nvmlHwbcEntry_st
    hwbcId::Cuint
    firmwareVersion::NTuple{32,Cchar}
end

const nvmlHwbcEntry_t = nvmlHwbcEntry_st

@cenum nvmlFanState_enum::UInt32 begin
    NVML_FAN_NORMAL = 0
    NVML_FAN_FAILED = 1
end

const nvmlFanState_t = nvmlFanState_enum

@cenum nvmlLedColor_enum::UInt32 begin
    NVML_LED_COLOR_GREEN = 0
    NVML_LED_COLOR_AMBER = 1
end

const nvmlLedColor_t = nvmlLedColor_enum

struct nvmlLedState_st
    cause::NTuple{256,Cchar}
    color::nvmlLedColor_t
end

const nvmlLedState_t = nvmlLedState_st

struct nvmlUnitInfo_st
    name::NTuple{96,Cchar}
    id::NTuple{96,Cchar}
    serial::NTuple{96,Cchar}
    firmwareVersion::NTuple{96,Cchar}
end

const nvmlUnitInfo_t = nvmlUnitInfo_st

struct nvmlPSUInfo_st
    state::NTuple{256,Cchar}
    current::Cuint
    voltage::Cuint
    power::Cuint
end

const nvmlPSUInfo_t = nvmlPSUInfo_st

struct nvmlUnitFanInfo_st
    speed::Cuint
    state::nvmlFanState_t
end

const nvmlUnitFanInfo_t = nvmlUnitFanInfo_st

struct nvmlUnitFanSpeeds_st
    fans::NTuple{24,nvmlUnitFanInfo_t}
    count::Cuint
end

const nvmlUnitFanSpeeds_t = nvmlUnitFanSpeeds_st

mutable struct nvmlEventSet_st end

const nvmlEventSet_t = Ptr{nvmlEventSet_st}

struct nvmlEventData_st
    device::nvmlDevice_t
    eventType::Culonglong
    eventData::Culonglong
    gpuInstanceId::Cuint
    computeInstanceId::Cuint
end

const nvmlEventData_t = nvmlEventData_st

mutable struct nvmlSystemEventSet_st end

const nvmlSystemEventSet_t = Ptr{nvmlSystemEventSet_st}

struct nvmlSystemEventSetCreateRequest_v1_t
    version::Cuint
    set::nvmlSystemEventSet_t
end

const nvmlSystemEventSetCreateRequest_t = nvmlSystemEventSetCreateRequest_v1_t

struct nvmlSystemEventSetFreeRequest_v1_t
    version::Cuint
    set::nvmlSystemEventSet_t
end

const nvmlSystemEventSetFreeRequest_t = nvmlSystemEventSetFreeRequest_v1_t

struct nvmlSystemRegisterEventRequest_v1_t
    version::Cuint
    eventTypes::Culonglong
    set::nvmlSystemEventSet_t
end

const nvmlSystemRegisterEventRequest_t = nvmlSystemRegisterEventRequest_v1_t

struct nvmlSystemEventData_v1_t
    eventType::Culonglong
    gpuId::Cuint
end

struct nvmlSystemEventSetWaitRequest_v1_t
    version::Cuint
    timeoutms::Cuint
    set::nvmlSystemEventSet_t
    data::Ptr{nvmlSystemEventData_v1_t}
    dataSize::Cuint
    numEvent::Cuint
end

const nvmlSystemEventSetWaitRequest_t = nvmlSystemEventSetWaitRequest_v1_t

struct nvmlAccountingStats_st
    gpuUtilization::Cuint
    memoryUtilization::Cuint
    maxMemoryUsage::Culonglong
    time::Culonglong
    startTime::Culonglong
    isRunning::Cuint
    reserved::NTuple{5,Cuint}
end

const nvmlAccountingStats_t = nvmlAccountingStats_st

@cenum nvmlEncoderQueryType_enum::UInt32 begin
    NVML_ENCODER_QUERY_H264 = 0
    NVML_ENCODER_QUERY_HEVC = 1
    NVML_ENCODER_QUERY_AV1 = 2
    NVML_ENCODER_QUERY_UNKNOWN = 255
end

const nvmlEncoderType_t = nvmlEncoderQueryType_enum

struct nvmlEncoderSessionInfo_st
    sessionId::Cuint
    pid::Cuint
    vgpuInstance::nvmlVgpuInstance_t
    codecType::nvmlEncoderType_t
    hResolution::Cuint
    vResolution::Cuint
    averageFps::Cuint
    averageLatency::Cuint
end

const nvmlEncoderSessionInfo_t = nvmlEncoderSessionInfo_st

@cenum nvmlFBCSessionType_enum::UInt32 begin
    NVML_FBC_SESSION_TYPE_UNKNOWN = 0
    NVML_FBC_SESSION_TYPE_TOSYS = 1
    NVML_FBC_SESSION_TYPE_CUDA = 2
    NVML_FBC_SESSION_TYPE_VID = 3
    NVML_FBC_SESSION_TYPE_HWENC = 4
end

const nvmlFBCSessionType_t = nvmlFBCSessionType_enum

struct nvmlFBCStats_st
    sessionsCount::Cuint
    averageFPS::Cuint
    averageLatency::Cuint
end

const nvmlFBCStats_t = nvmlFBCStats_st

struct nvmlFBCSessionInfo_st
    sessionId::Cuint
    pid::Cuint
    vgpuInstance::nvmlVgpuInstance_t
    displayOrdinal::Cuint
    sessionType::nvmlFBCSessionType_t
    sessionFlags::Cuint
    hMaxResolution::Cuint
    vMaxResolution::Cuint
    hResolution::Cuint
    vResolution::Cuint
    averageFPS::Cuint
    averageLatency::Cuint
end

const nvmlFBCSessionInfo_t = nvmlFBCSessionInfo_st

@cenum nvmlDetachGpuState_enum::UInt32 begin
    NVML_DETACH_GPU_KEEP = 0
    NVML_DETACH_GPU_REMOVE = 1
end

const nvmlDetachGpuState_t = nvmlDetachGpuState_enum

@cenum nvmlPcieLinkState_enum::UInt32 begin
    NVML_PCIE_LINK_KEEP = 0
    NVML_PCIE_LINK_SHUT_DOWN = 1
end

const nvmlPcieLinkState_t = nvmlPcieLinkState_enum

struct nvmlConfComputeSystemCaps_st
    cpuCaps::Cuint
    gpusCaps::Cuint
end

const nvmlConfComputeSystemCaps_t = nvmlConfComputeSystemCaps_st

struct nvmlConfComputeSystemState_st
    environment::Cuint
    ccFeature::Cuint
    devToolsMode::Cuint
end

const nvmlConfComputeSystemState_t = nvmlConfComputeSystemState_st

struct nvmlSystemConfComputeSettings_v1_t
    version::Cuint
    environment::Cuint
    ccFeature::Cuint
    devToolsMode::Cuint
    multiGpuMode::Cuint
end

const nvmlSystemConfComputeSettings_t = nvmlSystemConfComputeSettings_v1_t

struct nvmlConfComputeMemSizeInfo_st
    protectedMemSizeKib::Culonglong
    unprotectedMemSizeKib::Culonglong
end

const nvmlConfComputeMemSizeInfo_t = nvmlConfComputeMemSizeInfo_st

struct nvmlConfComputeGpuCertificate_st
    certChainSize::Cuint
    attestationCertChainSize::Cuint
    certChain::NTuple{4096,Cuchar}
    attestationCertChain::NTuple{5120,Cuchar}
end

const nvmlConfComputeGpuCertificate_t = nvmlConfComputeGpuCertificate_st

struct nvmlConfComputeGpuAttestationReport_st
    isCecAttestationReportPresent::Cuint
    attestationReportSize::Cuint
    cecAttestationReportSize::Cuint
    nonce::NTuple{32,Cuchar}
    attestationReport::NTuple{8192,Cuchar}
    cecAttestationReport::NTuple{4096,Cuchar}
end

const nvmlConfComputeGpuAttestationReport_t = nvmlConfComputeGpuAttestationReport_st

struct nvmlConfComputeSetKeyRotationThresholdInfo_st
    version::Cuint
    maxAttackerAdvantage::Culonglong
end

const nvmlConfComputeSetKeyRotationThresholdInfo_v1_t = nvmlConfComputeSetKeyRotationThresholdInfo_st

const nvmlConfComputeSetKeyRotationThresholdInfo_t = nvmlConfComputeSetKeyRotationThresholdInfo_v1_t

struct nvmlConfComputeGetKeyRotationThresholdInfo_st
    version::Cuint
    attackerAdvantage::Culonglong
end

const nvmlConfComputeGetKeyRotationThresholdInfo_v1_t = nvmlConfComputeGetKeyRotationThresholdInfo_st

const nvmlConfComputeGetKeyRotationThresholdInfo_t = nvmlConfComputeGetKeyRotationThresholdInfo_v1_t

const nvmlGpuFabricState_t = Cuchar

struct nvmlGpuFabricInfo_t
    clusterUuid::NTuple{16,Cuchar}
    status::nvmlReturn_t
    cliqueId::Cuint
    state::nvmlGpuFabricState_t
end

struct nvmlGpuFabricInfo_v2_t
    version::Cuint
    clusterUuid::NTuple{16,Cuchar}
    status::nvmlReturn_t
    cliqueId::Cuint
    state::nvmlGpuFabricState_t
    healthMask::Cuint
end

struct nvmlGpuFabricInfo_v3_t
    version::Cuint
    clusterUuid::NTuple{16,Cuchar}
    status::nvmlReturn_t
    cliqueId::Cuint
    state::nvmlGpuFabricState_t
    healthMask::Cuint
    healthSummary::Cuchar
end

const nvmlGpuFabricInfoV_t = nvmlGpuFabricInfo_v3_t

@checked function nvmlInit_v2()
    @gcsafe_ccall (libnvml()).nvmlInit_v2()::nvmlReturn_t
end

@checked function nvmlInitWithFlags(flags)
    @gcsafe_ccall (libnvml()).nvmlInitWithFlags(flags::Cuint)::nvmlReturn_t
end

@checked function nvmlShutdown()
    @gcsafe_ccall (libnvml()).nvmlShutdown()::nvmlReturn_t
end

function nvmlErrorString(result)
    @gcsafe_ccall (libnvml()).nvmlErrorString(result::nvmlReturn_t)::Cstring
end

@checked function nvmlSystemGetDriverVersion(version, length)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemGetDriverVersion(version::Cstring,
                                                         length::Cuint)::nvmlReturn_t
end

@checked function nvmlSystemGetNVMLVersion(version, length)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemGetNVMLVersion(version::Cstring,
                                                       length::Cuint)::nvmlReturn_t
end

@checked function nvmlSystemGetCudaDriverVersion(cudaDriverVersion)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemGetCudaDriverVersion(cudaDriverVersion::Ptr{Cint})::nvmlReturn_t
end

@checked function nvmlSystemGetCudaDriverVersion_v2(cudaDriverVersion)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemGetCudaDriverVersion_v2(cudaDriverVersion::Ptr{Cint})::nvmlReturn_t
end

@checked function nvmlSystemGetProcessName(pid, name, length)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemGetProcessName(pid::Cuint, name::Cstring,
                                                       length::Cuint)::nvmlReturn_t
end

@checked function nvmlSystemGetHicVersion(hwbcCount, hwbcEntries)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemGetHicVersion(hwbcCount::Ptr{Cuint},
                                                      hwbcEntries::Ptr{nvmlHwbcEntry_t})::nvmlReturn_t
end

@checked function nvmlSystemGetTopologyGpuSet(cpuNumber, count, deviceArray)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemGetTopologyGpuSet(cpuNumber::Cuint,
                                                          count::Ptr{Cuint},
                                                          deviceArray::Ptr{nvmlDevice_t})::nvmlReturn_t
end

struct nvmlSystemDriverBranchInfo_v1_t
    version::Cuint
    branch::NTuple{80,Cchar}
end

const nvmlSystemDriverBranchInfo_t = nvmlSystemDriverBranchInfo_v1_t

@checked function nvmlSystemGetDriverBranch(branchInfo, length)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemGetDriverBranch(branchInfo::Ptr{nvmlSystemDriverBranchInfo_t},
                                                        length::Cuint)::nvmlReturn_t
end

@checked function nvmlUnitGetCount(unitCount)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlUnitGetCount(unitCount::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlUnitGetHandleByIndex(index, unit)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlUnitGetHandleByIndex(index::Cuint,
                                                       unit::Ptr{nvmlUnit_t})::nvmlReturn_t
end

@checked function nvmlUnitGetUnitInfo(unit, info)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlUnitGetUnitInfo(unit::nvmlUnit_t,
                                                  info::Ptr{nvmlUnitInfo_t})::nvmlReturn_t
end

@checked function nvmlUnitGetLedState(unit, state)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlUnitGetLedState(unit::nvmlUnit_t,
                                                  state::Ptr{nvmlLedState_t})::nvmlReturn_t
end

@checked function nvmlUnitGetPsuInfo(unit, psu)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlUnitGetPsuInfo(unit::nvmlUnit_t,
                                                 psu::Ptr{nvmlPSUInfo_t})::nvmlReturn_t
end

@checked function nvmlUnitGetTemperature(unit, type, temp)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlUnitGetTemperature(unit::nvmlUnit_t, type::Cuint,
                                                     temp::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlUnitGetFanSpeedInfo(unit, fanSpeeds)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlUnitGetFanSpeedInfo(unit::nvmlUnit_t,
                                                      fanSpeeds::Ptr{nvmlUnitFanSpeeds_t})::nvmlReturn_t
end

@checked function nvmlUnitGetDevices(unit, deviceCount, devices)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlUnitGetDevices(unit::nvmlUnit_t, deviceCount::Ptr{Cuint},
                                                 devices::Ptr{nvmlDevice_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetCount_v2(deviceCount)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetCount_v2(deviceCount::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetAttributes_v2(device, attributes)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetAttributes_v2(device::nvmlDevice_t,
                                                         attributes::Ptr{nvmlDeviceAttributes_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetHandleByIndex_v2(index, device)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetHandleByIndex_v2(index::Cuint,
                                                            device::Ptr{nvmlDevice_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetHandleBySerial(serial, device)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetHandleBySerial(serial::Cstring,
                                                          device::Ptr{nvmlDevice_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetHandleByUUID(uuid, device)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetHandleByUUID(uuid::Cstring,
                                                        device::Ptr{nvmlDevice_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetHandleByUUIDV(uuid, device)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetHandleByUUIDV(uuid::Ptr{nvmlUUID_t},
                                                         device::Ptr{nvmlDevice_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetHandleByPciBusId_v2(pciBusId, device)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetHandleByPciBusId_v2(pciBusId::Cstring,
                                                               device::Ptr{nvmlDevice_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetName(device, name, length)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetName(device::nvmlDevice_t, name::Cstring,
                                                length::Cuint)::nvmlReturn_t
end

@checked function nvmlDeviceGetBrand(device, type)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetBrand(device::nvmlDevice_t,
                                                 type::Ptr{nvmlBrandType_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetIndex(device, index)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetIndex(device::nvmlDevice_t,
                                                 index::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetSerial(device, serial, length)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetSerial(device::nvmlDevice_t, serial::Cstring,
                                                  length::Cuint)::nvmlReturn_t
end

@checked function nvmlDeviceGetModuleId(device, moduleId)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetModuleId(device::nvmlDevice_t,
                                                    moduleId::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetC2cModeInfoV(device, c2cModeInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetC2cModeInfoV(device::nvmlDevice_t,
                                                        c2cModeInfo::Ptr{nvmlC2cModeInfo_v1_t})::nvmlReturn_t
end

const nvmlAffinityScope_t = Cuint

@checked function nvmlDeviceGetMemoryAffinity(device, nodeSetSize, nodeSet, scope)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMemoryAffinity(device::nvmlDevice_t,
                                                          nodeSetSize::Cuint,
                                                          nodeSet::Ptr{Culong},
                                                          scope::nvmlAffinityScope_t)::nvmlReturn_t
end

@checked function nvmlDeviceGetCpuAffinityWithinScope(device, cpuSetSize, cpuSet, scope)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetCpuAffinityWithinScope(device::nvmlDevice_t,
                                                                  cpuSetSize::Cuint,
                                                                  cpuSet::Ptr{Culong},
                                                                  scope::nvmlAffinityScope_t)::nvmlReturn_t
end

@checked function nvmlDeviceGetCpuAffinity(device, cpuSetSize, cpuSet)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetCpuAffinity(device::nvmlDevice_t,
                                                       cpuSetSize::Cuint,
                                                       cpuSet::Ptr{Culong})::nvmlReturn_t
end

@checked function nvmlDeviceSetCpuAffinity(device)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetCpuAffinity(device::nvmlDevice_t)::nvmlReturn_t
end

@checked function nvmlDeviceClearCpuAffinity(device)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceClearCpuAffinity(device::nvmlDevice_t)::nvmlReturn_t
end

@checked function nvmlDeviceGetNumaNodeId(device, node)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetNumaNodeId(device::nvmlDevice_t,
                                                      node::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetAddressingMode(device, mode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetAddressingMode(device::nvmlDevice_t,
                                                          mode::Ptr{nvmlDeviceAddressingMode_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetRepairStatus(device, repairStatus)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetRepairStatus(device::nvmlDevice_t,
                                                        repairStatus::Ptr{nvmlRepairStatus_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetTopologyCommonAncestor(device1, device2, pathInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetTopologyCommonAncestor(device1::nvmlDevice_t,
                                                                  device2::nvmlDevice_t,
                                                                  pathInfo::Ptr{nvmlGpuTopologyLevel_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetTopologyNearestGpus(device, level, count, deviceArray)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetTopologyNearestGpus(device::nvmlDevice_t,
                                                               level::nvmlGpuTopologyLevel_t,
                                                               count::Ptr{Cuint},
                                                               deviceArray::Ptr{nvmlDevice_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetP2PStatus(device1, device2, p2pIndex, p2pStatus)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetP2PStatus(device1::nvmlDevice_t,
                                                     device2::nvmlDevice_t,
                                                     p2pIndex::nvmlGpuP2PCapsIndex_t,
                                                     p2pStatus::Ptr{nvmlGpuP2PStatus_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetUUID(device, uuid, length)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetUUID(device::nvmlDevice_t, uuid::Cstring,
                                                length::Cuint)::nvmlReturn_t
end

@checked function nvmlDeviceGetMinorNumber(device, minorNumber)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMinorNumber(device::nvmlDevice_t,
                                                       minorNumber::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetBoardPartNumber(device, partNumber, length)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetBoardPartNumber(device::nvmlDevice_t,
                                                           partNumber::Cstring,
                                                           length::Cuint)::nvmlReturn_t
end

@checked function nvmlDeviceGetInforomVersion(device, object, version, length)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetInforomVersion(device::nvmlDevice_t,
                                                          object::nvmlInforomObject_t,
                                                          version::Cstring,
                                                          length::Cuint)::nvmlReturn_t
end

@checked function nvmlDeviceGetInforomImageVersion(device, version, length)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetInforomImageVersion(device::nvmlDevice_t,
                                                               version::Cstring,
                                                               length::Cuint)::nvmlReturn_t
end

@checked function nvmlDeviceGetInforomConfigurationChecksum(device, checksum)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetInforomConfigurationChecksum(device::nvmlDevice_t,
                                                                        checksum::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceValidateInforom(device)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceValidateInforom(device::nvmlDevice_t)::nvmlReturn_t
end

@checked function nvmlDeviceGetLastBBXFlushTime(device, timestamp, durationUs)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetLastBBXFlushTime(device::nvmlDevice_t,
                                                            timestamp::Ptr{Culonglong},
                                                            durationUs::Ptr{Culong})::nvmlReturn_t
end

@checked function nvmlDeviceGetDisplayMode(device, display)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetDisplayMode(device::nvmlDevice_t,
                                                       display::Ptr{nvmlEnableState_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetDisplayActive(device, isActive)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetDisplayActive(device::nvmlDevice_t,
                                                         isActive::Ptr{nvmlEnableState_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetPersistenceMode(device, mode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPersistenceMode(device::nvmlDevice_t,
                                                           mode::Ptr{nvmlEnableState_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetPciInfoExt(device, pci)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPciInfoExt(device::nvmlDevice_t,
                                                      pci::Ptr{nvmlPciInfoExt_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetPciInfo_v3(device, pci)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPciInfo_v3(device::nvmlDevice_t,
                                                      pci::Ptr{nvmlPciInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetMaxPcieLinkGeneration(device, maxLinkGen)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMaxPcieLinkGeneration(device::nvmlDevice_t,
                                                                 maxLinkGen::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetGpuMaxPcieLinkGeneration(device, maxLinkGenDevice)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGpuMaxPcieLinkGeneration(device::nvmlDevice_t,
                                                                    maxLinkGenDevice::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetMaxPcieLinkWidth(device, maxLinkWidth)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMaxPcieLinkWidth(device::nvmlDevice_t,
                                                            maxLinkWidth::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetCurrPcieLinkGeneration(device, currLinkGen)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetCurrPcieLinkGeneration(device::nvmlDevice_t,
                                                                  currLinkGen::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetCurrPcieLinkWidth(device, currLinkWidth)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetCurrPcieLinkWidth(device::nvmlDevice_t,
                                                             currLinkWidth::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetPcieThroughput(device, counter, value)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPcieThroughput(device::nvmlDevice_t,
                                                          counter::nvmlPcieUtilCounter_t,
                                                          value::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetPcieReplayCounter(device, value)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPcieReplayCounter(device::nvmlDevice_t,
                                                             value::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetClockInfo(device, type, clock)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetClockInfo(device::nvmlDevice_t,
                                                     type::nvmlClockType_t,
                                                     clock::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetMaxClockInfo(device, type, clock)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMaxClockInfo(device::nvmlDevice_t,
                                                        type::nvmlClockType_t,
                                                        clock::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetGpcClkVfOffset(device, offset)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGpcClkVfOffset(device::nvmlDevice_t,
                                                          offset::Ptr{Cint})::nvmlReturn_t
end

@checked function nvmlDeviceGetApplicationsClock(device, clockType, clockMHz)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetApplicationsClock(device::nvmlDevice_t,
                                                             clockType::nvmlClockType_t,
                                                             clockMHz::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetDefaultApplicationsClock(device, clockType, clockMHz)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetDefaultApplicationsClock(device::nvmlDevice_t,
                                                                    clockType::nvmlClockType_t,
                                                                    clockMHz::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetClock(device, clockType, clockId, clockMHz)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetClock(device::nvmlDevice_t,
                                                 clockType::nvmlClockType_t,
                                                 clockId::nvmlClockId_t,
                                                 clockMHz::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetMaxCustomerBoostClock(device, clockType, clockMHz)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMaxCustomerBoostClock(device::nvmlDevice_t,
                                                                 clockType::nvmlClockType_t,
                                                                 clockMHz::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetSupportedMemoryClocks(device, count, clocksMHz)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetSupportedMemoryClocks(device::nvmlDevice_t,
                                                                 count::Ptr{Cuint},
                                                                 clocksMHz::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetSupportedGraphicsClocks(device, memoryClockMHz, count,
                                                       clocksMHz)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetSupportedGraphicsClocks(device::nvmlDevice_t,
                                                                   memoryClockMHz::Cuint,
                                                                   count::Ptr{Cuint},
                                                                   clocksMHz::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetAutoBoostedClocksEnabled(device, isEnabled, defaultIsEnabled)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetAutoBoostedClocksEnabled(device::nvmlDevice_t,
                                                                    isEnabled::Ptr{nvmlEnableState_t},
                                                                    defaultIsEnabled::Ptr{nvmlEnableState_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetFanSpeed(device, speed)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetFanSpeed(device::nvmlDevice_t,
                                                    speed::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetFanSpeed_v2(device, fan, speed)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetFanSpeed_v2(device::nvmlDevice_t, fan::Cuint,
                                                       speed::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetFanSpeedRPM(device, fanSpeed)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetFanSpeedRPM(device::nvmlDevice_t,
                                                       fanSpeed::Ptr{nvmlFanSpeedInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetTargetFanSpeed(device, fan, targetSpeed)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetTargetFanSpeed(device::nvmlDevice_t, fan::Cuint,
                                                          targetSpeed::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetMinMaxFanSpeed(device, minSpeed, maxSpeed)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMinMaxFanSpeed(device::nvmlDevice_t,
                                                          minSpeed::Ptr{Cuint},
                                                          maxSpeed::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetFanControlPolicy_v2(device, fan, policy)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetFanControlPolicy_v2(device::nvmlDevice_t,
                                                               fan::Cuint,
                                                               policy::Ptr{nvmlFanControlPolicy_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetNumFans(device, numFans)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetNumFans(device::nvmlDevice_t,
                                                   numFans::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetTemperature(device, sensorType, temp)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetTemperature(device::nvmlDevice_t,
                                                       sensorType::nvmlTemperatureSensors_t,
                                                       temp::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetCoolerInfo(device, coolerInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetCoolerInfo(device::nvmlDevice_t,
                                                      coolerInfo::Ptr{nvmlCoolerInfo_t})::nvmlReturn_t
end

struct nvmlTemperature_v1_t
    version::Cuint
    sensorType::nvmlTemperatureSensors_t
    temperature::Cint
end

const nvmlTemperature_t = nvmlTemperature_v1_t

@checked function nvmlDeviceGetTemperatureV(device, temperature)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetTemperatureV(device::nvmlDevice_t,
                                                        temperature::Ptr{nvmlTemperature_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetTemperatureThreshold(device, thresholdType, temp)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetTemperatureThreshold(device::nvmlDevice_t,
                                                                thresholdType::nvmlTemperatureThresholds_t,
                                                                temp::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetMarginTemperature(device, marginTempInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMarginTemperature(device::nvmlDevice_t,
                                                             marginTempInfo::Ptr{nvmlMarginTemperature_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetThermalSettings(device, sensorIndex, pThermalSettings)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetThermalSettings(device::nvmlDevice_t,
                                                           sensorIndex::Cuint,
                                                           pThermalSettings::Ptr{nvmlGpuThermalSettings_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetPerformanceState(device, pState)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPerformanceState(device::nvmlDevice_t,
                                                            pState::Ptr{nvmlPstates_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetCurrentClocksEventReasons(device, clocksEventReasons)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetCurrentClocksEventReasons(device::nvmlDevice_t,
                                                                     clocksEventReasons::Ptr{Culonglong})::nvmlReturn_t
end

@checked function nvmlDeviceGetCurrentClocksThrottleReasons(device, clocksThrottleReasons)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetCurrentClocksThrottleReasons(device::nvmlDevice_t,
                                                                        clocksThrottleReasons::Ptr{Culonglong})::nvmlReturn_t
end

@checked function nvmlDeviceGetSupportedClocksEventReasons(device,
                                                           supportedClocksEventReasons)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetSupportedClocksEventReasons(device::nvmlDevice_t,
                                                                       supportedClocksEventReasons::Ptr{Culonglong})::nvmlReturn_t
end

@checked function nvmlDeviceGetSupportedClocksThrottleReasons(device,
                                                              supportedClocksThrottleReasons)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetSupportedClocksThrottleReasons(device::nvmlDevice_t,
                                                                          supportedClocksThrottleReasons::Ptr{Culonglong})::nvmlReturn_t
end

@checked function nvmlDeviceGetPowerState(device, pState)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPowerState(device::nvmlDevice_t,
                                                      pState::Ptr{nvmlPstates_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetDynamicPstatesInfo(device, pDynamicPstatesInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetDynamicPstatesInfo(device::nvmlDevice_t,
                                                              pDynamicPstatesInfo::Ptr{nvmlGpuDynamicPstatesInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetMemClkVfOffset(device, offset)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMemClkVfOffset(device::nvmlDevice_t,
                                                          offset::Ptr{Cint})::nvmlReturn_t
end

@checked function nvmlDeviceGetMinMaxClockOfPState(device, type, pstate, minClockMHz,
                                                   maxClockMHz)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMinMaxClockOfPState(device::nvmlDevice_t,
                                                               type::nvmlClockType_t,
                                                               pstate::nvmlPstates_t,
                                                               minClockMHz::Ptr{Cuint},
                                                               maxClockMHz::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetSupportedPerformanceStates(device, pstates, size)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetSupportedPerformanceStates(device::nvmlDevice_t,
                                                                      pstates::Ptr{nvmlPstates_t},
                                                                      size::Cuint)::nvmlReturn_t
end

@checked function nvmlDeviceGetGpcClkMinMaxVfOffset(device, minOffset, maxOffset)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGpcClkMinMaxVfOffset(device::nvmlDevice_t,
                                                                minOffset::Ptr{Cint},
                                                                maxOffset::Ptr{Cint})::nvmlReturn_t
end

@checked function nvmlDeviceGetMemClkMinMaxVfOffset(device, minOffset, maxOffset)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMemClkMinMaxVfOffset(device::nvmlDevice_t,
                                                                minOffset::Ptr{Cint},
                                                                maxOffset::Ptr{Cint})::nvmlReturn_t
end

@checked function nvmlDeviceGetClockOffsets(device, info)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetClockOffsets(device::nvmlDevice_t,
                                                        info::Ptr{nvmlClockOffset_t})::nvmlReturn_t
end

@checked function nvmlDeviceSetClockOffsets(device, info)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetClockOffsets(device::nvmlDevice_t,
                                                        info::Ptr{nvmlClockOffset_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetPerformanceModes(device, perfModes)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPerformanceModes(device::nvmlDevice_t,
                                                            perfModes::Ptr{nvmlDevicePerfModes_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetCurrentClockFreqs(device, currentClockFreqs)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetCurrentClockFreqs(device::nvmlDevice_t,
                                                             currentClockFreqs::Ptr{nvmlDeviceCurrentClockFreqs_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetPowerManagementMode(device, mode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPowerManagementMode(device::nvmlDevice_t,
                                                               mode::Ptr{nvmlEnableState_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetPowerManagementLimit(device, limit)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPowerManagementLimit(device::nvmlDevice_t,
                                                                limit::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetPowerManagementLimitConstraints(device, minLimit, maxLimit)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPowerManagementLimitConstraints(device::nvmlDevice_t,
                                                                           minLimit::Ptr{Cuint},
                                                                           maxLimit::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetPowerManagementDefaultLimit(device, defaultLimit)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPowerManagementDefaultLimit(device::nvmlDevice_t,
                                                                       defaultLimit::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetPowerUsage(device, power)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPowerUsage(device::nvmlDevice_t,
                                                      power::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetPowerMizerMode_v1(device, powerMizerMode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPowerMizerMode_v1(device::nvmlDevice_t,
                                                             powerMizerMode::Ptr{nvmlDevicePowerMizerModes_v1_t})::nvmlReturn_t
end

@checked function nvmlDeviceSetPowerMizerMode_v1(device, powerMizerMode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetPowerMizerMode_v1(device::nvmlDevice_t,
                                                             powerMizerMode::Ptr{nvmlDevicePowerMizerModes_v1_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetTotalEnergyConsumption(device, energy)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetTotalEnergyConsumption(device::nvmlDevice_t,
                                                                  energy::Ptr{Culonglong})::nvmlReturn_t
end

@checked function nvmlDeviceGetEnforcedPowerLimit(device, limit)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetEnforcedPowerLimit(device::nvmlDevice_t,
                                                              limit::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetGpuOperationMode(device, current, pending)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGpuOperationMode(device::nvmlDevice_t,
                                                            current::Ptr{nvmlGpuOperationMode_t},
                                                            pending::Ptr{nvmlGpuOperationMode_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetMemoryInfo(device, memory)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMemoryInfo(device::nvmlDevice_t,
                                                      memory::Ptr{nvmlMemory_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetMemoryInfo_v2(device, memory)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMemoryInfo_v2(device::nvmlDevice_t,
                                                         memory::Ptr{nvmlMemory_v2_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetComputeMode(device, mode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetComputeMode(device::nvmlDevice_t,
                                                       mode::Ptr{nvmlComputeMode_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetCudaComputeCapability(device, major, minor)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetCudaComputeCapability(device::nvmlDevice_t,
                                                                 major::Ptr{Cint},
                                                                 minor::Ptr{Cint})::nvmlReturn_t
end

@checked function nvmlDeviceGetDramEncryptionMode(device, current, pending)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetDramEncryptionMode(device::nvmlDevice_t,
                                                              current::Ptr{nvmlDramEncryptionInfo_t},
                                                              pending::Ptr{nvmlDramEncryptionInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceSetDramEncryptionMode(device, dramEncryption)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetDramEncryptionMode(device::nvmlDevice_t,
                                                              dramEncryption::Ptr{nvmlDramEncryptionInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetEccMode(device, current, pending)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetEccMode(device::nvmlDevice_t,
                                                   current::Ptr{nvmlEnableState_t},
                                                   pending::Ptr{nvmlEnableState_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetDefaultEccMode(device, defaultMode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetDefaultEccMode(device::nvmlDevice_t,
                                                          defaultMode::Ptr{nvmlEnableState_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetBoardId(device, boardId)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetBoardId(device::nvmlDevice_t,
                                                   boardId::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetMultiGpuBoard(device, multiGpuBool)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMultiGpuBoard(device::nvmlDevice_t,
                                                         multiGpuBool::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetTotalEccErrors(device, errorType, counterType, eccCounts)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetTotalEccErrors(device::nvmlDevice_t,
                                                          errorType::nvmlMemoryErrorType_t,
                                                          counterType::nvmlEccCounterType_t,
                                                          eccCounts::Ptr{Culonglong})::nvmlReturn_t
end

@checked function nvmlDeviceGetDetailedEccErrors(device, errorType, counterType, eccCounts)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetDetailedEccErrors(device::nvmlDevice_t,
                                                             errorType::nvmlMemoryErrorType_t,
                                                             counterType::nvmlEccCounterType_t,
                                                             eccCounts::Ptr{nvmlEccErrorCounts_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetMemoryErrorCounter(device, errorType, counterType,
                                                  locationType, count)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMemoryErrorCounter(device::nvmlDevice_t,
                                                              errorType::nvmlMemoryErrorType_t,
                                                              counterType::nvmlEccCounterType_t,
                                                              locationType::nvmlMemoryLocation_t,
                                                              count::Ptr{Culonglong})::nvmlReturn_t
end

@checked function nvmlDeviceGetUtilizationRates(device, utilization)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetUtilizationRates(device::nvmlDevice_t,
                                                            utilization::Ptr{nvmlUtilization_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetEncoderUtilization(device, utilization, samplingPeriodUs)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetEncoderUtilization(device::nvmlDevice_t,
                                                              utilization::Ptr{Cuint},
                                                              samplingPeriodUs::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetEncoderCapacity(device, encoderQueryType, encoderCapacity)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetEncoderCapacity(device::nvmlDevice_t,
                                                           encoderQueryType::nvmlEncoderType_t,
                                                           encoderCapacity::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetEncoderStats(device, sessionCount, averageFps,
                                            averageLatency)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetEncoderStats(device::nvmlDevice_t,
                                                        sessionCount::Ptr{Cuint},
                                                        averageFps::Ptr{Cuint},
                                                        averageLatency::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetEncoderSessions(device, sessionCount, sessionInfos)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetEncoderSessions(device::nvmlDevice_t,
                                                           sessionCount::Ptr{Cuint},
                                                           sessionInfos::Ptr{nvmlEncoderSessionInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetDecoderUtilization(device, utilization, samplingPeriodUs)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetDecoderUtilization(device::nvmlDevice_t,
                                                              utilization::Ptr{Cuint},
                                                              samplingPeriodUs::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetJpgUtilization(device, utilization, samplingPeriodUs)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetJpgUtilization(device::nvmlDevice_t,
                                                          utilization::Ptr{Cuint},
                                                          samplingPeriodUs::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetOfaUtilization(device, utilization, samplingPeriodUs)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetOfaUtilization(device::nvmlDevice_t,
                                                          utilization::Ptr{Cuint},
                                                          samplingPeriodUs::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetFBCStats(device, fbcStats)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetFBCStats(device::nvmlDevice_t,
                                                    fbcStats::Ptr{nvmlFBCStats_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetFBCSessions(device, sessionCount, sessionInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetFBCSessions(device::nvmlDevice_t,
                                                       sessionCount::Ptr{Cuint},
                                                       sessionInfo::Ptr{nvmlFBCSessionInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetDriverModel_v2(device, current, pending)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetDriverModel_v2(device::nvmlDevice_t,
                                                          current::Ptr{nvmlDriverModel_t},
                                                          pending::Ptr{nvmlDriverModel_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetVbiosVersion(device, version, length)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetVbiosVersion(device::nvmlDevice_t,
                                                        version::Cstring,
                                                        length::Cuint)::nvmlReturn_t
end

@checked function nvmlDeviceGetBridgeChipInfo(device, bridgeHierarchy)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetBridgeChipInfo(device::nvmlDevice_t,
                                                          bridgeHierarchy::Ptr{nvmlBridgeChipHierarchy_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetComputeRunningProcesses_v3(device, infoCount, infos)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetComputeRunningProcesses_v3(device::nvmlDevice_t,
                                                                      infoCount::Ptr{Cuint},
                                                                      infos::Ptr{nvmlProcessInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetGraphicsRunningProcesses_v3(device, infoCount, infos)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGraphicsRunningProcesses_v3(device::nvmlDevice_t,
                                                                       infoCount::Ptr{Cuint},
                                                                       infos::Ptr{nvmlProcessInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetMPSComputeRunningProcesses_v3(device, infoCount, infos)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMPSComputeRunningProcesses_v3(device::nvmlDevice_t,
                                                                         infoCount::Ptr{Cuint},
                                                                         infos::Ptr{nvmlProcessInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetRunningProcessDetailList(device, plist)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetRunningProcessDetailList(device::nvmlDevice_t,
                                                                    plist::Ptr{nvmlProcessDetailList_t})::nvmlReturn_t
end

@checked function nvmlDeviceOnSameBoard(device1, device2, onSameBoard)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceOnSameBoard(device1::nvmlDevice_t,
                                                    device2::nvmlDevice_t,
                                                    onSameBoard::Ptr{Cint})::nvmlReturn_t
end

@checked function nvmlDeviceGetAPIRestriction(device, apiType, isRestricted)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetAPIRestriction(device::nvmlDevice_t,
                                                          apiType::nvmlRestrictedAPI_t,
                                                          isRestricted::Ptr{nvmlEnableState_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetSamples(device, type, lastSeenTimeStamp, sampleValType,
                                       sampleCount, samples)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetSamples(device::nvmlDevice_t,
                                                   type::nvmlSamplingType_t,
                                                   lastSeenTimeStamp::Culonglong,
                                                   sampleValType::Ptr{nvmlValueType_t},
                                                   sampleCount::Ptr{Cuint},
                                                   samples::Ptr{nvmlSample_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetBAR1MemoryInfo(device, bar1Memory)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetBAR1MemoryInfo(device::nvmlDevice_t,
                                                          bar1Memory::Ptr{nvmlBAR1Memory_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetViolationStatus(device, perfPolicyType, violTime)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetViolationStatus(device::nvmlDevice_t,
                                                           perfPolicyType::nvmlPerfPolicyType_t,
                                                           violTime::Ptr{nvmlViolationTime_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetIrqNum(device, irqNum)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetIrqNum(device::nvmlDevice_t,
                                                  irqNum::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetNumGpuCores(device, numCores)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetNumGpuCores(device::nvmlDevice_t,
                                                       numCores::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetPowerSource(device, powerSource)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPowerSource(device::nvmlDevice_t,
                                                       powerSource::Ptr{nvmlPowerSource_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetMemoryBusWidth(device, busWidth)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMemoryBusWidth(device::nvmlDevice_t,
                                                          busWidth::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetPcieLinkMaxSpeed(device, maxSpeed)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPcieLinkMaxSpeed(device::nvmlDevice_t,
                                                            maxSpeed::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetPcieSpeed(device, pcieSpeed)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPcieSpeed(device::nvmlDevice_t,
                                                     pcieSpeed::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetAdaptiveClockInfoStatus(device, adaptiveClockStatus)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetAdaptiveClockInfoStatus(device::nvmlDevice_t,
                                                                   adaptiveClockStatus::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetBusType(device, type)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetBusType(device::nvmlDevice_t,
                                                   type::Ptr{nvmlBusType_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetGpuFabricInfo(device, gpuFabricInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGpuFabricInfo(device::nvmlDevice_t,
                                                         gpuFabricInfo::Ptr{nvmlGpuFabricInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetGpuFabricInfoV(device, gpuFabricInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGpuFabricInfoV(device::nvmlDevice_t,
                                                          gpuFabricInfo::Ptr{nvmlGpuFabricInfoV_t})::nvmlReturn_t
end

@checked function nvmlSystemGetConfComputeCapabilities(capabilities)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemGetConfComputeCapabilities(capabilities::Ptr{nvmlConfComputeSystemCaps_t})::nvmlReturn_t
end

@checked function nvmlSystemGetConfComputeState(state)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemGetConfComputeState(state::Ptr{nvmlConfComputeSystemState_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetConfComputeMemSizeInfo(device, memInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetConfComputeMemSizeInfo(device::nvmlDevice_t,
                                                                  memInfo::Ptr{nvmlConfComputeMemSizeInfo_t})::nvmlReturn_t
end

@checked function nvmlSystemGetConfComputeGpusReadyState(isAcceptingWork)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemGetConfComputeGpusReadyState(isAcceptingWork::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetConfComputeProtectedMemoryUsage(device, memory)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetConfComputeProtectedMemoryUsage(device::nvmlDevice_t,
                                                                           memory::Ptr{nvmlMemory_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetConfComputeGpuCertificate(device, gpuCert)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetConfComputeGpuCertificate(device::nvmlDevice_t,
                                                                     gpuCert::Ptr{nvmlConfComputeGpuCertificate_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetConfComputeGpuAttestationReport(device, gpuAtstReport)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetConfComputeGpuAttestationReport(device::nvmlDevice_t,
                                                                           gpuAtstReport::Ptr{nvmlConfComputeGpuAttestationReport_t})::nvmlReturn_t
end

@checked function nvmlSystemGetConfComputeKeyRotationThresholdInfo(pKeyRotationThrInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemGetConfComputeKeyRotationThresholdInfo(pKeyRotationThrInfo::Ptr{nvmlConfComputeGetKeyRotationThresholdInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceSetConfComputeUnprotectedMemSize(device, sizeKiB)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetConfComputeUnprotectedMemSize(device::nvmlDevice_t,
                                                                         sizeKiB::Culonglong)::nvmlReturn_t
end

@checked function nvmlSystemSetConfComputeGpusReadyState(isAcceptingWork)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemSetConfComputeGpusReadyState(isAcceptingWork::Cuint)::nvmlReturn_t
end

@checked function nvmlSystemSetConfComputeKeyRotationThresholdInfo(pKeyRotationThrInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemSetConfComputeKeyRotationThresholdInfo(pKeyRotationThrInfo::Ptr{nvmlConfComputeSetKeyRotationThresholdInfo_t})::nvmlReturn_t
end

@checked function nvmlSystemGetConfComputeSettings(settings)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemGetConfComputeSettings(settings::Ptr{nvmlSystemConfComputeSettings_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetGspFirmwareVersion(device, version)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGspFirmwareVersion(device::nvmlDevice_t,
                                                              version::Cstring)::nvmlReturn_t
end

@checked function nvmlDeviceGetGspFirmwareMode(device, isEnabled, defaultMode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGspFirmwareMode(device::nvmlDevice_t,
                                                           isEnabled::Ptr{Cuint},
                                                           defaultMode::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetSramEccErrorStatus(device, status)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetSramEccErrorStatus(device::nvmlDevice_t,
                                                              status::Ptr{nvmlEccSramErrorStatus_t})::nvmlReturn_t
end

@checked function nvmlDeviceSetPowerManagementLimit_v2(device, powerValue)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetPowerManagementLimit_v2(device::nvmlDevice_t,
                                                                   powerValue::Ptr{nvmlPowerValue_v2_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetAccountingMode(device, mode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetAccountingMode(device::nvmlDevice_t,
                                                          mode::Ptr{nvmlEnableState_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetAccountingStats(device, pid, stats)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetAccountingStats(device::nvmlDevice_t, pid::Cuint,
                                                           stats::Ptr{nvmlAccountingStats_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetAccountingPids(device, count, pids)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetAccountingPids(device::nvmlDevice_t,
                                                          count::Ptr{Cuint},
                                                          pids::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetAccountingBufferSize(device, bufferSize)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetAccountingBufferSize(device::nvmlDevice_t,
                                                                bufferSize::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetRetiredPages(device, cause, pageCount, addresses)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetRetiredPages(device::nvmlDevice_t,
                                                        cause::nvmlPageRetirementCause_t,
                                                        pageCount::Ptr{Cuint},
                                                        addresses::Ptr{Culonglong})::nvmlReturn_t
end

@checked function nvmlDeviceGetRetiredPages_v2(device, cause, pageCount, addresses,
                                               timestamps)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetRetiredPages_v2(device::nvmlDevice_t,
                                                           cause::nvmlPageRetirementCause_t,
                                                           pageCount::Ptr{Cuint},
                                                           addresses::Ptr{Culonglong},
                                                           timestamps::Ptr{Culonglong})::nvmlReturn_t
end

@checked function nvmlDeviceGetRetiredPagesPendingStatus(device, isPending)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetRetiredPagesPendingStatus(device::nvmlDevice_t,
                                                                     isPending::Ptr{nvmlEnableState_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetRemappedRows(device, corrRows, uncRows, isPending,
                                            failureOccurred)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetRemappedRows(device::nvmlDevice_t,
                                                        corrRows::Ptr{Cuint},
                                                        uncRows::Ptr{Cuint},
                                                        isPending::Ptr{Cuint},
                                                        failureOccurred::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetRowRemapperHistogram(device, values)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetRowRemapperHistogram(device::nvmlDevice_t,
                                                                values::Ptr{nvmlRowRemapperHistogramValues_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetArchitecture(device, arch)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetArchitecture(device::nvmlDevice_t,
                                                        arch::Ptr{nvmlDeviceArchitecture_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetClkMonStatus(device, status)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetClkMonStatus(device::nvmlDevice_t,
                                                        status::Ptr{nvmlClkMonStatus_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetProcessUtilization(device, utilization, processSamplesCount,
                                                  lastSeenTimeStamp)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetProcessUtilization(device::nvmlDevice_t,
                                                              utilization::Ptr{nvmlProcessUtilizationSample_t},
                                                              processSamplesCount::Ptr{Cuint},
                                                              lastSeenTimeStamp::Culonglong)::nvmlReturn_t
end

@checked function nvmlDeviceGetProcessesUtilizationInfo(device, procesesUtilInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetProcessesUtilizationInfo(device::nvmlDevice_t,
                                                                    procesesUtilInfo::Ptr{nvmlProcessesUtilizationInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetPlatformInfo(device, platformInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPlatformInfo(device::nvmlDevice_t,
                                                        platformInfo::Ptr{nvmlPlatformInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetPdi(device, pdi)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPdi(device::nvmlDevice_t,
                                               pdi::Ptr{nvmlPdi_t})::nvmlReturn_t
end

@checked function nvmlDeviceSetHostname_v1(device, hostname)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetHostname_v1(device::nvmlDevice_t,
                                                       hostname::Ptr{nvmlHostname_v1_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetHostname_v1(device, hostname)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetHostname_v1(device::nvmlDevice_t,
                                                       hostname::Ptr{nvmlHostname_v1_t})::nvmlReturn_t
end

@checked function nvmlUnitSetLedState(unit, color)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlUnitSetLedState(unit::nvmlUnit_t,
                                                  color::nvmlLedColor_t)::nvmlReturn_t
end

@checked function nvmlDeviceSetPersistenceMode(device, mode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetPersistenceMode(device::nvmlDevice_t,
                                                           mode::nvmlEnableState_t)::nvmlReturn_t
end

@checked function nvmlDeviceSetComputeMode(device, mode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetComputeMode(device::nvmlDevice_t,
                                                       mode::nvmlComputeMode_t)::nvmlReturn_t
end

@checked function nvmlDeviceSetEccMode(device, ecc)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetEccMode(device::nvmlDevice_t,
                                                   ecc::nvmlEnableState_t)::nvmlReturn_t
end

@checked function nvmlDeviceClearEccErrorCounts(device, counterType)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceClearEccErrorCounts(device::nvmlDevice_t,
                                                            counterType::nvmlEccCounterType_t)::nvmlReturn_t
end

@checked function nvmlDeviceSetDriverModel(device, driverModel, flags)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetDriverModel(device::nvmlDevice_t,
                                                       driverModel::nvmlDriverModel_t,
                                                       flags::Cuint)::nvmlReturn_t
end

@cenum nvmlClockLimitId_enum::UInt32 begin
    NVML_CLOCK_LIMIT_ID_RANGE_START = 0x00000000ffffff00
    NVML_CLOCK_LIMIT_ID_TDP = 0x00000000ffffff01
    NVML_CLOCK_LIMIT_ID_UNLIMITED = 0x00000000ffffff02
end

const nvmlClockLimitId_t = nvmlClockLimitId_enum

@checked function nvmlDeviceSetGpuLockedClocks(device, minGpuClockMHz, maxGpuClockMHz)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetGpuLockedClocks(device::nvmlDevice_t,
                                                           minGpuClockMHz::Cuint,
                                                           maxGpuClockMHz::Cuint)::nvmlReturn_t
end

@checked function nvmlDeviceResetGpuLockedClocks(device)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceResetGpuLockedClocks(device::nvmlDevice_t)::nvmlReturn_t
end

@checked function nvmlDeviceSetMemoryLockedClocks(device, minMemClockMHz, maxMemClockMHz)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetMemoryLockedClocks(device::nvmlDevice_t,
                                                              minMemClockMHz::Cuint,
                                                              maxMemClockMHz::Cuint)::nvmlReturn_t
end

@checked function nvmlDeviceResetMemoryLockedClocks(device)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceResetMemoryLockedClocks(device::nvmlDevice_t)::nvmlReturn_t
end

@checked function nvmlDeviceSetApplicationsClocks(device, memClockMHz, graphicsClockMHz)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetApplicationsClocks(device::nvmlDevice_t,
                                                              memClockMHz::Cuint,
                                                              graphicsClockMHz::Cuint)::nvmlReturn_t
end

@checked function nvmlDeviceResetApplicationsClocks(device)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceResetApplicationsClocks(device::nvmlDevice_t)::nvmlReturn_t
end

@checked function nvmlDeviceSetAutoBoostedClocksEnabled(device, enabled)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetAutoBoostedClocksEnabled(device::nvmlDevice_t,
                                                                    enabled::nvmlEnableState_t)::nvmlReturn_t
end

@checked function nvmlDeviceSetDefaultAutoBoostedClocksEnabled(device, enabled, flags)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetDefaultAutoBoostedClocksEnabled(device::nvmlDevice_t,
                                                                           enabled::nvmlEnableState_t,
                                                                           flags::Cuint)::nvmlReturn_t
end

@checked function nvmlDeviceSetDefaultFanSpeed_v2(device, fan)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetDefaultFanSpeed_v2(device::nvmlDevice_t,
                                                              fan::Cuint)::nvmlReturn_t
end

@checked function nvmlDeviceSetFanControlPolicy(device, fan, policy)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetFanControlPolicy(device::nvmlDevice_t,
                                                            fan::Cuint,
                                                            policy::nvmlFanControlPolicy_t)::nvmlReturn_t
end

@checked function nvmlDeviceSetTemperatureThreshold(device, thresholdType, temp)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetTemperatureThreshold(device::nvmlDevice_t,
                                                                thresholdType::nvmlTemperatureThresholds_t,
                                                                temp::Ptr{Cint})::nvmlReturn_t
end

@checked function nvmlDeviceSetPowerManagementLimit(device, limit)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetPowerManagementLimit(device::nvmlDevice_t,
                                                                limit::Cuint)::nvmlReturn_t
end

@checked function nvmlDeviceSetGpuOperationMode(device, mode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetGpuOperationMode(device::nvmlDevice_t,
                                                            mode::nvmlGpuOperationMode_t)::nvmlReturn_t
end

@checked function nvmlDeviceSetAPIRestriction(device, apiType, isRestricted)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetAPIRestriction(device::nvmlDevice_t,
                                                          apiType::nvmlRestrictedAPI_t,
                                                          isRestricted::nvmlEnableState_t)::nvmlReturn_t
end

@checked function nvmlDeviceSetFanSpeed_v2(device, fan, speed)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetFanSpeed_v2(device::nvmlDevice_t, fan::Cuint,
                                                       speed::Cuint)::nvmlReturn_t
end

@checked function nvmlDeviceSetGpcClkVfOffset(device, offset)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetGpcClkVfOffset(device::nvmlDevice_t,
                                                          offset::Cint)::nvmlReturn_t
end

@checked function nvmlDeviceSetMemClkVfOffset(device, offset)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetMemClkVfOffset(device::nvmlDevice_t,
                                                          offset::Cint)::nvmlReturn_t
end

@checked function nvmlDeviceSetAccountingMode(device, mode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetAccountingMode(device::nvmlDevice_t,
                                                          mode::nvmlEnableState_t)::nvmlReturn_t
end

@checked function nvmlDeviceClearAccountingPids(device)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceClearAccountingPids(device::nvmlDevice_t)::nvmlReturn_t
end

struct nvmlNvlinkSupportedBwModes_v1_t
    version::Cuint
    bwModes::NTuple{23,Cuchar}
    totalBwModes::Cuchar
end

const nvmlNvlinkSupportedBwModes_t = nvmlNvlinkSupportedBwModes_v1_t

struct nvmlNvlinkGetBwMode_v1_t
    version::Cuint
    bIsBest::Cuint
    bwMode::Cuchar
end

const nvmlNvlinkGetBwMode_t = nvmlNvlinkGetBwMode_v1_t

struct nvmlNvlinkSetBwMode_v1_t
    version::Cuint
    bSetBest::Cuint
    bwMode::Cuchar
end

const nvmlNvlinkSetBwMode_t = nvmlNvlinkSetBwMode_v1_t

struct nvmlNvLinkInfo_v1_t
    version::Cuint
    isNvleEnabled::Cuint
end

struct nvmlNvlinkFirmwareVersion_t
    ucodeType::Cuchar
    major::Cuint
    minor::Cuint
    subMinor::Cuint
end

struct nvmlNvlinkFirmwareInfo_t
    firmwareVersion::NTuple{100,nvmlNvlinkFirmwareVersion_t}
    numValidEntries::Cuint
end

struct nvmlNvLinkInfo_v2_t
    version::Cuint
    isNvleEnabled::Cuint
    firmwareInfo::nvmlNvlinkFirmwareInfo_t
end

const nvmlNvLinkInfo_t = nvmlNvLinkInfo_v2_t

@checked function nvmlDeviceGetNvLinkState(device, link, isActive)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetNvLinkState(device::nvmlDevice_t, link::Cuint,
                                                       isActive::Ptr{nvmlEnableState_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetNvLinkVersion(device, link, version)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetNvLinkVersion(device::nvmlDevice_t, link::Cuint,
                                                         version::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetNvLinkCapability(device, link, capability, capResult)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetNvLinkCapability(device::nvmlDevice_t,
                                                            link::Cuint,
                                                            capability::nvmlNvLinkCapability_t,
                                                            capResult::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetNvLinkRemotePciInfo_v2(device, link, pci)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetNvLinkRemotePciInfo_v2(device::nvmlDevice_t,
                                                                  link::Cuint,
                                                                  pci::Ptr{nvmlPciInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetNvLinkErrorCounter(device, link, counter, counterValue)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetNvLinkErrorCounter(device::nvmlDevice_t,
                                                              link::Cuint,
                                                              counter::nvmlNvLinkErrorCounter_t,
                                                              counterValue::Ptr{Culonglong})::nvmlReturn_t
end

@checked function nvmlDeviceResetNvLinkErrorCounters(device, link)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceResetNvLinkErrorCounters(device::nvmlDevice_t,
                                                                 link::Cuint)::nvmlReturn_t
end

@checked function nvmlDeviceSetNvLinkUtilizationControl(device, link, counter, control,
                                                        reset)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetNvLinkUtilizationControl(device::nvmlDevice_t,
                                                                    link::Cuint,
                                                                    counter::Cuint,
                                                                    control::Ptr{nvmlNvLinkUtilizationControl_t},
                                                                    reset::Cuint)::nvmlReturn_t
end

@checked function nvmlDeviceGetNvLinkUtilizationControl(device, link, counter, control)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetNvLinkUtilizationControl(device::nvmlDevice_t,
                                                                    link::Cuint,
                                                                    counter::Cuint,
                                                                    control::Ptr{nvmlNvLinkUtilizationControl_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetNvLinkUtilizationCounter(device, link, counter, rxcounter,
                                                        txcounter)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetNvLinkUtilizationCounter(device::nvmlDevice_t,
                                                                    link::Cuint,
                                                                    counter::Cuint,
                                                                    rxcounter::Ptr{Culonglong},
                                                                    txcounter::Ptr{Culonglong})::nvmlReturn_t
end

@checked function nvmlDeviceFreezeNvLinkUtilizationCounter(device, link, counter, freeze)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceFreezeNvLinkUtilizationCounter(device::nvmlDevice_t,
                                                                       link::Cuint,
                                                                       counter::Cuint,
                                                                       freeze::nvmlEnableState_t)::nvmlReturn_t
end

@checked function nvmlDeviceResetNvLinkUtilizationCounter(device, link, counter)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceResetNvLinkUtilizationCounter(device::nvmlDevice_t,
                                                                      link::Cuint,
                                                                      counter::Cuint)::nvmlReturn_t
end

@checked function nvmlDeviceGetNvLinkRemoteDeviceType(device, link, pNvLinkDeviceType)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetNvLinkRemoteDeviceType(device::nvmlDevice_t,
                                                                  link::Cuint,
                                                                  pNvLinkDeviceType::Ptr{nvmlIntNvLinkDeviceType_t})::nvmlReturn_t
end

@checked function nvmlDeviceSetNvLinkDeviceLowPowerThreshold(device, info)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetNvLinkDeviceLowPowerThreshold(device::nvmlDevice_t,
                                                                         info::Ptr{nvmlNvLinkPowerThres_t})::nvmlReturn_t
end

@checked function nvmlSystemSetNvlinkBwMode(nvlinkBwMode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemSetNvlinkBwMode(nvlinkBwMode::Cuint)::nvmlReturn_t
end

@checked function nvmlSystemGetNvlinkBwMode(nvlinkBwMode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemGetNvlinkBwMode(nvlinkBwMode::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetNvlinkSupportedBwModes(device, supportedBwMode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetNvlinkSupportedBwModes(device::nvmlDevice_t,
                                                                  supportedBwMode::Ptr{nvmlNvlinkSupportedBwModes_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetNvlinkBwMode(device, getBwMode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetNvlinkBwMode(device::nvmlDevice_t,
                                                        getBwMode::Ptr{nvmlNvlinkGetBwMode_t})::nvmlReturn_t
end

@checked function nvmlDeviceSetNvlinkBwMode(device, setBwMode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetNvlinkBwMode(device::nvmlDevice_t,
                                                        setBwMode::Ptr{nvmlNvlinkSetBwMode_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetNvLinkInfo(device, info)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetNvLinkInfo(device::nvmlDevice_t,
                                                      info::Ptr{nvmlNvLinkInfo_t})::nvmlReturn_t
end

@checked function nvmlEventSetCreate(set)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlEventSetCreate(set::Ptr{nvmlEventSet_t})::nvmlReturn_t
end

@checked function nvmlDeviceRegisterEvents(device, eventTypes, set)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceRegisterEvents(device::nvmlDevice_t,
                                                       eventTypes::Culonglong,
                                                       set::nvmlEventSet_t)::nvmlReturn_t
end

@checked function nvmlDeviceGetSupportedEventTypes(device, eventTypes)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetSupportedEventTypes(device::nvmlDevice_t,
                                                               eventTypes::Ptr{Culonglong})::nvmlReturn_t
end

@checked function nvmlEventSetWait_v2(set, data, timeoutms)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlEventSetWait_v2(set::nvmlEventSet_t,
                                                  data::Ptr{nvmlEventData_t},
                                                  timeoutms::Cuint)::nvmlReturn_t
end

@checked function nvmlEventSetFree(set)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlEventSetFree(set::nvmlEventSet_t)::nvmlReturn_t
end

@checked function nvmlSystemEventSetCreate(request)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemEventSetCreate(request::Ptr{nvmlSystemEventSetCreateRequest_t})::nvmlReturn_t
end

@checked function nvmlSystemEventSetFree(request)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemEventSetFree(request::Ptr{nvmlSystemEventSetFreeRequest_t})::nvmlReturn_t
end

@checked function nvmlSystemRegisterEvents(request)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemRegisterEvents(request::Ptr{nvmlSystemRegisterEventRequest_t})::nvmlReturn_t
end

@checked function nvmlSystemEventSetWait(request)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSystemEventSetWait(request::Ptr{nvmlSystemEventSetWaitRequest_t})::nvmlReturn_t
end

@checked function nvmlDeviceModifyDrainState(pciInfo, newState)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceModifyDrainState(pciInfo::Ptr{nvmlPciInfo_t},
                                                         newState::nvmlEnableState_t)::nvmlReturn_t
end

@checked function nvmlDeviceQueryDrainState(pciInfo, currentState)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceQueryDrainState(pciInfo::Ptr{nvmlPciInfo_t},
                                                        currentState::Ptr{nvmlEnableState_t})::nvmlReturn_t
end

@checked function nvmlDeviceRemoveGpu_v2(pciInfo, gpuState, linkState)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceRemoveGpu_v2(pciInfo::Ptr{nvmlPciInfo_t},
                                                     gpuState::nvmlDetachGpuState_t,
                                                     linkState::nvmlPcieLinkState_t)::nvmlReturn_t
end

@checked function nvmlDeviceDiscoverGpus(pciInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceDiscoverGpus(pciInfo::Ptr{nvmlPciInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetFieldValues(device, valuesCount, values)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetFieldValues(device::nvmlDevice_t,
                                                       valuesCount::Cint,
                                                       values::Ptr{nvmlFieldValue_t})::nvmlReturn_t
end

@checked function nvmlDeviceClearFieldValues(device, valuesCount, values)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceClearFieldValues(device::nvmlDevice_t,
                                                         valuesCount::Cint,
                                                         values::Ptr{nvmlFieldValue_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetVirtualizationMode(device, pVirtualMode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetVirtualizationMode(device::nvmlDevice_t,
                                                              pVirtualMode::Ptr{nvmlGpuVirtualizationMode_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetHostVgpuMode(device, pHostVgpuMode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetHostVgpuMode(device::nvmlDevice_t,
                                                        pHostVgpuMode::Ptr{nvmlHostVgpuMode_t})::nvmlReturn_t
end

@checked function nvmlDeviceSetVirtualizationMode(device, virtualMode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetVirtualizationMode(device::nvmlDevice_t,
                                                              virtualMode::nvmlGpuVirtualizationMode_t)::nvmlReturn_t
end

@checked function nvmlDeviceGetVgpuHeterogeneousMode(device, pHeterogeneousMode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetVgpuHeterogeneousMode(device::nvmlDevice_t,
                                                                 pHeterogeneousMode::Ptr{nvmlVgpuHeterogeneousMode_t})::nvmlReturn_t
end

@checked function nvmlDeviceSetVgpuHeterogeneousMode(device, pHeterogeneousMode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetVgpuHeterogeneousMode(device::nvmlDevice_t,
                                                                 pHeterogeneousMode::Ptr{nvmlVgpuHeterogeneousMode_t})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetPlacementId(vgpuInstance, pPlacement)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetPlacementId(vgpuInstance::nvmlVgpuInstance_t,
                                                             pPlacement::Ptr{nvmlVgpuPlacementId_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetVgpuTypeSupportedPlacements(device, vgpuTypeId,
                                                           pPlacementList)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetVgpuTypeSupportedPlacements(device::nvmlDevice_t,
                                                                       vgpuTypeId::nvmlVgpuTypeId_t,
                                                                       pPlacementList::Ptr{nvmlVgpuPlacementList_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetVgpuTypeCreatablePlacements(device, vgpuTypeId,
                                                           pPlacementList)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetVgpuTypeCreatablePlacements(device::nvmlDevice_t,
                                                                       vgpuTypeId::nvmlVgpuTypeId_t,
                                                                       pPlacementList::Ptr{nvmlVgpuPlacementList_t})::nvmlReturn_t
end

@checked function nvmlVgpuTypeGetGspHeapSize(vgpuTypeId, gspHeapSize)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuTypeGetGspHeapSize(vgpuTypeId::nvmlVgpuTypeId_t,
                                                         gspHeapSize::Ptr{Culonglong})::nvmlReturn_t
end

@checked function nvmlVgpuTypeGetFbReservation(vgpuTypeId, fbReservation)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuTypeGetFbReservation(vgpuTypeId::nvmlVgpuTypeId_t,
                                                           fbReservation::Ptr{Culonglong})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetRuntimeStateSize(vgpuInstance, pState)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetRuntimeStateSize(vgpuInstance::nvmlVgpuInstance_t,
                                                                  pState::Ptr{nvmlVgpuRuntimeState_t})::nvmlReturn_t
end

@checked function nvmlDeviceSetVgpuCapabilities(device, capability, state)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetVgpuCapabilities(device::nvmlDevice_t,
                                                            capability::nvmlDeviceVgpuCapability_t,
                                                            state::nvmlEnableState_t)::nvmlReturn_t
end

@checked function nvmlDeviceGetGridLicensableFeatures_v4(device, pGridLicensableFeatures)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGridLicensableFeatures_v4(device::nvmlDevice_t,
                                                                     pGridLicensableFeatures::Ptr{nvmlGridLicensableFeatures_t})::nvmlReturn_t
end

@checked function nvmlGetVgpuDriverCapabilities(capability, capResult)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGetVgpuDriverCapabilities(capability::nvmlVgpuDriverCapability_t,
                                                            capResult::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetVgpuCapabilities(device, capability, capResult)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetVgpuCapabilities(device::nvmlDevice_t,
                                                            capability::nvmlDeviceVgpuCapability_t,
                                                            capResult::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetSupportedVgpus(device, vgpuCount, vgpuTypeIds)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetSupportedVgpus(device::nvmlDevice_t,
                                                          vgpuCount::Ptr{Cuint},
                                                          vgpuTypeIds::Ptr{nvmlVgpuTypeId_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetCreatableVgpus(device, vgpuCount, vgpuTypeIds)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetCreatableVgpus(device::nvmlDevice_t,
                                                          vgpuCount::Ptr{Cuint},
                                                          vgpuTypeIds::Ptr{nvmlVgpuTypeId_t})::nvmlReturn_t
end

@checked function nvmlVgpuTypeGetClass(vgpuTypeId, vgpuTypeClass, size)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuTypeGetClass(vgpuTypeId::nvmlVgpuTypeId_t,
                                                   vgpuTypeClass::Cstring,
                                                   size::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlVgpuTypeGetName(vgpuTypeId, vgpuTypeName, size)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuTypeGetName(vgpuTypeId::nvmlVgpuTypeId_t,
                                                  vgpuTypeName::Cstring,
                                                  size::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlVgpuTypeGetGpuInstanceProfileId(vgpuTypeId, gpuInstanceProfileId)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuTypeGetGpuInstanceProfileId(vgpuTypeId::nvmlVgpuTypeId_t,
                                                                  gpuInstanceProfileId::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlVgpuTypeGetDeviceID(vgpuTypeId, deviceID, subsystemID)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuTypeGetDeviceID(vgpuTypeId::nvmlVgpuTypeId_t,
                                                      deviceID::Ptr{Culonglong},
                                                      subsystemID::Ptr{Culonglong})::nvmlReturn_t
end

@checked function nvmlVgpuTypeGetFramebufferSize(vgpuTypeId, fbSize)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuTypeGetFramebufferSize(vgpuTypeId::nvmlVgpuTypeId_t,
                                                             fbSize::Ptr{Culonglong})::nvmlReturn_t
end

@checked function nvmlVgpuTypeGetNumDisplayHeads(vgpuTypeId, numDisplayHeads)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuTypeGetNumDisplayHeads(vgpuTypeId::nvmlVgpuTypeId_t,
                                                             numDisplayHeads::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlVgpuTypeGetResolution(vgpuTypeId, displayIndex, xdim, ydim)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuTypeGetResolution(vgpuTypeId::nvmlVgpuTypeId_t,
                                                        displayIndex::Cuint,
                                                        xdim::Ptr{Cuint},
                                                        ydim::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlVgpuTypeGetLicense(vgpuTypeId, vgpuTypeLicenseString, size)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuTypeGetLicense(vgpuTypeId::nvmlVgpuTypeId_t,
                                                     vgpuTypeLicenseString::Cstring,
                                                     size::Cuint)::nvmlReturn_t
end

@checked function nvmlVgpuTypeGetFrameRateLimit(vgpuTypeId, frameRateLimit)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuTypeGetFrameRateLimit(vgpuTypeId::nvmlVgpuTypeId_t,
                                                            frameRateLimit::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlVgpuTypeGetMaxInstances(device, vgpuTypeId, vgpuInstanceCount)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuTypeGetMaxInstances(device::nvmlDevice_t,
                                                          vgpuTypeId::nvmlVgpuTypeId_t,
                                                          vgpuInstanceCount::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlVgpuTypeGetMaxInstancesPerVm(vgpuTypeId, vgpuInstanceCountPerVm)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuTypeGetMaxInstancesPerVm(vgpuTypeId::nvmlVgpuTypeId_t,
                                                               vgpuInstanceCountPerVm::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlVgpuTypeGetBAR1Info(vgpuTypeId, bar1Info)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuTypeGetBAR1Info(vgpuTypeId::nvmlVgpuTypeId_t,
                                                      bar1Info::Ptr{nvmlVgpuTypeBar1Info_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetActiveVgpus(device, vgpuCount, vgpuInstances)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetActiveVgpus(device::nvmlDevice_t,
                                                       vgpuCount::Ptr{Cuint},
                                                       vgpuInstances::Ptr{nvmlVgpuInstance_t})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetVmID(vgpuInstance, vmId, size, vmIdType)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetVmID(vgpuInstance::nvmlVgpuInstance_t,
                                                      vmId::Cstring, size::Cuint,
                                                      vmIdType::Ptr{nvmlVgpuVmIdType_t})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetUUID(vgpuInstance, uuid, size)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetUUID(vgpuInstance::nvmlVgpuInstance_t,
                                                      uuid::Cstring,
                                                      size::Cuint)::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetVmDriverVersion(vgpuInstance, version, length)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetVmDriverVersion(vgpuInstance::nvmlVgpuInstance_t,
                                                                 version::Cstring,
                                                                 length::Cuint)::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetFbUsage(vgpuInstance, fbUsage)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetFbUsage(vgpuInstance::nvmlVgpuInstance_t,
                                                         fbUsage::Ptr{Culonglong})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetLicenseStatus(vgpuInstance, licensed)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetLicenseStatus(vgpuInstance::nvmlVgpuInstance_t,
                                                               licensed::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetType(vgpuInstance, vgpuTypeId)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetType(vgpuInstance::nvmlVgpuInstance_t,
                                                      vgpuTypeId::Ptr{nvmlVgpuTypeId_t})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetFrameRateLimit(vgpuInstance, frameRateLimit)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetFrameRateLimit(vgpuInstance::nvmlVgpuInstance_t,
                                                                frameRateLimit::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetEccMode(vgpuInstance, eccMode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetEccMode(vgpuInstance::nvmlVgpuInstance_t,
                                                         eccMode::Ptr{nvmlEnableState_t})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetEncoderCapacity(vgpuInstance, encoderCapacity)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetEncoderCapacity(vgpuInstance::nvmlVgpuInstance_t,
                                                                 encoderCapacity::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceSetEncoderCapacity(vgpuInstance, encoderCapacity)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceSetEncoderCapacity(vgpuInstance::nvmlVgpuInstance_t,
                                                                 encoderCapacity::Cuint)::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetEncoderStats(vgpuInstance, sessionCount, averageFps,
                                                  averageLatency)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetEncoderStats(vgpuInstance::nvmlVgpuInstance_t,
                                                              sessionCount::Ptr{Cuint},
                                                              averageFps::Ptr{Cuint},
                                                              averageLatency::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetEncoderSessions(vgpuInstance, sessionCount,
                                                     sessionInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetEncoderSessions(vgpuInstance::nvmlVgpuInstance_t,
                                                                 sessionCount::Ptr{Cuint},
                                                                 sessionInfo::Ptr{nvmlEncoderSessionInfo_t})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetFBCStats(vgpuInstance, fbcStats)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetFBCStats(vgpuInstance::nvmlVgpuInstance_t,
                                                          fbcStats::Ptr{nvmlFBCStats_t})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetFBCSessions(vgpuInstance, sessionCount, sessionInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetFBCSessions(vgpuInstance::nvmlVgpuInstance_t,
                                                             sessionCount::Ptr{Cuint},
                                                             sessionInfo::Ptr{nvmlFBCSessionInfo_t})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetGpuInstanceId(vgpuInstance, gpuInstanceId)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetGpuInstanceId(vgpuInstance::nvmlVgpuInstance_t,
                                                               gpuInstanceId::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetGpuPciId(vgpuInstance, vgpuPciId, length)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetGpuPciId(vgpuInstance::nvmlVgpuInstance_t,
                                                          vgpuPciId::Cstring,
                                                          length::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlVgpuTypeGetCapabilities(vgpuTypeId, capability, capResult)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuTypeGetCapabilities(vgpuTypeId::nvmlVgpuTypeId_t,
                                                          capability::nvmlVgpuCapability_t,
                                                          capResult::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetMdevUUID(vgpuInstance, mdevUuid, size)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetMdevUUID(vgpuInstance::nvmlVgpuInstance_t,
                                                          mdevUuid::Cstring,
                                                          size::Cuint)::nvmlReturn_t
end

@checked function nvmlGpuInstanceGetCreatableVgpus(gpuInstance, pVgpus)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpuInstanceGetCreatableVgpus(gpuInstance::nvmlGpuInstance_t,
                                                               pVgpus::Ptr{nvmlVgpuTypeIdInfo_t})::nvmlReturn_t
end

@checked function nvmlVgpuTypeGetMaxInstancesPerGpuInstance(pMaxInstance)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuTypeGetMaxInstancesPerGpuInstance(pMaxInstance::Ptr{nvmlVgpuTypeMaxInstance_t})::nvmlReturn_t
end

@checked function nvmlGpuInstanceGetActiveVgpus(gpuInstance, pVgpuInstanceInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpuInstanceGetActiveVgpus(gpuInstance::nvmlGpuInstance_t,
                                                            pVgpuInstanceInfo::Ptr{nvmlActiveVgpuInstanceInfo_t})::nvmlReturn_t
end

@checked function nvmlGpuInstanceSetVgpuSchedulerState(gpuInstance, pScheduler)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpuInstanceSetVgpuSchedulerState(gpuInstance::nvmlGpuInstance_t,
                                                                   pScheduler::Ptr{nvmlVgpuSchedulerState_t})::nvmlReturn_t
end

@checked function nvmlGpuInstanceGetVgpuSchedulerState(gpuInstance, pSchedulerStateInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpuInstanceGetVgpuSchedulerState(gpuInstance::nvmlGpuInstance_t,
                                                                   pSchedulerStateInfo::Ptr{nvmlVgpuSchedulerStateInfo_t})::nvmlReturn_t
end

@checked function nvmlGpuInstanceGetVgpuSchedulerLog(gpuInstance, pSchedulerLogInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpuInstanceGetVgpuSchedulerLog(gpuInstance::nvmlGpuInstance_t,
                                                                 pSchedulerLogInfo::Ptr{nvmlVgpuSchedulerLogInfo_t})::nvmlReturn_t
end

@checked function nvmlGpuInstanceGetVgpuTypeCreatablePlacements(gpuInstance,
                                                                pCreatablePlacementInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpuInstanceGetVgpuTypeCreatablePlacements(gpuInstance::nvmlGpuInstance_t,
                                                                            pCreatablePlacementInfo::Ptr{nvmlVgpuCreatablePlacementInfo_t})::nvmlReturn_t
end

@checked function nvmlGpuInstanceGetVgpuHeterogeneousMode(gpuInstance, pHeterogeneousMode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpuInstanceGetVgpuHeterogeneousMode(gpuInstance::nvmlGpuInstance_t,
                                                                      pHeterogeneousMode::Ptr{nvmlVgpuHeterogeneousMode_t})::nvmlReturn_t
end

@checked function nvmlGpuInstanceSetVgpuHeterogeneousMode(gpuInstance, pHeterogeneousMode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpuInstanceSetVgpuHeterogeneousMode(gpuInstance::nvmlGpuInstance_t,
                                                                      pHeterogeneousMode::Ptr{nvmlVgpuHeterogeneousMode_t})::nvmlReturn_t
end

struct nvmlVgpuVersion_st
    minVersion::Cuint
    maxVersion::Cuint
end

const nvmlVgpuVersion_t = nvmlVgpuVersion_st

struct nvmlVgpuMetadata_st
    version::Cuint
    revision::Cuint
    guestInfoState::nvmlVgpuGuestInfoState_t
    guestDriverVersion::NTuple{80,Cchar}
    hostDriverVersion::NTuple{80,Cchar}
    reserved::NTuple{6,Cuint}
    vgpuVirtualizationCaps::Cuint
    guestVgpuVersion::Cuint
    opaqueDataSize::Cuint
    opaqueData::NTuple{4,Cchar}
end

const nvmlVgpuMetadata_t = nvmlVgpuMetadata_st

struct nvmlVgpuPgpuMetadata_st
    version::Cuint
    revision::Cuint
    hostDriverVersion::NTuple{80,Cchar}
    pgpuVirtualizationCaps::Cuint
    reserved::NTuple{5,Cuint}
    hostSupportedVgpuRange::nvmlVgpuVersion_t
    opaqueDataSize::Cuint
    opaqueData::NTuple{4,Cchar}
end

const nvmlVgpuPgpuMetadata_t = nvmlVgpuPgpuMetadata_st

@cenum nvmlVgpuVmCompatibility_enum::UInt32 begin
    NVML_VGPU_VM_COMPATIBILITY_NONE = 0
    NVML_VGPU_VM_COMPATIBILITY_COLD = 1
    NVML_VGPU_VM_COMPATIBILITY_HIBERNATE = 2
    NVML_VGPU_VM_COMPATIBILITY_SLEEP = 4
    NVML_VGPU_VM_COMPATIBILITY_LIVE = 8
end

const nvmlVgpuVmCompatibility_t = nvmlVgpuVmCompatibility_enum

@cenum nvmlVgpuPgpuCompatibilityLimitCode_enum::UInt32 begin
    NVML_VGPU_COMPATIBILITY_LIMIT_NONE = 0
    NVML_VGPU_COMPATIBILITY_LIMIT_HOST_DRIVER = 1
    NVML_VGPU_COMPATIBILITY_LIMIT_GUEST_DRIVER = 2
    NVML_VGPU_COMPATIBILITY_LIMIT_GPU = 4
    NVML_VGPU_COMPATIBILITY_LIMIT_OTHER = 0x0000000080000000
end

const nvmlVgpuPgpuCompatibilityLimitCode_t = nvmlVgpuPgpuCompatibilityLimitCode_enum

struct nvmlVgpuPgpuCompatibility_st
    vgpuVmCompatibility::nvmlVgpuVmCompatibility_t
    compatibilityLimitCode::nvmlVgpuPgpuCompatibilityLimitCode_t
end

const nvmlVgpuPgpuCompatibility_t = nvmlVgpuPgpuCompatibility_st

@checked function nvmlVgpuInstanceGetMetadata(vgpuInstance, vgpuMetadata, bufferSize)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetMetadata(vgpuInstance::nvmlVgpuInstance_t,
                                                          vgpuMetadata::Ptr{nvmlVgpuMetadata_t},
                                                          bufferSize::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetVgpuMetadata(device, pgpuMetadata, bufferSize)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetVgpuMetadata(device::nvmlDevice_t,
                                                        pgpuMetadata::Ptr{nvmlVgpuPgpuMetadata_t},
                                                        bufferSize::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlGetVgpuCompatibility(vgpuMetadata, pgpuMetadata, compatibilityInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGetVgpuCompatibility(vgpuMetadata::Ptr{nvmlVgpuMetadata_t},
                                                       pgpuMetadata::Ptr{nvmlVgpuPgpuMetadata_t},
                                                       compatibilityInfo::Ptr{nvmlVgpuPgpuCompatibility_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetPgpuMetadataString(device, pgpuMetadata, bufferSize)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPgpuMetadataString(device::nvmlDevice_t,
                                                              pgpuMetadata::Cstring,
                                                              bufferSize::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetVgpuSchedulerLog(device, pSchedulerLog)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetVgpuSchedulerLog(device::nvmlDevice_t,
                                                            pSchedulerLog::Ptr{nvmlVgpuSchedulerLog_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetVgpuSchedulerState(device, pSchedulerState)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetVgpuSchedulerState(device::nvmlDevice_t,
                                                              pSchedulerState::Ptr{nvmlVgpuSchedulerGetState_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetVgpuSchedulerCapabilities(device, pCapabilities)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetVgpuSchedulerCapabilities(device::nvmlDevice_t,
                                                                     pCapabilities::Ptr{nvmlVgpuSchedulerCapabilities_t})::nvmlReturn_t
end

@checked function nvmlDeviceSetVgpuSchedulerState(device, pSchedulerState)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetVgpuSchedulerState(device::nvmlDevice_t,
                                                              pSchedulerState::Ptr{nvmlVgpuSchedulerSetState_t})::nvmlReturn_t
end

@checked function nvmlGetVgpuVersion(supported, current)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGetVgpuVersion(supported::Ptr{nvmlVgpuVersion_t},
                                                 current::Ptr{nvmlVgpuVersion_t})::nvmlReturn_t
end

@checked function nvmlSetVgpuVersion(vgpuVersion)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlSetVgpuVersion(vgpuVersion::Ptr{nvmlVgpuVersion_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetVgpuUtilization(device, lastSeenTimeStamp, sampleValType,
                                               vgpuInstanceSamplesCount, utilizationSamples)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetVgpuUtilization(device::nvmlDevice_t,
                                                           lastSeenTimeStamp::Culonglong,
                                                           sampleValType::Ptr{nvmlValueType_t},
                                                           vgpuInstanceSamplesCount::Ptr{Cuint},
                                                           utilizationSamples::Ptr{nvmlVgpuInstanceUtilizationSample_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetVgpuInstancesUtilizationInfo(device, vgpuUtilInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetVgpuInstancesUtilizationInfo(device::nvmlDevice_t,
                                                                        vgpuUtilInfo::Ptr{nvmlVgpuInstancesUtilizationInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetVgpuProcessUtilization(device, lastSeenTimeStamp,
                                                      vgpuProcessSamplesCount,
                                                      utilizationSamples)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetVgpuProcessUtilization(device::nvmlDevice_t,
                                                                  lastSeenTimeStamp::Culonglong,
                                                                  vgpuProcessSamplesCount::Ptr{Cuint},
                                                                  utilizationSamples::Ptr{nvmlVgpuProcessUtilizationSample_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetVgpuProcessesUtilizationInfo(device, vgpuProcUtilInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetVgpuProcessesUtilizationInfo(device::nvmlDevice_t,
                                                                        vgpuProcUtilInfo::Ptr{nvmlVgpuProcessesUtilizationInfo_t})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetAccountingMode(vgpuInstance, mode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetAccountingMode(vgpuInstance::nvmlVgpuInstance_t,
                                                                mode::Ptr{nvmlEnableState_t})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetAccountingPids(vgpuInstance, count, pids)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetAccountingPids(vgpuInstance::nvmlVgpuInstance_t,
                                                                count::Ptr{Cuint},
                                                                pids::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetAccountingStats(vgpuInstance, pid, stats)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetAccountingStats(vgpuInstance::nvmlVgpuInstance_t,
                                                                 pid::Cuint,
                                                                 stats::Ptr{nvmlAccountingStats_t})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceClearAccountingPids(vgpuInstance)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceClearAccountingPids(vgpuInstance::nvmlVgpuInstance_t)::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetLicenseInfo_v2(vgpuInstance, licenseInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetLicenseInfo_v2(vgpuInstance::nvmlVgpuInstance_t,
                                                                licenseInfo::Ptr{nvmlVgpuLicenseInfo_t})::nvmlReturn_t
end

struct nvmlExcludedDeviceInfo_st
    pciInfo::nvmlPciInfo_t
    uuid::NTuple{80,Cchar}
end

const nvmlExcludedDeviceInfo_t = nvmlExcludedDeviceInfo_st

@checked function nvmlGetExcludedDeviceCount(deviceCount)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGetExcludedDeviceCount(deviceCount::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlGetExcludedDeviceInfoByIndex(index, info)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGetExcludedDeviceInfoByIndex(index::Cuint,
                                                               info::Ptr{nvmlExcludedDeviceInfo_t})::nvmlReturn_t
end

struct nvmlPRMTLV_v1_t
    data::NTuple{504,UInt8}
end

function Base.getproperty(x::Ptr{nvmlPRMTLV_v1_t}, f::Symbol)
    f === :dataSize && return Ptr{Cuint}(x + 0)
    f === :status && return Ptr{Cuint}(x + 4)
    f === :inData && return Ptr{NTuple{496,Cuchar}}(x + 8)
    f === :outData && return Ptr{NTuple{496,Cuchar}}(x + 8)
    return getfield(x, f)
end

function Base.getproperty(x::nvmlPRMTLV_v1_t, f::Symbol)
    r = Ref{nvmlPRMTLV_v1_t}(x)
    ptr = Base.unsafe_convert(Ptr{nvmlPRMTLV_v1_t}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{nvmlPRMTLV_v1_t}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::nvmlPRMTLV_v1_t, private::Bool=false)
    return (:dataSize, :status, :inData, :outData, if private
                fieldnames(typeof(x))
            else
                ()
            end...)
end

@checked function nvmlDeviceReadWritePRM_v1(device, buffer)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceReadWritePRM_v1(device::nvmlDevice_t,
                                                        buffer::Ptr{nvmlPRMTLV_v1_t})::nvmlReturn_t
end

struct nvmlGpuInstancePlacement_st
    start::Cuint
    size::Cuint
end

const nvmlGpuInstancePlacement_t = nvmlGpuInstancePlacement_st

struct nvmlGpuInstanceProfileInfo_st
    id::Cuint
    isP2pSupported::Cuint
    sliceCount::Cuint
    instanceCount::Cuint
    multiprocessorCount::Cuint
    copyEngineCount::Cuint
    decoderCount::Cuint
    encoderCount::Cuint
    jpegCount::Cuint
    ofaCount::Cuint
    memorySizeMB::Culonglong
end

const nvmlGpuInstanceProfileInfo_t = nvmlGpuInstanceProfileInfo_st

struct nvmlGpuInstanceProfileInfo_v2_st
    version::Cuint
    id::Cuint
    isP2pSupported::Cuint
    sliceCount::Cuint
    instanceCount::Cuint
    multiprocessorCount::Cuint
    copyEngineCount::Cuint
    decoderCount::Cuint
    encoderCount::Cuint
    jpegCount::Cuint
    ofaCount::Cuint
    memorySizeMB::Culonglong
    name::NTuple{96,Cchar}
end

const nvmlGpuInstanceProfileInfo_v2_t = nvmlGpuInstanceProfileInfo_v2_st

struct nvmlGpuInstanceProfileInfo_v3_st
    version::Cuint
    id::Cuint
    sliceCount::Cuint
    instanceCount::Cuint
    multiprocessorCount::Cuint
    copyEngineCount::Cuint
    decoderCount::Cuint
    encoderCount::Cuint
    jpegCount::Cuint
    ofaCount::Cuint
    memorySizeMB::Culonglong
    name::NTuple{96,Cchar}
    capabilities::Cuint
end

const nvmlGpuInstanceProfileInfo_v3_t = nvmlGpuInstanceProfileInfo_v3_st

struct nvmlGpuInstanceInfo_st
    device::nvmlDevice_t
    id::Cuint
    profileId::Cuint
    placement::nvmlGpuInstancePlacement_t
end

const nvmlGpuInstanceInfo_t = nvmlGpuInstanceInfo_st

struct nvmlComputeInstancePlacement_st
    start::Cuint
    size::Cuint
end

const nvmlComputeInstancePlacement_t = nvmlComputeInstancePlacement_st

struct nvmlComputeInstanceProfileInfo_st
    id::Cuint
    sliceCount::Cuint
    instanceCount::Cuint
    multiprocessorCount::Cuint
    sharedCopyEngineCount::Cuint
    sharedDecoderCount::Cuint
    sharedEncoderCount::Cuint
    sharedJpegCount::Cuint
    sharedOfaCount::Cuint
end

const nvmlComputeInstanceProfileInfo_t = nvmlComputeInstanceProfileInfo_st

struct nvmlComputeInstanceProfileInfo_v2_st
    version::Cuint
    id::Cuint
    sliceCount::Cuint
    instanceCount::Cuint
    multiprocessorCount::Cuint
    sharedCopyEngineCount::Cuint
    sharedDecoderCount::Cuint
    sharedEncoderCount::Cuint
    sharedJpegCount::Cuint
    sharedOfaCount::Cuint
    name::NTuple{96,Cchar}
end

const nvmlComputeInstanceProfileInfo_v2_t = nvmlComputeInstanceProfileInfo_v2_st

struct nvmlComputeInstanceProfileInfo_v3_st
    version::Cuint
    id::Cuint
    sliceCount::Cuint
    instanceCount::Cuint
    multiprocessorCount::Cuint
    sharedCopyEngineCount::Cuint
    sharedDecoderCount::Cuint
    sharedEncoderCount::Cuint
    sharedJpegCount::Cuint
    sharedOfaCount::Cuint
    name::NTuple{96,Cchar}
    capabilities::Cuint
end

const nvmlComputeInstanceProfileInfo_v3_t = nvmlComputeInstanceProfileInfo_v3_st

struct nvmlComputeInstanceInfo_st
    device::nvmlDevice_t
    gpuInstance::nvmlGpuInstance_t
    id::Cuint
    profileId::Cuint
    placement::nvmlComputeInstancePlacement_t
end

const nvmlComputeInstanceInfo_t = nvmlComputeInstanceInfo_st

mutable struct nvmlComputeInstance_st end

const nvmlComputeInstance_t = Ptr{nvmlComputeInstance_st}

@checked function nvmlDeviceSetMigMode(device, mode, activationStatus)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceSetMigMode(device::nvmlDevice_t, mode::Cuint,
                                                   activationStatus::Ptr{nvmlReturn_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetMigMode(device, currentMode, pendingMode)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMigMode(device::nvmlDevice_t,
                                                   currentMode::Ptr{Cuint},
                                                   pendingMode::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetGpuInstanceProfileInfo(device, profile, info)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGpuInstanceProfileInfo(device::nvmlDevice_t,
                                                                  profile::Cuint,
                                                                  info::Ptr{nvmlGpuInstanceProfileInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetGpuInstanceProfileInfoV(device, profile, info)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGpuInstanceProfileInfoV(device::nvmlDevice_t,
                                                                   profile::Cuint,
                                                                   info::Ptr{nvmlGpuInstanceProfileInfo_v2_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetGpuInstanceProfileInfoByIdV(device, profileId, info)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGpuInstanceProfileInfoByIdV(device::nvmlDevice_t,
                                                                       profileId::Cuint,
                                                                       info::Ptr{nvmlGpuInstanceProfileInfo_v2_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetGpuInstancePossiblePlacements_v2(device, profileId,
                                                                placements, count)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGpuInstancePossiblePlacements_v2(device::nvmlDevice_t,
                                                                            profileId::Cuint,
                                                                            placements::Ptr{nvmlGpuInstancePlacement_t},
                                                                            count::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetGpuInstanceRemainingCapacity(device, profileId, count)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGpuInstanceRemainingCapacity(device::nvmlDevice_t,
                                                                        profileId::Cuint,
                                                                        count::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceCreateGpuInstance(device, profileId, gpuInstance)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceCreateGpuInstance(device::nvmlDevice_t,
                                                          profileId::Cuint,
                                                          gpuInstance::Ptr{nvmlGpuInstance_t})::nvmlReturn_t
end

@checked function nvmlDeviceCreateGpuInstanceWithPlacement(device, profileId, placement,
                                                           gpuInstance)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceCreateGpuInstanceWithPlacement(device::nvmlDevice_t,
                                                                       profileId::Cuint,
                                                                       placement::Ptr{nvmlGpuInstancePlacement_t},
                                                                       gpuInstance::Ptr{nvmlGpuInstance_t})::nvmlReturn_t
end

@checked function nvmlGpuInstanceDestroy(gpuInstance)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpuInstanceDestroy(gpuInstance::nvmlGpuInstance_t)::nvmlReturn_t
end

@checked function nvmlDeviceGetGpuInstances(device, profileId, gpuInstances, count)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGpuInstances(device::nvmlDevice_t,
                                                        profileId::Cuint,
                                                        gpuInstances::Ptr{nvmlGpuInstance_t},
                                                        count::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetGpuInstanceById(device, id, gpuInstance)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGpuInstanceById(device::nvmlDevice_t, id::Cuint,
                                                           gpuInstance::Ptr{nvmlGpuInstance_t})::nvmlReturn_t
end

@checked function nvmlGpuInstanceGetInfo(gpuInstance, info)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpuInstanceGetInfo(gpuInstance::nvmlGpuInstance_t,
                                                     info::Ptr{nvmlGpuInstanceInfo_t})::nvmlReturn_t
end

@checked function nvmlGpuInstanceGetComputeInstanceProfileInfo(gpuInstance, profile,
                                                               engProfile, info)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpuInstanceGetComputeInstanceProfileInfo(gpuInstance::nvmlGpuInstance_t,
                                                                           profile::Cuint,
                                                                           engProfile::Cuint,
                                                                           info::Ptr{nvmlComputeInstanceProfileInfo_t})::nvmlReturn_t
end

@checked function nvmlGpuInstanceGetComputeInstanceProfileInfoV(gpuInstance, profile,
                                                                engProfile, info)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpuInstanceGetComputeInstanceProfileInfoV(gpuInstance::nvmlGpuInstance_t,
                                                                            profile::Cuint,
                                                                            engProfile::Cuint,
                                                                            info::Ptr{nvmlComputeInstanceProfileInfo_v2_t})::nvmlReturn_t
end

@checked function nvmlGpuInstanceGetComputeInstanceRemainingCapacity(gpuInstance, profileId,
                                                                     count)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpuInstanceGetComputeInstanceRemainingCapacity(gpuInstance::nvmlGpuInstance_t,
                                                                                 profileId::Cuint,
                                                                                 count::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlGpuInstanceGetComputeInstancePossiblePlacements(gpuInstance,
                                                                      profileId, placements,
                                                                      count)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpuInstanceGetComputeInstancePossiblePlacements(gpuInstance::nvmlGpuInstance_t,
                                                                                  profileId::Cuint,
                                                                                  placements::Ptr{nvmlComputeInstancePlacement_t},
                                                                                  count::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlGpuInstanceCreateComputeInstance(gpuInstance, profileId,
                                                       computeInstance)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpuInstanceCreateComputeInstance(gpuInstance::nvmlGpuInstance_t,
                                                                   profileId::Cuint,
                                                                   computeInstance::Ptr{nvmlComputeInstance_t})::nvmlReturn_t
end

@checked function nvmlGpuInstanceCreateComputeInstanceWithPlacement(gpuInstance, profileId,
                                                                    placement,
                                                                    computeInstance)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpuInstanceCreateComputeInstanceWithPlacement(gpuInstance::nvmlGpuInstance_t,
                                                                                profileId::Cuint,
                                                                                placement::Ptr{nvmlComputeInstancePlacement_t},
                                                                                computeInstance::Ptr{nvmlComputeInstance_t})::nvmlReturn_t
end

@checked function nvmlComputeInstanceDestroy(computeInstance)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlComputeInstanceDestroy(computeInstance::nvmlComputeInstance_t)::nvmlReturn_t
end

@checked function nvmlGpuInstanceGetComputeInstances(gpuInstance, profileId,
                                                     computeInstances, count)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpuInstanceGetComputeInstances(gpuInstance::nvmlGpuInstance_t,
                                                                 profileId::Cuint,
                                                                 computeInstances::Ptr{nvmlComputeInstance_t},
                                                                 count::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlGpuInstanceGetComputeInstanceById(gpuInstance, id, computeInstance)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpuInstanceGetComputeInstanceById(gpuInstance::nvmlGpuInstance_t,
                                                                    id::Cuint,
                                                                    computeInstance::Ptr{nvmlComputeInstance_t})::nvmlReturn_t
end

@checked function nvmlComputeInstanceGetInfo_v2(computeInstance, info)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlComputeInstanceGetInfo_v2(computeInstance::nvmlComputeInstance_t,
                                                            info::Ptr{nvmlComputeInstanceInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceIsMigDeviceHandle(device, isMigDevice)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceIsMigDeviceHandle(device::nvmlDevice_t,
                                                          isMigDevice::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetGpuInstanceId(device, id)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGpuInstanceId(device::nvmlDevice_t,
                                                         id::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetComputeInstanceId(device, id)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetComputeInstanceId(device::nvmlDevice_t,
                                                             id::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetMaxMigDeviceCount(device, count)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMaxMigDeviceCount(device::nvmlDevice_t,
                                                             count::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetMigDeviceHandleByIndex(device, index, migDevice)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMigDeviceHandleByIndex(device::nvmlDevice_t,
                                                                  index::Cuint,
                                                                  migDevice::Ptr{nvmlDevice_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetDeviceHandleFromMigDeviceHandle(migDevice, device)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetDeviceHandleFromMigDeviceHandle(migDevice::nvmlDevice_t,
                                                                           device::Ptr{nvmlDevice_t})::nvmlReturn_t
end

@cenum nvmlGpmMetricId_t::UInt32 begin
    NVML_GPM_METRIC_GRAPHICS_UTIL = 1
    NVML_GPM_METRIC_SM_UTIL = 2
    NVML_GPM_METRIC_SM_OCCUPANCY = 3
    NVML_GPM_METRIC_INTEGER_UTIL = 4
    NVML_GPM_METRIC_ANY_TENSOR_UTIL = 5
    NVML_GPM_METRIC_DFMA_TENSOR_UTIL = 6
    NVML_GPM_METRIC_HMMA_TENSOR_UTIL = 7
    NVML_GPM_METRIC_IMMA_TENSOR_UTIL = 9
    NVML_GPM_METRIC_DRAM_BW_UTIL = 10
    NVML_GPM_METRIC_FP64_UTIL = 11
    NVML_GPM_METRIC_FP32_UTIL = 12
    NVML_GPM_METRIC_FP16_UTIL = 13
    NVML_GPM_METRIC_PCIE_TX_PER_SEC = 20
    NVML_GPM_METRIC_PCIE_RX_PER_SEC = 21
    NVML_GPM_METRIC_NVDEC_0_UTIL = 30
    NVML_GPM_METRIC_NVDEC_1_UTIL = 31
    NVML_GPM_METRIC_NVDEC_2_UTIL = 32
    NVML_GPM_METRIC_NVDEC_3_UTIL = 33
    NVML_GPM_METRIC_NVDEC_4_UTIL = 34
    NVML_GPM_METRIC_NVDEC_5_UTIL = 35
    NVML_GPM_METRIC_NVDEC_6_UTIL = 36
    NVML_GPM_METRIC_NVDEC_7_UTIL = 37
    NVML_GPM_METRIC_NVJPG_0_UTIL = 40
    NVML_GPM_METRIC_NVJPG_1_UTIL = 41
    NVML_GPM_METRIC_NVJPG_2_UTIL = 42
    NVML_GPM_METRIC_NVJPG_3_UTIL = 43
    NVML_GPM_METRIC_NVJPG_4_UTIL = 44
    NVML_GPM_METRIC_NVJPG_5_UTIL = 45
    NVML_GPM_METRIC_NVJPG_6_UTIL = 46
    NVML_GPM_METRIC_NVJPG_7_UTIL = 47
    NVML_GPM_METRIC_NVOFA_0_UTIL = 50
    NVML_GPM_METRIC_NVOFA_1_UTIL = 51
    NVML_GPM_METRIC_NVLINK_TOTAL_RX_PER_SEC = 60
    NVML_GPM_METRIC_NVLINK_TOTAL_TX_PER_SEC = 61
    NVML_GPM_METRIC_NVLINK_L0_RX_PER_SEC = 62
    NVML_GPM_METRIC_NVLINK_L0_TX_PER_SEC = 63
    NVML_GPM_METRIC_NVLINK_L1_RX_PER_SEC = 64
    NVML_GPM_METRIC_NVLINK_L1_TX_PER_SEC = 65
    NVML_GPM_METRIC_NVLINK_L2_RX_PER_SEC = 66
    NVML_GPM_METRIC_NVLINK_L2_TX_PER_SEC = 67
    NVML_GPM_METRIC_NVLINK_L3_RX_PER_SEC = 68
    NVML_GPM_METRIC_NVLINK_L3_TX_PER_SEC = 69
    NVML_GPM_METRIC_NVLINK_L4_RX_PER_SEC = 70
    NVML_GPM_METRIC_NVLINK_L4_TX_PER_SEC = 71
    NVML_GPM_METRIC_NVLINK_L5_RX_PER_SEC = 72
    NVML_GPM_METRIC_NVLINK_L5_TX_PER_SEC = 73
    NVML_GPM_METRIC_NVLINK_L6_RX_PER_SEC = 74
    NVML_GPM_METRIC_NVLINK_L6_TX_PER_SEC = 75
    NVML_GPM_METRIC_NVLINK_L7_RX_PER_SEC = 76
    NVML_GPM_METRIC_NVLINK_L7_TX_PER_SEC = 77
    NVML_GPM_METRIC_NVLINK_L8_RX_PER_SEC = 78
    NVML_GPM_METRIC_NVLINK_L8_TX_PER_SEC = 79
    NVML_GPM_METRIC_NVLINK_L9_RX_PER_SEC = 80
    NVML_GPM_METRIC_NVLINK_L9_TX_PER_SEC = 81
    NVML_GPM_METRIC_NVLINK_L10_RX_PER_SEC = 82
    NVML_GPM_METRIC_NVLINK_L10_TX_PER_SEC = 83
    NVML_GPM_METRIC_NVLINK_L11_RX_PER_SEC = 84
    NVML_GPM_METRIC_NVLINK_L11_TX_PER_SEC = 85
    NVML_GPM_METRIC_NVLINK_L12_RX_PER_SEC = 86
    NVML_GPM_METRIC_NVLINK_L12_TX_PER_SEC = 87
    NVML_GPM_METRIC_NVLINK_L13_RX_PER_SEC = 88
    NVML_GPM_METRIC_NVLINK_L13_TX_PER_SEC = 89
    NVML_GPM_METRIC_NVLINK_L14_RX_PER_SEC = 90
    NVML_GPM_METRIC_NVLINK_L14_TX_PER_SEC = 91
    NVML_GPM_METRIC_NVLINK_L15_RX_PER_SEC = 92
    NVML_GPM_METRIC_NVLINK_L15_TX_PER_SEC = 93
    NVML_GPM_METRIC_NVLINK_L16_RX_PER_SEC = 94
    NVML_GPM_METRIC_NVLINK_L16_TX_PER_SEC = 95
    NVML_GPM_METRIC_NVLINK_L17_RX_PER_SEC = 96
    NVML_GPM_METRIC_NVLINK_L17_TX_PER_SEC = 97
    NVML_GPM_METRIC_C2C_TOTAL_TX_PER_SEC = 100
    NVML_GPM_METRIC_C2C_TOTAL_RX_PER_SEC = 101
    NVML_GPM_METRIC_C2C_DATA_TX_PER_SEC = 102
    NVML_GPM_METRIC_C2C_DATA_RX_PER_SEC = 103
    NVML_GPM_METRIC_C2C_LINK0_TOTAL_TX_PER_SEC = 104
    NVML_GPM_METRIC_C2C_LINK0_TOTAL_RX_PER_SEC = 105
    NVML_GPM_METRIC_C2C_LINK0_DATA_TX_PER_SEC = 106
    NVML_GPM_METRIC_C2C_LINK0_DATA_RX_PER_SEC = 107
    NVML_GPM_METRIC_C2C_LINK1_TOTAL_TX_PER_SEC = 108
    NVML_GPM_METRIC_C2C_LINK1_TOTAL_RX_PER_SEC = 109
    NVML_GPM_METRIC_C2C_LINK1_DATA_TX_PER_SEC = 110
    NVML_GPM_METRIC_C2C_LINK1_DATA_RX_PER_SEC = 111
    NVML_GPM_METRIC_C2C_LINK2_TOTAL_TX_PER_SEC = 112
    NVML_GPM_METRIC_C2C_LINK2_TOTAL_RX_PER_SEC = 113
    NVML_GPM_METRIC_C2C_LINK2_DATA_TX_PER_SEC = 114
    NVML_GPM_METRIC_C2C_LINK2_DATA_RX_PER_SEC = 115
    NVML_GPM_METRIC_C2C_LINK3_TOTAL_TX_PER_SEC = 116
    NVML_GPM_METRIC_C2C_LINK3_TOTAL_RX_PER_SEC = 117
    NVML_GPM_METRIC_C2C_LINK3_DATA_TX_PER_SEC = 118
    NVML_GPM_METRIC_C2C_LINK3_DATA_RX_PER_SEC = 119
    NVML_GPM_METRIC_C2C_LINK4_TOTAL_TX_PER_SEC = 120
    NVML_GPM_METRIC_C2C_LINK4_TOTAL_RX_PER_SEC = 121
    NVML_GPM_METRIC_C2C_LINK4_DATA_TX_PER_SEC = 122
    NVML_GPM_METRIC_C2C_LINK4_DATA_RX_PER_SEC = 123
    NVML_GPM_METRIC_C2C_LINK5_TOTAL_TX_PER_SEC = 124
    NVML_GPM_METRIC_C2C_LINK5_TOTAL_RX_PER_SEC = 125
    NVML_GPM_METRIC_C2C_LINK5_DATA_TX_PER_SEC = 126
    NVML_GPM_METRIC_C2C_LINK5_DATA_RX_PER_SEC = 127
    NVML_GPM_METRIC_C2C_LINK6_TOTAL_TX_PER_SEC = 128
    NVML_GPM_METRIC_C2C_LINK6_TOTAL_RX_PER_SEC = 129
    NVML_GPM_METRIC_C2C_LINK6_DATA_TX_PER_SEC = 130
    NVML_GPM_METRIC_C2C_LINK6_DATA_RX_PER_SEC = 131
    NVML_GPM_METRIC_C2C_LINK7_TOTAL_TX_PER_SEC = 132
    NVML_GPM_METRIC_C2C_LINK7_TOTAL_RX_PER_SEC = 133
    NVML_GPM_METRIC_C2C_LINK7_DATA_TX_PER_SEC = 134
    NVML_GPM_METRIC_C2C_LINK7_DATA_RX_PER_SEC = 135
    NVML_GPM_METRIC_C2C_LINK8_TOTAL_TX_PER_SEC = 136
    NVML_GPM_METRIC_C2C_LINK8_TOTAL_RX_PER_SEC = 137
    NVML_GPM_METRIC_C2C_LINK8_DATA_TX_PER_SEC = 138
    NVML_GPM_METRIC_C2C_LINK8_DATA_RX_PER_SEC = 139
    NVML_GPM_METRIC_C2C_LINK9_TOTAL_TX_PER_SEC = 140
    NVML_GPM_METRIC_C2C_LINK9_TOTAL_RX_PER_SEC = 141
    NVML_GPM_METRIC_C2C_LINK9_DATA_TX_PER_SEC = 142
    NVML_GPM_METRIC_C2C_LINK9_DATA_RX_PER_SEC = 143
    NVML_GPM_METRIC_C2C_LINK10_TOTAL_TX_PER_SEC = 144
    NVML_GPM_METRIC_C2C_LINK10_TOTAL_RX_PER_SEC = 145
    NVML_GPM_METRIC_C2C_LINK10_DATA_TX_PER_SEC = 146
    NVML_GPM_METRIC_C2C_LINK10_DATA_RX_PER_SEC = 147
    NVML_GPM_METRIC_C2C_LINK11_TOTAL_TX_PER_SEC = 148
    NVML_GPM_METRIC_C2C_LINK11_TOTAL_RX_PER_SEC = 149
    NVML_GPM_METRIC_C2C_LINK11_DATA_TX_PER_SEC = 150
    NVML_GPM_METRIC_C2C_LINK11_DATA_RX_PER_SEC = 151
    NVML_GPM_METRIC_C2C_LINK12_TOTAL_TX_PER_SEC = 152
    NVML_GPM_METRIC_C2C_LINK12_TOTAL_RX_PER_SEC = 153
    NVML_GPM_METRIC_C2C_LINK12_DATA_TX_PER_SEC = 154
    NVML_GPM_METRIC_C2C_LINK12_DATA_RX_PER_SEC = 155
    NVML_GPM_METRIC_C2C_LINK13_TOTAL_TX_PER_SEC = 156
    NVML_GPM_METRIC_C2C_LINK13_TOTAL_RX_PER_SEC = 157
    NVML_GPM_METRIC_C2C_LINK13_DATA_TX_PER_SEC = 158
    NVML_GPM_METRIC_C2C_LINK13_DATA_RX_PER_SEC = 159
    NVML_GPM_METRIC_HOSTMEM_CACHE_HIT = 160
    NVML_GPM_METRIC_HOSTMEM_CACHE_MISS = 161
    NVML_GPM_METRIC_PEERMEM_CACHE_HIT = 162
    NVML_GPM_METRIC_PEERMEM_CACHE_MISS = 163
    NVML_GPM_METRIC_DRAM_CACHE_HIT = 164
    NVML_GPM_METRIC_DRAM_CACHE_MISS = 165
    NVML_GPM_METRIC_NVENC_0_UTIL = 166
    NVML_GPM_METRIC_NVENC_1_UTIL = 167
    NVML_GPM_METRIC_NVENC_2_UTIL = 168
    NVML_GPM_METRIC_NVENC_3_UTIL = 169
    NVML_GPM_METRIC_GR0_CTXSW_CYCLES_ELAPSED = 170
    NVML_GPM_METRIC_GR0_CTXSW_CYCLES_ACTIVE = 171
    NVML_GPM_METRIC_GR0_CTXSW_REQUESTS = 172
    NVML_GPM_METRIC_GR0_CTXSW_CYCLES_PER_REQ = 173
    NVML_GPM_METRIC_GR0_CTXSW_ACTIVE_PCT = 174
    NVML_GPM_METRIC_GR1_CTXSW_CYCLES_ELAPSED = 175
    NVML_GPM_METRIC_GR1_CTXSW_CYCLES_ACTIVE = 176
    NVML_GPM_METRIC_GR1_CTXSW_REQUESTS = 177
    NVML_GPM_METRIC_GR1_CTXSW_CYCLES_PER_REQ = 178
    NVML_GPM_METRIC_GR1_CTXSW_ACTIVE_PCT = 179
    NVML_GPM_METRIC_GR2_CTXSW_CYCLES_ELAPSED = 180
    NVML_GPM_METRIC_GR2_CTXSW_CYCLES_ACTIVE = 181
    NVML_GPM_METRIC_GR2_CTXSW_REQUESTS = 182
    NVML_GPM_METRIC_GR2_CTXSW_CYCLES_PER_REQ = 183
    NVML_GPM_METRIC_GR2_CTXSW_ACTIVE_PCT = 184
    NVML_GPM_METRIC_GR3_CTXSW_CYCLES_ELAPSED = 185
    NVML_GPM_METRIC_GR3_CTXSW_CYCLES_ACTIVE = 186
    NVML_GPM_METRIC_GR3_CTXSW_REQUESTS = 187
    NVML_GPM_METRIC_GR3_CTXSW_CYCLES_PER_REQ = 188
    NVML_GPM_METRIC_GR3_CTXSW_ACTIVE_PCT = 189
    NVML_GPM_METRIC_GR4_CTXSW_CYCLES_ELAPSED = 190
    NVML_GPM_METRIC_GR4_CTXSW_CYCLES_ACTIVE = 191
    NVML_GPM_METRIC_GR4_CTXSW_REQUESTS = 192
    NVML_GPM_METRIC_GR4_CTXSW_CYCLES_PER_REQ = 193
    NVML_GPM_METRIC_GR4_CTXSW_ACTIVE_PCT = 194
    NVML_GPM_METRIC_GR5_CTXSW_CYCLES_ELAPSED = 195
    NVML_GPM_METRIC_GR5_CTXSW_CYCLES_ACTIVE = 196
    NVML_GPM_METRIC_GR5_CTXSW_REQUESTS = 197
    NVML_GPM_METRIC_GR5_CTXSW_CYCLES_PER_REQ = 198
    NVML_GPM_METRIC_GR5_CTXSW_ACTIVE_PCT = 199
    NVML_GPM_METRIC_GR6_CTXSW_CYCLES_ELAPSED = 200
    NVML_GPM_METRIC_GR6_CTXSW_CYCLES_ACTIVE = 201
    NVML_GPM_METRIC_GR6_CTXSW_REQUESTS = 202
    NVML_GPM_METRIC_GR6_CTXSW_CYCLES_PER_REQ = 203
    NVML_GPM_METRIC_GR6_CTXSW_ACTIVE_PCT = 204
    NVML_GPM_METRIC_GR7_CTXSW_CYCLES_ELAPSED = 205
    NVML_GPM_METRIC_GR7_CTXSW_CYCLES_ACTIVE = 206
    NVML_GPM_METRIC_GR7_CTXSW_REQUESTS = 207
    NVML_GPM_METRIC_GR7_CTXSW_CYCLES_PER_REQ = 208
    NVML_GPM_METRIC_GR7_CTXSW_ACTIVE_PCT = 209
    NVML_GPM_METRIC_MAX = 210
end

mutable struct nvmlGpmSample_st end

const nvmlGpmSample_t = Ptr{nvmlGpmSample_st}

struct var"##Ctag#271"
    shortName::Cstring
    longName::Cstring
    unit::Cstring
end
function Base.getproperty(x::Ptr{var"##Ctag#271"}, f::Symbol)
    f === :shortName && return Ptr{Cstring}(x + 0)
    f === :longName && return Ptr{Cstring}(x + 8)
    f === :unit && return Ptr{Cstring}(x + 16)
    return getfield(x, f)
end

function Base.getproperty(x::var"##Ctag#271", f::Symbol)
    r = Ref{var"##Ctag#271"}(x)
    ptr = Base.unsafe_convert(Ptr{var"##Ctag#271"}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{var"##Ctag#271"}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

struct nvmlGpmMetric_t
    data::NTuple{40,UInt8}
end

function Base.getproperty(x::Ptr{nvmlGpmMetric_t}, f::Symbol)
    f === :metricId && return Ptr{Cuint}(x + 0)
    f === :nvmlReturn && return Ptr{nvmlReturn_t}(x + 4)
    f === :value && return Ptr{Cdouble}(x + 8)
    f === :metricInfo && return Ptr{var"##Ctag#271"}(x + 16)
    return getfield(x, f)
end

function Base.getproperty(x::nvmlGpmMetric_t, f::Symbol)
    r = Ref{nvmlGpmMetric_t}(x)
    ptr = Base.unsafe_convert(Ptr{nvmlGpmMetric_t}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{nvmlGpmMetric_t}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::nvmlGpmMetric_t, private::Bool=false)
    return (:metricId, :nvmlReturn, :value, :metricInfo, if private
                fieldnames(typeof(x))
            else
                ()
            end...)
end

struct nvmlGpmMetricsGet_t
    version::Cuint
    numMetrics::Cuint
    sample1::nvmlGpmSample_t
    sample2::nvmlGpmSample_t
    metrics::NTuple{210,nvmlGpmMetric_t}
end

struct nvmlGpmSupport_t
    version::Cuint
    isSupportedDevice::Cuint
end

@checked function nvmlGpmMetricsGet(metricsGet)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpmMetricsGet(metricsGet::Ptr{nvmlGpmMetricsGet_t})::nvmlReturn_t
end

@checked function nvmlGpmSampleFree(gpmSample)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpmSampleFree(gpmSample::nvmlGpmSample_t)::nvmlReturn_t
end

@checked function nvmlGpmSampleAlloc(gpmSample)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpmSampleAlloc(gpmSample::Ptr{nvmlGpmSample_t})::nvmlReturn_t
end

@checked function nvmlGpmSampleGet(device, gpmSample)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpmSampleGet(device::nvmlDevice_t,
                                               gpmSample::nvmlGpmSample_t)::nvmlReturn_t
end

@checked function nvmlGpmMigSampleGet(device, gpuInstanceId, gpmSample)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpmMigSampleGet(device::nvmlDevice_t,
                                                  gpuInstanceId::Cuint,
                                                  gpmSample::nvmlGpmSample_t)::nvmlReturn_t
end

@checked function nvmlGpmQueryDeviceSupport(device, gpmSupport)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpmQueryDeviceSupport(device::nvmlDevice_t,
                                                        gpmSupport::Ptr{nvmlGpmSupport_t})::nvmlReturn_t
end

@checked function nvmlGpmQueryIfStreamingEnabled(device, state)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpmQueryIfStreamingEnabled(device::nvmlDevice_t,
                                                             state::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlGpmSetStreamingEnabled(device, state)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlGpmSetStreamingEnabled(device::nvmlDevice_t,
                                                         state::Cuint)::nvmlReturn_t
end

struct nvmlDeviceCapabilities_v1_t
    version::Cuint
    capMask::Cuint
end

const nvmlDeviceCapabilities_t = nvmlDeviceCapabilities_v1_t

@checked function nvmlDeviceGetCapabilities(device, caps)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetCapabilities(device::nvmlDevice_t,
                                                        caps::Ptr{nvmlDeviceCapabilities_t})::nvmlReturn_t
end

struct nvmlMask255_t
    mask::NTuple{8,Cuint}
end

@cenum nvmlPowerProfileType_t::UInt32 begin
    NVML_POWER_PROFILE_MAX_P = 0
    NVML_POWER_PROFILE_MAX_Q = 1
    NVML_POWER_PROFILE_COMPUTE = 2
    NVML_POWER_PROFILE_MEMORY_BOUND = 3
    NVML_POWER_PROFILE_NETWORK = 4
    NVML_POWER_PROFILE_BALANCED = 5
    NVML_POWER_PROFILE_LLM_INFERENCE = 6
    NVML_POWER_PROFILE_LLM_TRAINING = 7
    NVML_POWER_PROFILE_RBM = 8
    NVML_POWER_PROFILE_DCPCIE = 9
    NVML_POWER_PROFILE_HMMA_SPARSE = 10
    NVML_POWER_PROFILE_HMMA_DENSE = 11
    NVML_POWER_PROFILE_SYNC_BALANCED = 12
    NVML_POWER_PROFILE_HPC = 13
    NVML_POWER_PROFILE_MIG = 14
    NVML_POWER_PROFILE_MAX = 15
end

struct nvmlWorkloadPowerProfileInfo_v1_t
    version::Cuint
    profileId::Cuint
    priority::Cuint
    conflictingMask::nvmlMask255_t
end

const nvmlWorkloadPowerProfileInfo_t = nvmlWorkloadPowerProfileInfo_v1_t

struct nvmlWorkloadPowerProfileProfilesInfo_v1_t
    version::Cuint
    perfProfilesMask::nvmlMask255_t
    perfProfile::NTuple{255,nvmlWorkloadPowerProfileInfo_t}
end

const nvmlWorkloadPowerProfileProfilesInfo_t = nvmlWorkloadPowerProfileProfilesInfo_v1_t

struct nvmlWorkloadPowerProfileCurrentProfiles_v1_t
    version::Cuint
    perfProfilesMask::nvmlMask255_t
    requestedProfilesMask::nvmlMask255_t
    enforcedProfilesMask::nvmlMask255_t
end

const nvmlWorkloadPowerProfileCurrentProfiles_t = nvmlWorkloadPowerProfileCurrentProfiles_v1_t

struct nvmlWorkloadPowerProfileRequestedProfiles_v1_t
    version::Cuint
    requestedProfilesMask::nvmlMask255_t
end

const nvmlWorkloadPowerProfileRequestedProfiles_t = nvmlWorkloadPowerProfileRequestedProfiles_v1_t

@checked function nvmlDeviceWorkloadPowerProfileGetProfilesInfo(device, profilesInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceWorkloadPowerProfileGetProfilesInfo(device::nvmlDevice_t,
                                                                            profilesInfo::Ptr{nvmlWorkloadPowerProfileProfilesInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceWorkloadPowerProfileGetCurrentProfiles(device, currentProfiles)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceWorkloadPowerProfileGetCurrentProfiles(device::nvmlDevice_t,
                                                                               currentProfiles::Ptr{nvmlWorkloadPowerProfileCurrentProfiles_t})::nvmlReturn_t
end

@checked function nvmlDeviceWorkloadPowerProfileSetRequestedProfiles(device,
                                                                     requestedProfiles)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceWorkloadPowerProfileSetRequestedProfiles(device::nvmlDevice_t,
                                                                                 requestedProfiles::Ptr{nvmlWorkloadPowerProfileRequestedProfiles_t})::nvmlReturn_t
end

@checked function nvmlDeviceWorkloadPowerProfileClearRequestedProfiles(device,
                                                                       requestedProfiles)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceWorkloadPowerProfileClearRequestedProfiles(device::nvmlDevice_t,
                                                                                   requestedProfiles::Ptr{nvmlWorkloadPowerProfileRequestedProfiles_t})::nvmlReturn_t
end

struct nvmlPowerSmoothingProfile_v1_t
    version::Cuint
    profileId::Cuint
    paramId::Cuint
    value::Cdouble
end

const nvmlPowerSmoothingProfile_t = nvmlPowerSmoothingProfile_v1_t

struct nvmlPowerSmoothingState_v1_t
    version::Cuint
    state::nvmlEnableState_t
end

const nvmlPowerSmoothingState_t = nvmlPowerSmoothingState_v1_t

@checked function nvmlDevicePowerSmoothingActivatePresetProfile(device, profile)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDevicePowerSmoothingActivatePresetProfile(device::nvmlDevice_t,
                                                                            profile::Ptr{nvmlPowerSmoothingProfile_t})::nvmlReturn_t
end

@checked function nvmlDevicePowerSmoothingUpdatePresetProfileParam(device, profile)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDevicePowerSmoothingUpdatePresetProfileParam(device::nvmlDevice_t,
                                                                               profile::Ptr{nvmlPowerSmoothingProfile_t})::nvmlReturn_t
end

@checked function nvmlDevicePowerSmoothingSetState(device, state)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDevicePowerSmoothingSetState(device::nvmlDevice_t,
                                                               state::Ptr{nvmlPowerSmoothingState_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetSramUniqueUncorrectedEccErrorCounts(device, errorCounts)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetSramUniqueUncorrectedEccErrorCounts(device::nvmlDevice_t,
                                                                               errorCounts::Ptr{nvmlEccSramUniqueUncorrectedErrorCounts_t})::nvmlReturn_t
end

@checked function nvmlInit()
    @gcsafe_ccall (libnvml()).nvmlInit()::nvmlReturn_t
end

@checked function nvmlDeviceGetCount(deviceCount)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetCount(deviceCount::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlDeviceGetHandleByIndex(index, device)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetHandleByIndex(index::Cuint,
                                                         device::Ptr{nvmlDevice_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetHandleByPciBusId(pciBusId, device)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetHandleByPciBusId(pciBusId::Cstring,
                                                            device::Ptr{nvmlDevice_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetPciInfo(device, pci)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPciInfo(device::nvmlDevice_t,
                                                   pci::Ptr{nvmlPciInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetPciInfo_v2(device, pci)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetPciInfo_v2(device::nvmlDevice_t,
                                                      pci::Ptr{nvmlPciInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetNvLinkRemotePciInfo(device, link, pci)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetNvLinkRemotePciInfo(device::nvmlDevice_t,
                                                               link::Cuint,
                                                               pci::Ptr{nvmlPciInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetGridLicensableFeatures(device, pGridLicensableFeatures)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGridLicensableFeatures(device::nvmlDevice_t,
                                                                  pGridLicensableFeatures::Ptr{nvmlGridLicensableFeatures_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetGridLicensableFeatures_v2(device, pGridLicensableFeatures)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGridLicensableFeatures_v2(device::nvmlDevice_t,
                                                                     pGridLicensableFeatures::Ptr{nvmlGridLicensableFeatures_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetGridLicensableFeatures_v3(device, pGridLicensableFeatures)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGridLicensableFeatures_v3(device::nvmlDevice_t,
                                                                     pGridLicensableFeatures::Ptr{nvmlGridLicensableFeatures_t})::nvmlReturn_t
end

@checked function nvmlDeviceRemoveGpu(pciInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceRemoveGpu(pciInfo::Ptr{nvmlPciInfo_t})::nvmlReturn_t
end

@checked function nvmlEventSetWait(set, data, timeoutms)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlEventSetWait(set::nvmlEventSet_t,
                                               data::Ptr{nvmlEventData_t},
                                               timeoutms::Cuint)::nvmlReturn_t
end

@checked function nvmlDeviceGetAttributes(device, attributes)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetAttributes(device::nvmlDevice_t,
                                                      attributes::Ptr{nvmlDeviceAttributes_t})::nvmlReturn_t
end

@checked function nvmlComputeInstanceGetInfo(computeInstance, info)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlComputeInstanceGetInfo(computeInstance::nvmlComputeInstance_t,
                                                         info::Ptr{nvmlComputeInstanceInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetComputeRunningProcesses(device, infoCount, infos)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetComputeRunningProcesses(device::nvmlDevice_t,
                                                                   infoCount::Ptr{Cuint},
                                                                   infos::Ptr{nvmlProcessInfo_v1_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetComputeRunningProcesses_v2(device, infoCount, infos)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetComputeRunningProcesses_v2(device::nvmlDevice_t,
                                                                      infoCount::Ptr{Cuint},
                                                                      infos::Ptr{nvmlProcessInfo_v2_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetGraphicsRunningProcesses(device, infoCount, infos)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGraphicsRunningProcesses(device::nvmlDevice_t,
                                                                    infoCount::Ptr{Cuint},
                                                                    infos::Ptr{nvmlProcessInfo_v1_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetGraphicsRunningProcesses_v2(device, infoCount, infos)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGraphicsRunningProcesses_v2(device::nvmlDevice_t,
                                                                       infoCount::Ptr{Cuint},
                                                                       infos::Ptr{nvmlProcessInfo_v2_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetMPSComputeRunningProcesses(device, infoCount, infos)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMPSComputeRunningProcesses(device::nvmlDevice_t,
                                                                      infoCount::Ptr{Cuint},
                                                                      infos::Ptr{nvmlProcessInfo_v1_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetMPSComputeRunningProcesses_v2(device, infoCount, infos)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetMPSComputeRunningProcesses_v2(device::nvmlDevice_t,
                                                                         infoCount::Ptr{Cuint},
                                                                         infos::Ptr{nvmlProcessInfo_v2_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetGpuInstancePossiblePlacements(device, profileId, placements,
                                                             count)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetGpuInstancePossiblePlacements(device::nvmlDevice_t,
                                                                         profileId::Cuint,
                                                                         placements::Ptr{nvmlGpuInstancePlacement_t},
                                                                         count::Ptr{Cuint})::nvmlReturn_t
end

@checked function nvmlVgpuInstanceGetLicenseInfo(vgpuInstance, licenseInfo)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlVgpuInstanceGetLicenseInfo(vgpuInstance::nvmlVgpuInstance_t,
                                                             licenseInfo::Ptr{nvmlVgpuLicenseInfo_t})::nvmlReturn_t
end

@checked function nvmlDeviceGetDriverModel(device, current, pending)
    initialize_context()
    @gcsafe_ccall (libnvml()).nvmlDeviceGetDriverModel(device::nvmlDevice_t,
                                                       current::Ptr{nvmlDriverModel_t},
                                                       pending::Ptr{nvmlDriverModel_t})::nvmlReturn_t
end

struct var"##Ctag#268"
    avgFactor::Cuint
    timeslice::Cuint
end
function Base.getproperty(x::Ptr{var"##Ctag#268"}, f::Symbol)
    f === :avgFactor && return Ptr{Cuint}(x + 0)
    f === :timeslice && return Ptr{Cuint}(x + 4)
    return getfield(x, f)
end

function Base.getproperty(x::var"##Ctag#268", f::Symbol)
    r = Ref{var"##Ctag#268"}(x)
    ptr = Base.unsafe_convert(Ptr{var"##Ctag#268"}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{var"##Ctag#268"}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

struct var"##Ctag#269"
    timeslice::Cuint
end
function Base.getproperty(x::Ptr{var"##Ctag#269"}, f::Symbol)
    f === :timeslice && return Ptr{Cuint}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::var"##Ctag#269", f::Symbol)
    r = Ref{var"##Ctag#269"}(x)
    ptr = Base.unsafe_convert(Ptr{var"##Ctag#269"}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{var"##Ctag#269"}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

struct var"##Ctag#273"
    avgFactor::Cuint
    frequency::Cuint
end
function Base.getproperty(x::Ptr{var"##Ctag#273"}, f::Symbol)
    f === :avgFactor && return Ptr{Cuint}(x + 0)
    f === :frequency && return Ptr{Cuint}(x + 4)
    return getfield(x, f)
end

function Base.getproperty(x::var"##Ctag#273", f::Symbol)
    r = Ref{var"##Ctag#273"}(x)
    ptr = Base.unsafe_convert(Ptr{var"##Ctag#273"}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{var"##Ctag#273"}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

struct var"##Ctag#274"
    timeslice::Cuint
end
function Base.getproperty(x::Ptr{var"##Ctag#274"}, f::Symbol)
    f === :timeslice && return Ptr{Cuint}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::var"##Ctag#274", f::Symbol)
    r = Ref{var"##Ctag#274"}(x)
    ptr = Base.unsafe_convert(Ptr{var"##Ctag#274"}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{var"##Ctag#274"}, f::Symbol, v)
    return unsafe_store!(getproperty(x, f), v)
end

const NVML_API_VERSION = 13

const NVML_API_VERSION_STR = "13"

const NVML_VALUE_NOT_AVAILABLE = -1

const NVML_DEVICE_PCI_BUS_ID_BUFFER_SIZE = 32

const NVML_DEVICE_PCI_BUS_ID_BUFFER_V2_SIZE = 16

const nvmlPciInfoExt_v1 = @NVML_STRUCT_VERSION(PciInfoExt, 1)

const NVML_DEVICE_PCI_BUS_ID_LEGACY_FMT = "%04X:%02X:%02X.0"

const NVML_DEVICE_PCI_BUS_ID_FMT = "%08X:%02X:%02X.0"

const nvmlMemory_v2 = @NVML_STRUCT_VERSION(Memory, 2)

const nvmlProcessDetailList_v1 = @NVML_STRUCT_VERSION(ProcessDetailList, 1)

const nvmlC2cModeInfo_v1 = @NVML_STRUCT_VERSION(C2cModeInfo, 1)

const nvmlDeviceAddressingMode_v1 = @NVML_STRUCT_VERSION(DeviceAddressingMode, 1)

const nvmlRepairStatus_v1 = @NVML_STRUCT_VERSION(RepairStatus, 1)

const NVML_NVLINK_MAX_LINKS = 18

const NVML_TOPOLOGY_CPU = NVML_TOPOLOGY_NODE

const NVML_MAX_PHYSICAL_BRIDGE = 128

const NVML_MAX_THERMAL_SENSORS_PER_GPU = 3

const nvmlCoolerInfo_v1 = @NVML_STRUCT_VERSION(CoolerInfo, 1)

const NVML_DEVICE_UUID_ASCII_LEN = 41

const NVML_DEVICE_UUID_BINARY_LEN = 16

const nvmlUUID_v1 = @NVML_STRUCT_VERSION(UUID, 1)

const nvmlPdi_v1 = @NVML_STRUCT_VERSION(Pdi, 1)

const nvmlFlagDefault = 0x00

const nvmlFlagForce = 0x01

const nvmlDramEncryptionInfo_v1 = @NVML_STRUCT_VERSION(DramEncryptionInfo, 1)

const nvmlMarginTemperature_v1 = @NVML_STRUCT_VERSION(MarginTemperature, 1)

const MAX_CLK_DOMAINS = 32

const NVML_SINGLE_BIT_ECC = NVML_MEMORY_ERROR_TYPE_CORRECTED

const NVML_DOUBLE_BIT_ECC = NVML_MEMORY_ERROR_TYPE_UNCORRECTED

const NVML_MAX_GPU_PERF_PSTATES = 16

const nvmlClockOffset_v1 = @NVML_STRUCT_VERSION(ClockOffset, 1)

const nvmlFanSpeedInfo_v1 = @NVML_STRUCT_VERSION(FanSpeedInfo, 1)

const NVML_PERF_MODES_BUFFER_SIZE = 2048

const nvmlDevicePerfModes_v1 = @NVML_STRUCT_VERSION(DevicePerfModes, 1)

const nvmlDeviceCurrentClockFreqs_v1 = @NVML_STRUCT_VERSION(DeviceCurrentClockFreqs, 1)

const NVML_POWER_MIZER_MODE_ADAPTIVE = 0

const NVML_POWER_MIZER_MODE_PREFER_MAXIMUM_PERFORMANCE = 1

const NVML_POWER_MIZER_MODE_AUTO = 2

const NVML_POWER_MIZER_MODE_PREFER_CONSISTENT_PERFORMANCE = 3

const nvmlProcessesUtilizationInfo_v1 = @NVML_STRUCT_VERSION(ProcessesUtilizationInfo, 1)

const nvmlEccSramErrorStatus_v1 = @NVML_STRUCT_VERSION(EccSramErrorStatus, 1)

const nvmlPlatformInfo_v1 = @NVML_STRUCT_VERSION(PlatformInfo, 1)

const nvmlPlatformInfo_v2 = @NVML_STRUCT_VERSION(PlatformInfo, 2)

const NVML_DEVICE_HOSTNAME_BUFFER_SIZE = 64

const nvmlEccSramUniqueUncorrectedErrorCounts_v1 = @NVML_STRUCT_VERSION(EccSramUniqueUncorrectedErrorCounts,
                                                                        1)

const NVML_GSP_FIRMWARE_VERSION_BUF_SIZE = 0x40

const NVML_DEVICE_ARCH_KEPLER = 2

const NVML_DEVICE_ARCH_MAXWELL = 3

const NVML_DEVICE_ARCH_PASCAL = 4

const NVML_DEVICE_ARCH_VOLTA = 5

const NVML_DEVICE_ARCH_TURING = 6

const NVML_DEVICE_ARCH_AMPERE = 7

const NVML_DEVICE_ARCH_ADA = 8

const NVML_DEVICE_ARCH_HOPPER = 9

const NVML_DEVICE_ARCH_BLACKWELL = 10

const NVML_DEVICE_ARCH_UNKNOWN = 0xffffffff

const NVML_BUS_TYPE_UNKNOWN = 0

const NVML_BUS_TYPE_PCI = 1

const NVML_BUS_TYPE_PCIE = 2

const NVML_BUS_TYPE_FPCI = 3

const NVML_BUS_TYPE_AGP = 4

const NVML_FAN_POLICY_TEMPERATURE_CONTINOUS_SW = 0

const NVML_FAN_POLICY_MANUAL = 1

const NVML_POWER_SOURCE_AC = 0x00000000

const NVML_POWER_SOURCE_BATTERY = 0x00000001

const NVML_POWER_SOURCE_UNDERSIZED = 0x00000002

const NVML_PCIE_LINK_MAX_SPEED_INVALID = 0x00000000

const NVML_PCIE_LINK_MAX_SPEED_2500MBPS = 0x00000001

const NVML_PCIE_LINK_MAX_SPEED_5000MBPS = 0x00000002

const NVML_PCIE_LINK_MAX_SPEED_8000MBPS = 0x00000003

const NVML_PCIE_LINK_MAX_SPEED_16000MBPS = 0x00000004

const NVML_PCIE_LINK_MAX_SPEED_32000MBPS = 0x00000005

const NVML_PCIE_LINK_MAX_SPEED_64000MBPS = 0x00000006

const NVML_ADAPTIVE_CLOCKING_INFO_STATUS_DISABLED = 0x00000000

const NVML_ADAPTIVE_CLOCKING_INFO_STATUS_ENABLED = 0x00000001

const NVML_MAX_GPU_UTILIZATIONS = 8

const NVML_PCIE_ATOMICS_CAP_FETCHADD32 = 0x01

const NVML_PCIE_ATOMICS_CAP_FETCHADD64 = 0x02

const NVML_PCIE_ATOMICS_CAP_SWAP32 = 0x04

const NVML_PCIE_ATOMICS_CAP_SWAP64 = 0x08

const NVML_PCIE_ATOMICS_CAP_CAS32 = 0x10

const NVML_PCIE_ATOMICS_CAP_CAS64 = 0x20

const NVML_PCIE_ATOMICS_CAP_CAS128 = 0x40

const NVML_PCIE_ATOMICS_OPS_MAX = 7

const NVML_POWER_SCOPE_GPU = Cuint(0)

const NVML_POWER_SCOPE_MODULE = Cuint(1)

const NVML_POWER_SCOPE_MEMORY = Cuint(2)

const nvmlPowerValue_v2 = @NVML_STRUCT_VERSION(PowerValue, 2)

const NVML_GRID_LICENSE_EXPIRY_NOT_AVAILABLE = 0

const NVML_GRID_LICENSE_EXPIRY_INVALID = 1

const NVML_GRID_LICENSE_EXPIRY_VALID = 2

const NVML_GRID_LICENSE_EXPIRY_NOT_APPLICABLE = 3

const NVML_GRID_LICENSE_EXPIRY_PERMANENT = 4

const NVML_GRID_LICENSE_BUFFER_SIZE = 128

const NVML_VGPU_NAME_BUFFER_SIZE = 64

const NVML_GRID_LICENSE_FEATURE_MAX_COUNT = 3

const INVALID_GPU_INSTANCE_PROFILE_ID = 0xffffffff

const INVALID_GPU_INSTANCE_ID = 0xffffffff

const NVML_INVALID_VGPU_PLACEMENT_ID = 0xffff

const NVML_VGPU_VIRTUALIZATION_CAP_MIGRATION = 0:0

const NVML_VGPU_VIRTUALIZATION_CAP_MIGRATION_NO = 0x00

const NVML_VGPU_VIRTUALIZATION_CAP_MIGRATION_YES = 0x01

const NVML_VGPU_PGPU_VIRTUALIZATION_CAP_MIGRATION = 0:0

const NVML_VGPU_PGPU_VIRTUALIZATION_CAP_MIGRATION_NO = 0x00

const NVML_VGPU_PGPU_VIRTUALIZATION_CAP_MIGRATION_YES = 0x01

const NVML_VGPU_PGPU_HETEROGENEOUS_MODE = 0

const NVML_VGPU_PGPU_HOMOGENEOUS_MODE = 1

const nvmlVgpuHeterogeneousMode_v1 = @NVML_STRUCT_VERSION(VgpuHeterogeneousMode, 1)

const nvmlVgpuPlacementId_v1 = @NVML_STRUCT_VERSION(VgpuPlacementId, 1)

const nvmlVgpuPlacementList_v1 = @NVML_STRUCT_VERSION(VgpuPlacementList, 1)

const nvmlVgpuPlacementList_v2 = @NVML_STRUCT_VERSION(VgpuPlacementList, 2)

const nvmlVgpuTypeBar1Info_v1 = @NVML_STRUCT_VERSION(VgpuTypeBar1Info, 1)

const nvmlVgpuInstancesUtilizationInfo_v1 = @NVML_STRUCT_VERSION(VgpuInstancesUtilizationInfo,
                                                                 1)

const nvmlVgpuProcessesUtilizationInfo_v1 = @NVML_STRUCT_VERSION(VgpuProcessesUtilizationInfo,
                                                                 1)

const nvmlVgpuRuntimeState_v1 = @NVML_STRUCT_VERSION(VgpuRuntimeState, 1)

const NVML_VGPU_SCHEDULER_POLICY_UNKNOWN = 0

const NVML_VGPU_SCHEDULER_POLICY_BEST_EFFORT = 1

const NVML_VGPU_SCHEDULER_POLICY_EQUAL_SHARE = 2

const NVML_VGPU_SCHEDULER_POLICY_FIXED_SHARE = 3

const NVML_SUPPORTED_VGPU_SCHEDULER_POLICY_COUNT = 3

const NVML_SCHEDULER_SW_MAX_LOG_ENTRIES = 200

const NVML_VGPU_SCHEDULER_ARR_DEFAULT = 0

const NVML_VGPU_SCHEDULER_ARR_DISABLE = 1

const NVML_VGPU_SCHEDULER_ARR_ENABLE = 2

const NVML_VGPU_SCHEDULER_ENGINE_TYPE_GRAPHICS = 1

const NVML_GRID_LICENSE_STATE_UNKNOWN = 0

const NVML_GRID_LICENSE_STATE_UNINITIALIZED = 1

const NVML_GRID_LICENSE_STATE_UNLICENSED_UNRESTRICTED = 2

const NVML_GRID_LICENSE_STATE_UNLICENSED_RESTRICTED = 3

const NVML_GRID_LICENSE_STATE_UNLICENSED = 4

const NVML_GRID_LICENSE_STATE_LICENSED = 5

const nvmlVgpuTypeIdInfo_v1 = @NVML_STRUCT_VERSION(VgpuTypeIdInfo, 1)

const nvmlVgpuTypeMaxInstance_v1 = @NVML_STRUCT_VERSION(VgpuTypeMaxInstance, 1)

const nvmlActiveVgpuInstanceInfo_v1 = @NVML_STRUCT_VERSION(ActiveVgpuInstanceInfo, 1)

const nvmlVgpuSchedulerState_v1 = @NVML_STRUCT_VERSION(VgpuSchedulerState, 1)

const nvmlVgpuSchedulerStateInfo_v1 = @NVML_STRUCT_VERSION(VgpuSchedulerStateInfo, 1)

const nvmlVgpuSchedulerLogInfo_v1 = @NVML_STRUCT_VERSION(VgpuSchedulerLogInfo, 1)

const nvmlVgpuCreatablePlacementInfo_v1 = @NVML_STRUCT_VERSION(VgpuCreatablePlacementInfo,
                                                               1)

const NVML_FI_DEV_ECC_CURRENT = 1

const NVML_FI_DEV_ECC_PENDING = 2

const NVML_FI_DEV_ECC_SBE_VOL_TOTAL = 3

const NVML_FI_DEV_ECC_DBE_VOL_TOTAL = 4

const NVML_FI_DEV_ECC_SBE_AGG_TOTAL = 5

const NVML_FI_DEV_ECC_DBE_AGG_TOTAL = 6

const NVML_FI_DEV_ECC_SBE_VOL_L1 = 7

const NVML_FI_DEV_ECC_DBE_VOL_L1 = 8

const NVML_FI_DEV_ECC_SBE_VOL_L2 = 9

const NVML_FI_DEV_ECC_DBE_VOL_L2 = 10

const NVML_FI_DEV_ECC_SBE_VOL_DEV = 11

const NVML_FI_DEV_ECC_DBE_VOL_DEV = 12

const NVML_FI_DEV_ECC_SBE_VOL_REG = 13

const NVML_FI_DEV_ECC_DBE_VOL_REG = 14

const NVML_FI_DEV_ECC_SBE_VOL_TEX = 15

const NVML_FI_DEV_ECC_DBE_VOL_TEX = 16

const NVML_FI_DEV_ECC_DBE_VOL_CBU = 17

const NVML_FI_DEV_ECC_SBE_AGG_L1 = 18

const NVML_FI_DEV_ECC_DBE_AGG_L1 = 19

const NVML_FI_DEV_ECC_SBE_AGG_L2 = 20

const NVML_FI_DEV_ECC_DBE_AGG_L2 = 21

const NVML_FI_DEV_ECC_SBE_AGG_DEV = 22

const NVML_FI_DEV_ECC_DBE_AGG_DEV = 23

const NVML_FI_DEV_ECC_SBE_AGG_REG = 24

const NVML_FI_DEV_ECC_DBE_AGG_REG = 25

const NVML_FI_DEV_ECC_SBE_AGG_TEX = 26

const NVML_FI_DEV_ECC_DBE_AGG_TEX = 27

const NVML_FI_DEV_ECC_DBE_AGG_CBU = 28

const NVML_FI_DEV_RETIRED_SBE = 29

const NVML_FI_DEV_RETIRED_DBE = 30

const NVML_FI_DEV_RETIRED_PENDING = 31

const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L0 = 32

const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L1 = 33

const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L2 = 34

const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L3 = 35

const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L4 = 36

const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L5 = 37

const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_TOTAL = 38

const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L0 = 39

const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L1 = 40

const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L2 = 41

const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L3 = 42

const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L4 = 43

const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L5 = 44

const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_TOTAL = 45

const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L0 = 46

const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L1 = 47

const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L2 = 48

const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L3 = 49

const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L4 = 50

const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L5 = 51

const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_TOTAL = 52

const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L0 = 53

const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L1 = 54

const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L2 = 55

const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L3 = 56

const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L4 = 57

const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L5 = 58

const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_TOTAL = 59

const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L0 = 60

const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L1 = 61

const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L2 = 62

const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L3 = 63

const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L4 = 64

const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L5 = 65

const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_TOTAL = 66

const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L0 = 67

const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L1 = 68

const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L2 = 69

const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L3 = 70

const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L4 = 71

const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L5 = 72

const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_TOTAL = 73

const NVML_FI_DEV_PERF_POLICY_POWER = 74

const NVML_FI_DEV_PERF_POLICY_THERMAL = 75

const NVML_FI_DEV_PERF_POLICY_SYNC_BOOST = 76

const NVML_FI_DEV_PERF_POLICY_BOARD_LIMIT = 77

const NVML_FI_DEV_PERF_POLICY_LOW_UTILIZATION = 78

const NVML_FI_DEV_PERF_POLICY_RELIABILITY = 79

const NVML_FI_DEV_PERF_POLICY_TOTAL_APP_CLOCKS = 80

const NVML_FI_DEV_PERF_POLICY_TOTAL_BASE_CLOCKS = 81

const NVML_FI_DEV_MEMORY_TEMP = 82

const NVML_FI_DEV_TOTAL_ENERGY_CONSUMPTION = 83

const NVML_FI_DEV_NVLINK_SPEED_MBPS_L0 = 84

const NVML_FI_DEV_NVLINK_SPEED_MBPS_L1 = 85

const NVML_FI_DEV_NVLINK_SPEED_MBPS_L2 = 86

const NVML_FI_DEV_NVLINK_SPEED_MBPS_L3 = 87

const NVML_FI_DEV_NVLINK_SPEED_MBPS_L4 = 88

const NVML_FI_DEV_NVLINK_SPEED_MBPS_L5 = 89

const NVML_FI_DEV_NVLINK_SPEED_MBPS_COMMON = 90

const NVML_FI_DEV_NVLINK_LINK_COUNT = 91

const NVML_FI_DEV_RETIRED_PENDING_SBE = 92

const NVML_FI_DEV_RETIRED_PENDING_DBE = 93

const NVML_FI_DEV_PCIE_REPLAY_COUNTER = 94

const NVML_FI_DEV_PCIE_REPLAY_ROLLOVER_COUNTER = 95

const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L6 = 96

const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L7 = 97

const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L8 = 98

const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L9 = 99

const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L10 = 100

const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L11 = 101

const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L6 = 102

const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L7 = 103

const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L8 = 104

const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L9 = 105

const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L10 = 106

const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L11 = 107

const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L6 = 108

const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L7 = 109

const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L8 = 110

const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L9 = 111

const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L10 = 112

const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L11 = 113

const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L6 = 114

const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L7 = 115

const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L8 = 116

const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L9 = 117

const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L10 = 118

const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L11 = 119

const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L6 = 120

const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L7 = 121

const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L8 = 122

const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L9 = 123

const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L10 = 124

const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L11 = 125

const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L6 = 126

const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L7 = 127

const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L8 = 128

const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L9 = 129

const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L10 = 130

const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L11 = 131

const NVML_FI_DEV_NVLINK_SPEED_MBPS_L6 = 132

const NVML_FI_DEV_NVLINK_SPEED_MBPS_L7 = 133

const NVML_FI_DEV_NVLINK_SPEED_MBPS_L8 = 134

const NVML_FI_DEV_NVLINK_SPEED_MBPS_L9 = 135

const NVML_FI_DEV_NVLINK_SPEED_MBPS_L10 = 136

const NVML_FI_DEV_NVLINK_SPEED_MBPS_L11 = 137

const NVML_FI_DEV_NVLINK_THROUGHPUT_DATA_TX = 138

const NVML_FI_DEV_NVLINK_THROUGHPUT_DATA_RX = 139

const NVML_FI_DEV_NVLINK_THROUGHPUT_RAW_TX = 140

const NVML_FI_DEV_NVLINK_THROUGHPUT_RAW_RX = 141

const NVML_FI_DEV_REMAPPED_COR = 142

const NVML_FI_DEV_REMAPPED_UNC = 143

const NVML_FI_DEV_REMAPPED_PENDING = 144

const NVML_FI_DEV_REMAPPED_FAILURE = 145

const NVML_FI_DEV_NVLINK_REMOTE_NVLINK_ID = 146

const NVML_FI_DEV_NVSWITCH_CONNECTED_LINK_COUNT = 147

const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L0 = 148

const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L1 = 149

const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L2 = 150

const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L3 = 151

const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L4 = 152

const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L5 = 153

const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L6 = 154

const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L7 = 155

const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L8 = 156

const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L9 = 157

const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L10 = 158

const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L11 = 159

const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_TOTAL = 160

const NVML_FI_DEV_NVLINK_ERROR_DL_REPLAY = 161

const NVML_FI_DEV_NVLINK_ERROR_DL_RECOVERY = 162

const NVML_FI_DEV_NVLINK_ERROR_DL_CRC = 163

const NVML_FI_DEV_NVLINK_GET_SPEED = 164

const NVML_FI_DEV_NVLINK_GET_STATE = 165

const NVML_FI_DEV_NVLINK_GET_VERSION = 166

const NVML_FI_DEV_NVLINK_GET_POWER_STATE = 167

const NVML_FI_DEV_NVLINK_GET_POWER_THRESHOLD = 168

const NVML_FI_DEV_PCIE_L0_TO_RECOVERY_COUNTER = 169

const NVML_FI_DEV_C2C_LINK_COUNT = 170

const NVML_FI_DEV_C2C_LINK_GET_STATUS = 171

const NVML_FI_DEV_C2C_LINK_GET_MAX_BW = 172

const NVML_FI_DEV_PCIE_COUNT_CORRECTABLE_ERRORS = 173

const NVML_FI_DEV_PCIE_COUNT_NAKS_RECEIVED = 174

const NVML_FI_DEV_PCIE_COUNT_RECEIVER_ERROR = 175

const NVML_FI_DEV_PCIE_COUNT_BAD_TLP = 176

const NVML_FI_DEV_PCIE_COUNT_NAKS_SENT = 177

const NVML_FI_DEV_PCIE_COUNT_BAD_DLLP = 178

const NVML_FI_DEV_PCIE_COUNT_NON_FATAL_ERROR = 179

const NVML_FI_DEV_PCIE_COUNT_FATAL_ERROR = 180

const NVML_FI_DEV_PCIE_COUNT_UNSUPPORTED_REQ = 181

const NVML_FI_DEV_PCIE_COUNT_LCRC_ERROR = 182

const NVML_FI_DEV_PCIE_COUNT_LANE_ERROR = 183

const NVML_FI_DEV_IS_RESETLESS_MIG_SUPPORTED = 184

const NVML_FI_DEV_POWER_AVERAGE = 185

const NVML_FI_DEV_POWER_INSTANT = 186

const NVML_FI_DEV_POWER_MIN_LIMIT = 187

const NVML_FI_DEV_POWER_MAX_LIMIT = 188

const NVML_FI_DEV_POWER_DEFAULT_LIMIT = 189

const NVML_FI_DEV_POWER_CURRENT_LIMIT = 190

const NVML_FI_DEV_ENERGY = 191

const NVML_FI_DEV_POWER_REQUESTED_LIMIT = 192

const NVML_FI_DEV_TEMPERATURE_SHUTDOWN_TLIMIT = 193

const NVML_FI_DEV_TEMPERATURE_SLOWDOWN_TLIMIT = 194

const NVML_FI_DEV_TEMPERATURE_MEM_MAX_TLIMIT = 195

const NVML_FI_DEV_TEMPERATURE_GPU_MAX_TLIMIT = 196

const NVML_FI_DEV_PCIE_COUNT_TX_BYTES = 197

const NVML_FI_DEV_PCIE_COUNT_RX_BYTES = 198

const NVML_FI_DEV_IS_MIG_MODE_INDEPENDENT_MIG_QUERY_CAPABLE = 199

const NVML_FI_DEV_NVLINK_GET_POWER_THRESHOLD_MAX = 200

const NVML_FI_DEV_NVLINK_COUNT_XMIT_PACKETS = 201

const NVML_FI_DEV_NVLINK_COUNT_XMIT_BYTES = 202

const NVML_FI_DEV_NVLINK_COUNT_RCV_PACKETS = 203

const NVML_FI_DEV_NVLINK_COUNT_RCV_BYTES = 204

const NVML_FI_DEV_NVLINK_COUNT_VL15_DROPPED = 205

const NVML_FI_DEV_NVLINK_COUNT_MALFORMED_PACKET_ERRORS = 206

const NVML_FI_DEV_NVLINK_COUNT_BUFFER_OVERRUN_ERRORS = 207

const NVML_FI_DEV_NVLINK_COUNT_RCV_ERRORS = 208

const NVML_FI_DEV_NVLINK_COUNT_RCV_REMOTE_ERRORS = 209

const NVML_FI_DEV_NVLINK_COUNT_RCV_GENERAL_ERRORS = 210

const NVML_FI_DEV_NVLINK_COUNT_LOCAL_LINK_INTEGRITY_ERRORS = 211

const NVML_FI_DEV_NVLINK_COUNT_XMIT_DISCARDS = 212

const NVML_FI_DEV_NVLINK_COUNT_LINK_RECOVERY_SUCCESSFUL_EVENTS = 213

const NVML_FI_DEV_NVLINK_COUNT_LINK_RECOVERY_FAILED_EVENTS = 214

const NVML_FI_DEV_NVLINK_COUNT_LINK_RECOVERY_EVENTS = 215

const NVML_FI_DEV_NVLINK_COUNT_RAW_BER_LANE0 = 216

const NVML_FI_DEV_NVLINK_COUNT_RAW_BER_LANE1 = 217

const NVML_FI_DEV_NVLINK_COUNT_RAW_BER = 218

const NVML_FI_DEV_NVLINK_COUNT_EFFECTIVE_ERRORS = 219

const NVML_FI_DEV_NVLINK_COUNT_EFFECTIVE_BER = 220

const NVML_FI_DEV_NVLINK_COUNT_SYMBOL_ERRORS = 221

const NVML_FI_DEV_NVLINK_COUNT_SYMBOL_BER = 222

const NVML_FI_DEV_NVLINK_GET_POWER_THRESHOLD_MIN = 223

const NVML_FI_DEV_NVLINK_GET_POWER_THRESHOLD_UNITS = 224

const NVML_FI_DEV_NVLINK_GET_POWER_THRESHOLD_SUPPORTED = 225

const NVML_FI_DEV_RESET_STATUS = 226

const NVML_FI_DEV_DRAIN_AND_RESET_STATUS = 227

const NVML_FI_DEV_PCIE_OUTBOUND_ATOMICS_MASK = 228

const NVML_FI_DEV_PCIE_INBOUND_ATOMICS_MASK = 229

const NVML_FI_DEV_GET_GPU_RECOVERY_ACTION = 230

const NVML_FI_DEV_C2C_LINK_ERROR_INTR = 231

const NVML_FI_DEV_C2C_LINK_ERROR_REPLAY = 232

const NVML_FI_DEV_C2C_LINK_ERROR_REPLAY_B2B = 233

const NVML_FI_DEV_C2C_LINK_POWER_STATE = 234

const NVML_FI_DEV_NVLINK_COUNT_FEC_HISTORY_0 = 235

const NVML_FI_DEV_NVLINK_COUNT_FEC_HISTORY_1 = 236

const NVML_FI_DEV_NVLINK_COUNT_FEC_HISTORY_2 = 237

const NVML_FI_DEV_NVLINK_COUNT_FEC_HISTORY_3 = 238

const NVML_FI_DEV_NVLINK_COUNT_FEC_HISTORY_4 = 239

const NVML_FI_DEV_NVLINK_COUNT_FEC_HISTORY_5 = 240

const NVML_FI_DEV_NVLINK_COUNT_FEC_HISTORY_6 = 241

const NVML_FI_DEV_NVLINK_COUNT_FEC_HISTORY_7 = 242

const NVML_FI_DEV_NVLINK_COUNT_FEC_HISTORY_8 = 243

const NVML_FI_DEV_NVLINK_COUNT_FEC_HISTORY_9 = 244

const NVML_FI_DEV_NVLINK_COUNT_FEC_HISTORY_10 = 245

const NVML_FI_DEV_NVLINK_COUNT_FEC_HISTORY_11 = 246

const NVML_FI_DEV_NVLINK_COUNT_FEC_HISTORY_12 = 247

const NVML_FI_DEV_NVLINK_COUNT_FEC_HISTORY_13 = 248

const NVML_FI_DEV_NVLINK_COUNT_FEC_HISTORY_14 = 249

const NVML_FI_DEV_NVLINK_COUNT_FEC_HISTORY_15 = 250

const NVML_FI_PWR_SMOOTHING_ENABLED = 251

const NVML_FI_PWR_SMOOTHING_PRIV_LVL = 252

const NVML_FI_PWR_SMOOTHING_IMM_RAMP_DOWN_ENABLED = 253

const NVML_FI_PWR_SMOOTHING_APPLIED_TMP_CEIL = 254

const NVML_FI_PWR_SMOOTHING_APPLIED_TMP_FLOOR = 255

const NVML_FI_PWR_SMOOTHING_MAX_PERCENT_TMP_FLOOR_SETTING = 256

const NVML_FI_PWR_SMOOTHING_MIN_PERCENT_TMP_FLOOR_SETTING = 257

const NVML_FI_PWR_SMOOTHING_HW_CIRCUITRY_PERCENT_LIFETIME_REMAINING = 258

const NVML_FI_PWR_SMOOTHING_MAX_NUM_PRESET_PROFILES = 259

const NVML_FI_PWR_SMOOTHING_PROFILE_PERCENT_TMP_FLOOR = 260

const NVML_FI_PWR_SMOOTHING_PROFILE_RAMP_UP_RATE = 261

const NVML_FI_PWR_SMOOTHING_PROFILE_RAMP_DOWN_RATE = 262

const NVML_FI_PWR_SMOOTHING_PROFILE_RAMP_DOWN_HYST_VAL = 263

const NVML_FI_PWR_SMOOTHING_ACTIVE_PRESET_PROFILE = 264

const NVML_FI_PWR_SMOOTHING_ADMIN_OVERRIDE_PERCENT_TMP_FLOOR = 265

const NVML_FI_PWR_SMOOTHING_ADMIN_OVERRIDE_RAMP_UP_RATE = 266

const NVML_FI_PWR_SMOOTHING_ADMIN_OVERRIDE_RAMP_DOWN_RATE = 267

const NVML_FI_PWR_SMOOTHING_ADMIN_OVERRIDE_RAMP_DOWN_HYST_VAL = 268

const NVML_FI_DEV_CLOCKS_EVENT_REASON_SW_POWER_CAP = NVML_FI_DEV_PERF_POLICY_POWER

const NVML_FI_DEV_CLOCKS_EVENT_REASON_SYNC_BOOST = NVML_FI_DEV_PERF_POLICY_SYNC_BOOST

const NVML_FI_DEV_CLOCKS_EVENT_REASON_SW_THERM_SLOWDOWN = 269

const NVML_FI_DEV_CLOCKS_EVENT_REASON_HW_THERM_SLOWDOWN = 270

const NVML_FI_DEV_CLOCKS_EVENT_REASON_HW_POWER_BRAKE_SLOWDOWN = 271

const NVML_FI_DEV_POWER_SYNC_BALANCING_FREQ = 272

const NVML_FI_DEV_POWER_SYNC_BALANCING_AF = 273

const NVML_FI_MAX = 274

const NVML_NVLINK_LOW_POWER_THRESHOLD_UNIT_100US = 0x00

const NVML_NVLINK_LOW_POWER_THRESHOLD_UNIT_50US = 0x01

const NVML_NVLINK_POWER_STATE_HIGH_SPEED = 0x00

const NVML_NVLINK_POWER_STATE_LOW = 0x01

const NVML_NVLINK_LOW_POWER_THRESHOLD_MIN = 0x01

const NVML_NVLINK_LOW_POWER_THRESHOLD_MAX = 0x1fff

const NVML_NVLINK_LOW_POWER_THRESHOLD_RESET = 0xffffffff

const NVML_NVLINK_LOW_POWER_THRESHOLD_DEFAULT = NVML_NVLINK_LOW_POWER_THRESHOLD_RESET

const NVML_C2C_POWER_STATE_FULL_POWER = 0

const NVML_C2C_POWER_STATE_LOW_POWER = 1

const nvmlEventTypeNone = Clonglong(0x0000000000000000)

const nvmlEventTypeSingleBitEccError = Clonglong(0x0000000000000001)

const nvmlEventTypeDoubleBitEccError = Clonglong(0x0000000000000002)

const nvmlEventTypePState = Clonglong(0x0000000000000004)

const nvmlEventTypeXidCriticalError = Clonglong(0x0000000000000008)

const nvmlEventTypeClock = Clonglong(0x0000000000000010)

const nvmlEventTypePowerSourceChange = Clonglong(0x0000000000000080)

const nvmlEventMigConfigChange = Clonglong(0x0000000000000100)

const nvmlEventTypeSingleBitEccErrorStorm = Clonglong(0x0000000000000200)

const nvmlEventTypeDramRetirementEvent = Clonglong(0x0000000000000400)

const nvmlEventTypeDramRetirementFailure = Clonglong(0x0000000000000800)

const nvmlEventTypeNonFatalPoisonError = Clonglong(0x0000000000001000)

const nvmlEventTypeFatalPoisonError = Clonglong(0x0000000000002000)

const nvmlEventTypeGpuUnavailableError = Clonglong(0x0000000000004000)

const nvmlEventTypeGpuRecoveryAction = Clonglong(0x0000000000008000)

const nvmlEventTypeAll = (((((((((((((nvmlEventTypeNone | nvmlEventTypeSingleBitEccError) |
                                     nvmlEventTypeDoubleBitEccError) | nvmlEventTypePState) |
                                   nvmlEventTypeClock) | nvmlEventTypeXidCriticalError) |
                                 nvmlEventTypePowerSourceChange) | nvmlEventMigConfigChange) |
                               nvmlEventTypeSingleBitEccErrorStorm) |
                              nvmlEventTypeDramRetirementEvent) |
                             nvmlEventTypeDramRetirementFailure) |
                            nvmlEventTypeNonFatalPoisonError) |
                           nvmlEventTypeFatalPoisonError) |
                          nvmlEventTypeGpuUnavailableError) | nvmlEventTypeGpuRecoveryAction

const nvmlSystemEventTypeGpuDriverUnbind = Clonglong(0x0000000000000001)

const nvmlSystemEventTypeGpuDriverBind = Clonglong(0x0000000000000002)

const nvmlSystemEventTypeCount = 2

const nvmlSystemEventSetCreateRequest_v1 = @NVML_STRUCT_VERSION(SystemEventSetCreateRequest,
                                                                1)

const nvmlSystemEventSetFreeRequest_v1 = @NVML_STRUCT_VERSION(SystemEventSetFreeRequest, 1)

const nvmlSystemRegisterEventRequest_v1 = @NVML_STRUCT_VERSION(SystemRegisterEventRequest,
                                                               1)

const nvmlSystemEventSetWaitRequest_v1 = @NVML_STRUCT_VERSION(SystemEventSetWaitRequest, 1)

const nvmlClocksEventReasonGpuIdle = Clonglong(0x0000000000000001)

const nvmlClocksEventReasonApplicationsClocksSetting = Clonglong(0x0000000000000002)

const nvmlClocksEventReasonSwPowerCap = Clonglong(0x0000000000000004)

const nvmlClocksThrottleReasonHwSlowdown = Clonglong(0x0000000000000008)

const nvmlClocksEventReasonSyncBoost = Clonglong(0x0000000000000010)

const nvmlClocksEventReasonSwThermalSlowdown = Clonglong(0x0000000000000020)

const nvmlClocksThrottleReasonHwThermalSlowdown = Clonglong(0x0000000000000040)

const nvmlClocksThrottleReasonHwPowerBrakeSlowdown = Clonglong(0x0000000000000080)

const nvmlClocksEventReasonDisplayClockSetting = Clonglong(0x0000000000000100)

const nvmlClocksEventReasonNone = Clonglong(0x0000000000000000)

# Skipping MacroDefinition: nvmlClocksEventReasonAll ( nvmlClocksThrottleReasonNone | nvmlClocksEventReasonGpuIdle | nvmlClocksEventReasonApplicationsClocksSetting | nvmlClocksEventReasonSwPowerCap | nvmlClocksThrottleReasonHwSlowdown | nvmlClocksEventReasonSyncBoost | nvmlClocksEventReasonSwThermalSlowdown | nvmlClocksThrottleReasonHwThermalSlowdown | nvmlClocksThrottleReasonHwPowerBrakeSlowdown | nvmlClocksEventReasonDisplayClockSetting \
#)

const NVML_NVFBC_SESSION_FLAG_DIFFMAP_ENABLED = 0x00000001

const NVML_NVFBC_SESSION_FLAG_CLASSIFICATIONMAP_ENABLED = 0x00000002

const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_NO_WAIT = 0x00000004

const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_INFINITE = 0x00000008

const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_TIMEOUT = 0x00000010

const NVML_CC_SYSTEM_CPU_CAPS_NONE = 0

const NVML_CC_SYSTEM_CPU_CAPS_AMD_SEV = 1

const NVML_CC_SYSTEM_CPU_CAPS_INTEL_TDX = 2

const NVML_CC_SYSTEM_CPU_CAPS_AMD_SEV_SNP = 3

const NVML_CC_SYSTEM_CPU_CAPS_AMD_SNP_VTOM = 4

const NVML_CC_SYSTEM_GPUS_CC_NOT_CAPABLE = 0

const NVML_CC_SYSTEM_GPUS_CC_CAPABLE = 1

const NVML_CC_SYSTEM_DEVTOOLS_MODE_OFF = 0

const NVML_CC_SYSTEM_DEVTOOLS_MODE_ON = 1

const NVML_CC_SYSTEM_ENVIRONMENT_UNAVAILABLE = 0

const NVML_CC_SYSTEM_ENVIRONMENT_SIM = 1

const NVML_CC_SYSTEM_ENVIRONMENT_PROD = 2

const NVML_CC_SYSTEM_FEATURE_DISABLED = 0

const NVML_CC_SYSTEM_FEATURE_ENABLED = 1

const NVML_CC_SYSTEM_MULTIGPU_NONE = 0

const NVML_CC_SYSTEM_MULTIGPU_PROTECTED_PCIE = 1

const NVML_CC_SYSTEM_MULTIGPU_NVLE = 2

const nvmlSystemConfComputeSettings_v1 = @NVML_STRUCT_VERSION(SystemConfComputeSettings, 1)

const NVML_CC_ACCEPTING_CLIENT_REQUESTS_FALSE = 0

const NVML_CC_ACCEPTING_CLIENT_REQUESTS_TRUE = 1

const NVML_GPU_CERT_CHAIN_SIZE = 0x1000

const NVML_GPU_ATTESTATION_CERT_CHAIN_SIZE = 0x1400

const NVML_CC_GPU_CEC_NONCE_SIZE = 0x20

const NVML_CC_GPU_ATTESTATION_REPORT_SIZE = 0x2000

const NVML_CC_GPU_CEC_ATTESTATION_REPORT_SIZE = 0x1000

const NVML_CC_CEC_ATTESTATION_REPORT_NOT_PRESENT = 0

const NVML_CC_CEC_ATTESTATION_REPORT_PRESENT = 1

const NVML_CC_KEY_ROTATION_THRESHOLD_ATTACKER_ADVANTAGE_MIN = 50

const NVML_CC_KEY_ROTATION_THRESHOLD_ATTACKER_ADVANTAGE_MAX = 65

const nvmlConfComputeSetKeyRotationThresholdInfo_v1 = @NVML_STRUCT_VERSION(ConfComputeSetKeyRotationThresholdInfo,
                                                                           1)

const nvmlConfComputeGetKeyRotationThresholdInfo_v1 = @NVML_STRUCT_VERSION(ConfComputeGetKeyRotationThresholdInfo,
                                                                           1)

const NVML_GPU_FABRIC_UUID_LEN = 16

const NVML_GPU_FABRIC_STATE_NOT_SUPPORTED = 0

const NVML_GPU_FABRIC_STATE_NOT_STARTED = 1

const NVML_GPU_FABRIC_STATE_IN_PROGRESS = 2

const NVML_GPU_FABRIC_STATE_COMPLETED = 3

const NVML_GPU_FABRIC_HEALTH_MASK_DEGRADED_BW_NOT_SUPPORTED = 0

const NVML_GPU_FABRIC_HEALTH_MASK_DEGRADED_BW_TRUE = 1

const NVML_GPU_FABRIC_HEALTH_MASK_DEGRADED_BW_FALSE = 2

const NVML_GPU_FABRIC_HEALTH_MASK_SHIFT_DEGRADED_BW = 0

const NVML_GPU_FABRIC_HEALTH_MASK_WIDTH_DEGRADED_BW = 0x03

const NVML_GPU_FABRIC_HEALTH_MASK_ROUTE_RECOVERY_NOT_SUPPORTED = 0

const NVML_GPU_FABRIC_HEALTH_MASK_ROUTE_RECOVERY_TRUE = 1

const NVML_GPU_FABRIC_HEALTH_MASK_ROUTE_RECOVERY_FALSE = 2

const NVML_GPU_FABRIC_HEALTH_MASK_SHIFT_ROUTE_RECOVERY = 2

const NVML_GPU_FABRIC_HEALTH_MASK_WIDTH_ROUTE_RECOVERY = 0x03

const NVML_GPU_FABRIC_HEALTH_MASK_ROUTE_UNHEALTHY_NOT_SUPPORTED = 0

const NVML_GPU_FABRIC_HEALTH_MASK_ROUTE_UNHEALTHY_TRUE = 1

const NVML_GPU_FABRIC_HEALTH_MASK_ROUTE_UNHEALTHY_FALSE = 2

const NVML_GPU_FABRIC_HEALTH_MASK_SHIFT_ROUTE_UNHEALTHY = 4

const NVML_GPU_FABRIC_HEALTH_MASK_WIDTH_ROUTE_UNHEALTHY = 0x03

const NVML_GPU_FABRIC_HEALTH_MASK_ACCESS_TIMEOUT_RECOVERY_NOT_SUPPORTED = 0

const NVML_GPU_FABRIC_HEALTH_MASK_ACCESS_TIMEOUT_RECOVERY_TRUE = 1

const NVML_GPU_FABRIC_HEALTH_MASK_ACCESS_TIMEOUT_RECOVERY_FALSE = 2

const NVML_GPU_FABRIC_HEALTH_MASK_SHIFT_ACCESS_TIMEOUT_RECOVERY = 6

const NVML_GPU_FABRIC_HEALTH_MASK_WIDTH_ACCESS_TIMEOUT_RECOVERY = 0x03

const NVML_GPU_FABRIC_HEALTH_MASK_INCORRECT_CONFIGURATION_NOT_SUPPORTED = 0

const NVML_GPU_FABRIC_HEALTH_MASK_INCORRECT_CONFIGURATION_NONE = 1

const NVML_GPU_FABRIC_HEALTH_MASK_INCORRECT_CONFIGURATION_INCORRECT_SYSGUID = 2

const NVML_GPU_FABRIC_HEALTH_MASK_INCORRECT_CONFIGURATION_INCORRECT_CHASSIS_SN = 3

const NVML_GPU_FABRIC_HEALTH_MASK_INCORRECT_CONFIGURATION_NO_PARTITION = 4

const NVML_GPU_FABRIC_HEALTH_MASK_INCORRECT_CONFIGURATION_INSUFFICIENT_NVLINKS = 5

const NVML_GPU_FABRIC_HEALTH_MASK_INCORRECT_CONFIGURATION_INCOMPATIBLE_GPU_FW = 6

const NVML_GPU_FABRIC_HEALTH_MASK_INCORRECT_CONFIGURATION_INVALID_LOCATION = 7

const NVML_GPU_FABRIC_HEALTH_MASK_SHIFT_INCORRECT_CONFIGURATION = 8

const NVML_GPU_FABRIC_HEALTH_MASK_WIDTH_INCORRECT_CONFIGURATION = 0x0f

const NVML_GPU_FABRIC_HEALTH_SUMMARY_NOT_SUPPORTED = 0

const NVML_GPU_FABRIC_HEALTH_SUMMARY_HEALTHY = 1

const NVML_GPU_FABRIC_HEALTH_SUMMARY_UNHEALTHY = 2

const NVML_GPU_FABRIC_HEALTH_SUMMARY_LIMITED_CAPACITY = 3

const nvmlGpuFabricInfo_v2 = @NVML_STRUCT_VERSION(GpuFabricInfo, 2)

const nvmlGpuFabricInfo_v3 = @NVML_STRUCT_VERSION(GpuFabricInfo, 3)

const NVML_INIT_FLAG_NO_GPUS = 1

const NVML_INIT_FLAG_NO_ATTACH = 2

const NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE = 16

const NVML_DEVICE_UUID_BUFFER_SIZE = 80

const NVML_DEVICE_UUID_V2_BUFFER_SIZE = 96

const NVML_DEVICE_PART_NUMBER_BUFFER_SIZE = 80

const NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE = 80

const NVML_SYSTEM_NVML_VERSION_BUFFER_SIZE = 80

const NVML_DEVICE_NAME_BUFFER_SIZE = 64

const NVML_DEVICE_NAME_V2_BUFFER_SIZE = 96

const NVML_DEVICE_SERIAL_BUFFER_SIZE = 30

const NVML_DEVICE_VBIOS_VERSION_BUFFER_SIZE = 32

const nvmlSystemDriverBranchInfo_v1 = @NVML_STRUCT_VERSION(SystemDriverBranchInfo, 1)

const NVML_AFFINITY_SCOPE_NODE = 0

const NVML_AFFINITY_SCOPE_SOCKET = 1

const nvmlTemperature_v1 = @NVML_STRUCT_VERSION(Temperature, 1)

const NVML_NVLINK_BER_MANTISSA_SHIFT = 8

const NVML_NVLINK_BER_MANTISSA_WIDTH = 0x0f

const NVML_NVLINK_BER_EXP_SHIFT = 0

const NVML_NVLINK_BER_EXP_WIDTH = 0xff

const NVML_NVLINK_STATE_INACTIVE = 0x00

const NVML_NVLINK_STATE_ACTIVE = 0x01

const NVML_NVLINK_STATE_SLEEP = 0x02

const NVML_NVLINK_TOTAL_SUPPORTED_BW_MODES = 23

const nvmlNvlinkSupportedBwModes_v1 = @NVML_STRUCT_VERSION(NvlinkSupportedBwModes, 1)

const nvmlNvlinkGetBwMode_v1 = @NVML_STRUCT_VERSION(NvlinkGetBwMode, 1)

const nvmlNvlinkSetBwMode_v1 = @NVML_STRUCT_VERSION(NvlinkSetBwMode, 1)

const nvmlNvLinkInfo_v1 = @NVML_STRUCT_VERSION(NvLinkInfo, 1)

const NVML_NVLINK_FIRMWARE_UCODE_TYPE_MSE = 0x01

const NVML_NVLINK_FIRMWARE_UCODE_TYPE_NETIR = 0x02

const NVML_NVLINK_FIRMWARE_UCODE_TYPE_NETIR_UPHY = 0x03

const NVML_NVLINK_FIRMWARE_UCODE_TYPE_NETIR_CLN = 0x04

const NVML_NVLINK_FIRMWARE_UCODE_TYPE_NETIR_DLN = 0x05

const NVML_NVLINK_FIRMWARE_VERSION_LENGTH = 100

const nvmlNvLinkInfo_v2 = @NVML_STRUCT_VERSION(NvLinkInfo, 2)

const NVML_PRM_DATA_MAX_SIZE = 496

const NVML_DEVICE_MIG_DISABLE = 0x00

const NVML_DEVICE_MIG_ENABLE = 0x01

const NVML_GPU_INSTANCE_PROFILE_1_SLICE = 0x00

const NVML_GPU_INSTANCE_PROFILE_2_SLICE = 0x01

const NVML_GPU_INSTANCE_PROFILE_3_SLICE = 0x02

const NVML_GPU_INSTANCE_PROFILE_4_SLICE = 0x03

const NVML_GPU_INSTANCE_PROFILE_7_SLICE = 0x04

const NVML_GPU_INSTANCE_PROFILE_8_SLICE = 0x05

const NVML_GPU_INSTANCE_PROFILE_6_SLICE = 0x06

const NVML_GPU_INSTANCE_PROFILE_1_SLICE_REV1 = 0x07

const NVML_GPU_INSTANCE_PROFILE_2_SLICE_REV1 = 0x08

const NVML_GPU_INSTANCE_PROFILE_1_SLICE_REV2 = 0x09

const NVML_GPU_INSTANCE_PROFILE_1_SLICE_GFX = 0x0a

const NVML_GPU_INSTANCE_PROFILE_2_SLICE_GFX = 0x0b

const NVML_GPU_INSTANCE_PROFILE_4_SLICE_GFX = 0x0c

const NVML_GPU_INSTANCE_PROFILE_1_SLICE_NO_ME = 0x0d

const NVML_GPU_INSTANCE_PROFILE_2_SLICE_NO_ME = 0x0e

const NVML_GPU_INSTANCE_PROFILE_1_SLICE_ALL_ME = 0x0f

const NVML_GPU_INSTANCE_PROFILE_2_SLICE_ALL_ME = 0x10

const NVML_GPU_INSTANCE_PROFILE_COUNT = 0x11

const NVML_GPU_INSTANCE_PROFILE_CAPS_P2P = 0x01

const NVML_GPU_INTSTANCE_PROFILE_CAPS_P2P = 0x01

const NVML_GPU_INSTANCE_PROFILE_CAPS_GFX = 0x02

const NVML_COMPUTE_INSTANCE_PROFILE_CAPS_GFX = 0x01

const nvmlGpuInstanceProfileInfo_v2 = @NVML_STRUCT_VERSION(GpuInstanceProfileInfo, 2)

const nvmlGpuInstanceProfileInfo_v3 = @NVML_STRUCT_VERSION(GpuInstanceProfileInfo, 3)

const NVML_COMPUTE_INSTANCE_PROFILE_1_SLICE = 0x00

const NVML_COMPUTE_INSTANCE_PROFILE_2_SLICE = 0x01

const NVML_COMPUTE_INSTANCE_PROFILE_3_SLICE = 0x02

const NVML_COMPUTE_INSTANCE_PROFILE_4_SLICE = 0x03

const NVML_COMPUTE_INSTANCE_PROFILE_7_SLICE = 0x04

const NVML_COMPUTE_INSTANCE_PROFILE_8_SLICE = 0x05

const NVML_COMPUTE_INSTANCE_PROFILE_6_SLICE = 0x06

const NVML_COMPUTE_INSTANCE_PROFILE_1_SLICE_REV1 = 0x07

const NVML_COMPUTE_INSTANCE_PROFILE_COUNT = 0x08

const NVML_COMPUTE_INSTANCE_ENGINE_PROFILE_SHARED = 0x00

const NVML_COMPUTE_INSTANCE_ENGINE_PROFILE_COUNT = 0x01

const nvmlComputeInstanceProfileInfo_v2 = @NVML_STRUCT_VERSION(ComputeInstanceProfileInfo,
                                                               2)

const nvmlComputeInstanceProfileInfo_v3 = @NVML_STRUCT_VERSION(ComputeInstanceProfileInfo,
                                                               3)

const NVML_GPM_METRICS_GET_VERSION = 1

const NVML_GPM_SUPPORT_VERSION = 1

const NVML_DEV_CAP_EGM = 1 << 0

const nvmlDeviceCapabilities_v1 = @NVML_STRUCT_VERSION(DeviceCapabilities, 1)

const NVML_255_MASK_BITS_PER_ELEM = 32

const NVML_255_MASK_NUM_ELEMS = 8

const NVML_WORKLOAD_POWER_MAX_PROFILES = 255

const nvmlWorkloadPowerProfileInfo_v1 = @NVML_STRUCT_VERSION(WorkloadPowerProfileInfo, 1)

const nvmlWorkloadPowerProfileProfilesInfo_v1 = @NVML_STRUCT_VERSION(WorkloadPowerProfileProfilesInfo,
                                                                     1)

const nvmlWorkloadPowerProfileCurrentProfiles_v1 = @NVML_STRUCT_VERSION(WorkloadPowerProfileCurrentProfiles,
                                                                        1)

const nvmlWorkloadPowerProfileRequestedProfiles_v1 = @NVML_STRUCT_VERSION(WorkloadPowerProfileRequestedProfiles,
                                                                          1)

const NVML_POWER_SMOOTHING_MAX_NUM_PROFILES = 5

const NVML_POWER_SMOOTHING_NUM_PROFILE_PARAMS = 4

const NVML_POWER_SMOOTHING_ADMIN_OVERRIDE_NOT_SET = Cuint(0xffffffff)

const NVML_POWER_SMOOTHING_PROFILE_PARAM_PERCENT_TMP_FLOOR = 0

const NVML_POWER_SMOOTHING_PROFILE_PARAM_RAMP_UP_RATE = 1

const NVML_POWER_SMOOTHING_PROFILE_PARAM_RAMP_DOWN_RATE = 2

const NVML_POWER_SMOOTHING_PROFILE_PARAM_RAMP_DOWN_HYSTERESIS = 3

const nvmlPowerSmoothingProfile_v1 = @NVML_STRUCT_VERSION(PowerSmoothingProfile, 1)

const nvmlPowerSmoothingState_v1 = @NVML_STRUCT_VERSION(PowerSmoothingState, 1)
