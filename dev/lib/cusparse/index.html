<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CUSPARSE · CUDA.jl</title><meta name="title" content="CUSPARSE · CUDA.jl"/><meta property="og:title" content="CUSPARSE · CUDA.jl"/><meta property="twitter:title" content="CUSPARSE · CUDA.jl"/><meta name="description" content="Documentation for CUDA.jl."/><meta property="og:description" content="Documentation for CUDA.jl."/><meta property="twitter:description" content="Documentation for CUDA.jl."/><meta property="og:url" content="https://cuda.juliagpu.org/stable/lib/cusparse/"/><meta property="twitter:url" content="https://cuda.juliagpu.org/stable/lib/cusparse/"/><link rel="canonical" href="https://cuda.juliagpu.org/stable/lib/cusparse/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-154489943-2"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-154489943-2', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="CUDA.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CUDA.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/custom_structs/">Using custom structs</a></li><li><a class="tocitem" href="../../tutorials/performance/">Performance Tips</a></li></ul></li><li><span class="tocitem">Installation</span><ul><li><a class="tocitem" href="../../installation/overview/">Overview</a></li><li><a class="tocitem" href="../../installation/conditional/">Conditional use</a></li><li><a class="tocitem" href="../../installation/troubleshooting/">Troubleshooting</a></li></ul></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../../usage/overview/">Overview</a></li><li><a class="tocitem" href="../../usage/workflow/">Workflow</a></li><li><a class="tocitem" href="../../usage/array/">Array programming</a></li><li><a class="tocitem" href="../../usage/memory/">Memory management</a></li><li><a class="tocitem" href="../../usage/multitasking/">Tasks and threads</a></li><li><a class="tocitem" href="../../usage/multigpu/">Multiple GPUs</a></li></ul></li><li><span class="tocitem">Development</span><ul><li><a class="tocitem" href="../../development/profiling/">Benchmarking &amp; profiling</a></li><li><a class="tocitem" href="../../development/kernel/">Kernel programming</a></li><li><a class="tocitem" href="../../development/troubleshooting/">Troubleshooting</a></li><li><a class="tocitem" href="../../development/debugging/">Debugging</a></li></ul></li><li><span class="tocitem">API reference</span><ul><li><a class="tocitem" href="../../api/essentials/">Essentials</a></li><li><a class="tocitem" href="../../api/array/">Array programming</a></li><li><a class="tocitem" href="../../api/kernel/">Kernel programming</a></li><li><a class="tocitem" href="../../api/compiler/">Compiler</a></li></ul></li><li><span class="tocitem">Library reference</span><ul><li><a class="tocitem" href="../cublas/">CUBLAS</a></li><li><a class="tocitem" href="../cudadrv/">CUDA driver</a></li><li><a class="tocitem" href="../cudnn/">cuDNN</a></li><li><a class="tocitem" href="../cufft/">CUFFT</a></li><li><a class="tocitem" href="../cupti/">CUPTI</a></li><li><a class="tocitem" href="../curand/">CURAND</a></li><li><a class="tocitem" href="../cusolver/">CUSOLVER</a></li><li class="is-active"><a class="tocitem" href>CUSPARSE</a><ul class="internal"><li><a class="tocitem" href="#Public"><span>Public</span></a></li><li><a class="tocitem" href="#Private"><span>Private</span></a></li></ul></li><li><a class="tocitem" href="../custatevec/">cuStateVec</a></li><li><a class="tocitem" href="../cutensor/">cuTENSOR</a></li><li><a class="tocitem" href="../cutensornet/">cuTensorNet</a></li><li><a class="tocitem" href="../nvml/">NVML</a></li><li><a class="tocitem" href="../utils/">APIUtils</a></li></ul></li><li><a class="tocitem" href="../../faq/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library reference</a></li><li class="is-active"><a href>CUSPARSE</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CUSPARSE</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGPU/CUDA.jl/blob/master/docs/src/lib/cusparse.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="CUSPARSE"><a class="docs-heading-anchor" href="#CUSPARSE">CUSPARSE</a><a id="CUSPARSE-1"></a><a class="docs-heading-anchor-permalink" href="#CUSPARSE" title="Permalink"></a></h1><h2 id="Public"><a class="docs-heading-anchor" href="#Public">Public</a><a id="Public-1"></a><a class="docs-heading-anchor-permalink" href="#Public" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.CuSparseMatrix" href="#CUDA.CUSPARSE.CuSparseMatrix"><code>CUDA.CUSPARSE.CuSparseMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Utility union type of <a href="#CUDA.CUSPARSE.CuSparseMatrixCSC"><code>CuSparseMatrixCSC</code></a>, <a href="#CUDA.CUSPARSE.CuSparseMatrixCSR"><code>CuSparseMatrixCSR</code></a>, <a href="#CUDA.CUSPARSE.CuSparseMatrixBSR"><code>CuSparseMatrixBSR</code></a>, <a href="#CUDA.CUSPARSE.CuSparseMatrixCOO"><code>CuSparseMatrixCOO</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/array.jl#L209-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.CuSparseMatrixBSR" href="#CUDA.CUSPARSE.CuSparseMatrixBSR"><code>CUDA.CUSPARSE.CuSparseMatrixBSR</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CuSparseMatrixBSR</code></pre><p>Container to hold sparse matrices in block compressed sparse row (BSR) format on the GPU. BSR format is also used in Intel MKL, and is suited to matrices that are &quot;block&quot; sparse - rare blocks of non-sparse regions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/array.jl#L128-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.CuSparseMatrixCOO" href="#CUDA.CUSPARSE.CuSparseMatrixCOO"><code>CUDA.CUSPARSE.CuSparseMatrixCOO</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CuSparseMatrixCOO</code></pre><p>Container to hold sparse matrices in coordinate (COO) format on the GPU. COO format is mainly useful to initially construct sparse matrices, afterwards switch to <a href="#CUDA.CUSPARSE.CuSparseMatrixCSR"><code>CuSparseMatrixCSR</code></a> for more functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/array.jl#L160-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.CuSparseMatrixCSC" href="#CUDA.CUSPARSE.CuSparseMatrixCSC"><code>CUDA.CUSPARSE.CuSparseMatrixCSC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CuSparseMatrixCSC</code></pre><p>Container to hold sparse matrices in compressed sparse column (CSC) format on the GPU.</p><div class="admonition is-info" id="Note-dbb56a5f782d450e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-dbb56a5f782d450e" title="Permalink"></a></header><div class="admonition-body"><p>Most CUSPARSE operations work with CSR formatted matrices, rather than CSC.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/array.jl#L34-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.CuSparseMatrixCSR" href="#CUDA.CUSPARSE.CuSparseMatrixCSR"><code>CUDA.CUSPARSE.CuSparseMatrixCSR</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CuSparseMatrixCSR{Tv, Ti} &lt;: AbstractCuSparseMatrix{Tv, Ti}</code></pre><p>Container to hold sparse matrices in compressed sparse row (CSR) format on the GPU.</p><div class="admonition is-info" id="Note-dbb56a5f782d450e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-dbb56a5f782d450e" title="Permalink"></a></header><div class="admonition-body"><p>Most CUSPARSE operations work with CSR formatted matrices, rather than CSC.</p></div></div><div class="admonition is-compat" id="CUDA-11-8d9a8e1b581bafad"><header class="admonition-header">CUDA 11<a class="admonition-anchor" href="#CUDA-11-8d9a8e1b581bafad" title="Permalink"></a></header><div class="admonition-body"><p>Support of indices type rather than <code>Cint</code> (<code>Int32</code>) requires at least CUDA 11.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/array.jl#L72-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.axpby!-Union{Tuple{T}, Tuple{Number, CuSparseVector{T}, Number, CuArray{T, 1}, Char}} where T" href="#CUDA.CUSPARSE.axpby!-Union{Tuple{T}, Tuple{Number, CuSparseVector{T}, Number, CuArray{T, 1}, Char}} where T"><code>CUDA.CUSPARSE.axpby!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">axpby!(alpha::Number, X::CuSparseVector, beta::Number, Y::CuVector, index::SparseChar)</code></pre><p>Computes <code>alpha * X + beta * Y</code> for sparse <code>X</code> and dense <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/generic.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.axpby-Tuple{Number, CuSparseVector, Number, CuSparseVector, Char}" href="#CUDA.CUSPARSE.axpby-Tuple{Number, CuSparseVector, Number, CuSparseVector, Char}"><code>CUDA.CUSPARSE.axpby</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">axpby(alpha::Number, x::CuSparseVector, beta::Number, y::CuSparseVector, index::SparseChar)</code></pre><p>Performs <code>z = alpha * x + beta * y</code>. <code>x</code> and <code>y</code> are sparse vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/extra.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.color" href="#CUDA.CUSPARSE.color"><code>CUDA.CUSPARSE.color</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">color(A::CuSparseMatrixCSC, index::SparseChar; percentage::Number=1.0)
color(A::CuSparseMatrixCSR, index::SparseChar; percentage::Number=1.0)</code></pre><p>This function performs the coloring of the adjacency graph associated with the matrix A. The coloring is an assignment of colors (integer numbers) to nodes, such that neighboring nodes have distinct colors. An approximate coloring algorithm is used in this routine, and is stopped when a certain percentage of nodes has been colored. The rest of the nodes are assigned distinct colors (an increasing sequence of integers numbers, starting from the last integer used previously). The reordering is such that nodes that have been assigned the same color are reordered to be next to each other.</p><p>The matrix A passed to this routine, must be stored as a general matrix and have a symmetric sparsity pattern. If the matrix is non-symmetric the user should pass A + Aᵀ as a parameter to this routine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/reorderings.jl#L5-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.gather!-Tuple{CuSparseVector, CuArray{T, 1} where T, Char}" href="#CUDA.CUSPARSE.gather!-Tuple{CuSparseVector, CuArray{T, 1} where T, Char}"><code>CUDA.CUSPARSE.gather!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gather!(X::CuSparseVector, Y::CuVector, index::SparseChar)</code></pre><p>Sets the nonzero elements of <code>X</code> equal to the nonzero elements of <code>Y</code> at the same indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/generic.jl#L169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.geam-Tuple{Number, CuSparseMatrixCSR, Number, CuSparseMatrixCSR, Char}" href="#CUDA.CUSPARSE.geam-Tuple{Number, CuSparseMatrixCSR, Number, CuSparseMatrixCSR, Char}"><code>CUDA.CUSPARSE.geam</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geam(alpha::Number, A::CuSparseMatrix, beta::Number, B::CuSparseMatrix, index::SparseChar)</code></pre><p>Performs <code>C = alpha * A + beta * B</code>. <code>A</code> and <code>B</code> are sparse matrices defined in CSR or CSC storage formats.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/extra.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.gemv" href="#CUDA.CUSPARSE.gemv"><code>CUDA.CUSPARSE.gemv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">y = gemv(transa, alpha, A, x, index, [algo])</code></pre><p>Perform a product between a <code>CuSparseMatrix</code> and a <code>CuSparseVector</code>, returning a <code>CuSparseVector</code>. This function should only be used for highly sparse matrices and vectors, as the result is expected to have many non-zeros in practice. For this reason, high-level functions like <code>mul!</code> and <code>*</code> internally convert the sparse vector into a dense vector to use a more efficient CUSPARSE routine.</p><p>Supported formats for the sparse matrix are <code>CuSparseMatrixCSC</code> and <code>CuSparseMatrixCSR</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/generic.jl#L704-L714">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.gtsv2!" href="#CUDA.CUSPARSE.gtsv2!"><code>CUDA.CUSPARSE.gtsv2!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gtsv2!(dl::CuVector, d::CuVector, du::CuVector, B::CuVecOrMat, index::SparseChar=&#39;O&#39;; pivoting::Bool=true)</code></pre><p>Solve the linear system <code>A * X = B</code> where <code>A</code> is a tridiagonal matrix defined by three vectors corresponding to its lower (<code>dl</code>), main (<code>d</code>), and upper (<code>du</code>) diagonals. With <code>pivoting</code>, the solution is more accurate but also more expensive. Note that the solution <code>X</code> overwrites the right-hand side <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/preconditioners.jl#L21-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.ic02!" href="#CUDA.CUSPARSE.ic02!"><code>CUDA.CUSPARSE.ic02!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ic02!(A::CuSparseMatrix, index::SparseChar=&#39;O&#39;)</code></pre><p>Incomplete Cholesky factorization with no pivoting. Preserves the sparse layout of matrix <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/preconditioners.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.ilu02!" href="#CUDA.CUSPARSE.ilu02!"><code>CUDA.CUSPARSE.ilu02!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ilu02!(A::CuSparseMatrix, index::SparseChar=&#39;O&#39;)</code></pre><p>Incomplete LU factorization with no pivoting. Preserves the sparse layout of matrix <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/preconditioners.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.mm!" href="#CUDA.CUSPARSE.mm!"><code>CUDA.CUSPARSE.mm!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mm!(transa::SparseChar, transb::SparseChar, alpha::Number, A::CuSparseMatrix, B::CuMatrix, beta::Number, C::CuMatrix, index::SparseChar)
mm!(transa::SparseChar, transb::SparseChar, alpha::Number, A::CuMatrix, B::Union{CuSparseMatrixCSC,CuSparseMatrixCSR,CuSparseMatrixCOO}, beta::Number, C::CuMatrix, index::SparseChar)</code></pre><p>Performs <code>C = alpha * op(A) * op(B) + beta * C</code>, where <code>op</code> can be nothing (<code>transa = N</code>), tranpose (<code>transa = T</code>) or conjugate transpose (<code>transa = C</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/generic.jl#L16-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.mv!" href="#CUDA.CUSPARSE.mv!"><code>CUDA.CUSPARSE.mv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mv!(transa::SparseChar, alpha::Number, A::CuSparseMatrix, X::CuVector, beta::Number, Y::CuVector, index::SparseChar)</code></pre><p>Performs <code>Y = alpha * op(A) * X + beta * Y</code>, where <code>op</code> can be nothing (<code>transa = N</code>), tranpose (<code>transa = T</code>) or conjugate transpose (<code>transa = C</code>). <code>X</code> and <code>Y</code> are dense vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/generic.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.rot!-Union{Tuple{T}, Tuple{CuSparseVector{T}, CuArray{T, 1}, Number, Number, Char}} where T" href="#CUDA.CUSPARSE.rot!-Union{Tuple{T}, Tuple{CuSparseVector{T}, CuArray{T, 1}, Number, Number, Char}} where T"><code>CUDA.CUSPARSE.rot!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rot!(X::CuSparseVector, Y::CuVector, c::Number, s::Number, index::SparseChar)</code></pre><p>Performs the Givens rotation specified by <code>c</code> and <code>s</code> to sparse <code>X</code> and dense <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/generic.jl#L205-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.scatter!-Tuple{CuArray{T, 1} where T, CuSparseVector, Char}" href="#CUDA.CUSPARSE.scatter!-Tuple{CuArray{T, 1} where T, CuSparseVector, Char}"><code>CUDA.CUSPARSE.scatter!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scatter!(Y::CuVector, X::CuSparseVector, index::SparseChar)</code></pre><p>Set <code>Y[:] = X[:]</code> for dense <code>Y</code> and sparse <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/generic.jl#L181-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.sm2!-Tuple{Char, Char, Char, Number, CuSparseMatrixBSR, CuArray{T, 2} where T, Char}" href="#CUDA.CUSPARSE.sm2!-Tuple{Char, Char, Char, Number, CuSparseMatrixBSR, CuArray{T, 2} where T, Char}"><code>CUDA.CUSPARSE.sm2!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sm2!(transa::SparseChar, transxy::SparseChar, uplo::SparseChar, diag::SparseChar, alpha::BlasFloat, A::CuSparseMatrixBSR, X::CuMatrix, index::SparseChar)</code></pre><p>Performs <code>X = alpha * op(A) \ op(X)</code>, where <code>op</code> can be nothing (<code>transa = N</code>), tranpose (<code>transa = T</code>) or conjugate transpose (<code>transa = C</code>). <code>X</code> is a dense matrix, and <code>uplo</code> tells <code>sm2!</code> which triangle of the block sparse matrix <code>A</code> to reference. If the triangle has unit diagonal, set <code>diag</code> to &#39;U&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/level3.jl#L6-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.sv2!-Tuple{Char, Char, Char, Union{Float32, Float64, ComplexF64, ComplexF32}, CuSparseMatrixBSR, CuArray{T, 1} where T, Char}" href="#CUDA.CUSPARSE.sv2!-Tuple{Char, Char, Char, Union{Float32, Float64, ComplexF64, ComplexF32}, CuSparseMatrixBSR, CuArray{T, 1} where T, Char}"><code>CUDA.CUSPARSE.sv2!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sv2!(transa::SparseChar, uplo::SparseChar, diag::SparseChar, alpha::BlasFloat, A::CuSparseMatrixBSR, X::CuVector, index::SparseChar)</code></pre><p>Performs <code>X = alpha * op(A) \ X</code>, where <code>op</code> can be nothing (<code>transa = N</code>), tranpose (<code>transa = T</code>) or conjugate transpose (<code>transa = C</code>). <code>X</code> is a dense vector, and <code>uplo</code> tells <code>sv2!</code> which triangle of the block sparse matrix <code>A</code> to reference. If the triangle has unit diagonal, set <code>diag</code> to &#39;U&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/level2.jl#L40-L47">source</a></section></article><h2 id="Private"><a class="docs-heading-anchor" href="#Private">Private</a><a id="Private-1"></a><a class="docs-heading-anchor-permalink" href="#Private" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.chkbmmdims-NTuple{6, Any}" href="#CUDA.CUSPARSE.chkbmmdims-NTuple{6, Any}"><code>CUDA.CUSPARSE.chkbmmdims</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>check that the dimensions of arrays <code>B</code> and <code>C</code> make sense for a batched matrix-matrix multiplication</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/util.jl#L25-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.chkmmdims-NTuple{6, Any}" href="#CUDA.CUSPARSE.chkmmdims-NTuple{6, Any}"><code>CUDA.CUSPARSE.chkmmdims</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>check that the dimensions of matrices <code>B</code> and <code>C</code> make sense for a multiplication</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/util.jl#L14-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CUSPARSE.chkmvdims-NTuple{4, Any}" href="#CUDA.CUSPARSE.chkmvdims-NTuple{4, Any}"><code>CUDA.CUSPARSE.chkmvdims</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>check that the dimensions of matrix <code>X</code> and vector <code>Y</code> make sense for a multiplication</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/util.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.sparse-Tuple{CuArray{T, 2} where T}" href="#SparseArrays.sparse-Tuple{CuArray{T, 2} where T}"><code>SparseArrays.sparse</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sparse(x::DenseCuMatrix; fmt=:csc)
sparse(I::CuVector, J::CuVector, V::CuVector, [m, n]; fmt=:csc)</code></pre><p>Return a sparse cuda matrix, with type determined by <code>fmt</code>. Possible formats are :csc, :csr, :bsr, and :coo.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/e2eab84e89085b5298d44634858993939479f0ac/lib/cusparse/conversions.jl#L9-L15">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../cusolver/">« CUSOLVER</a><a class="docs-footer-nextpage" href="../custatevec/">cuStateVec »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Wednesday 4 February 2026 13:51">Wednesday 4 February 2026</span>. Using Julia version 1.11.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
