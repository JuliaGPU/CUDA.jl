# discovering binary CUDA dependencies

import ..CUDA

using CompilerSupportLibraries_jll
using LazyArtifacts
import Libdl

const dependency_lock = ReentrantLock()

# lazily initialize a Ref containing a path to a library.
# the arguments to this macro is the name of the ref, an expression to populate it
# (possibly returning `nothing` if the library wasn't found), and an optional initialization
# hook to be executed after successfully discovering the library and setting the ref.
macro initialize_ref(ref, ex, hook=:())
    quote
        ref = $(esc(ref))

        # test and test-and-set
        if !isassigned(ref)
            Base.@lock dependency_lock begin
                if !isassigned(ref)
                    val = $(esc(ex))
                    if val === nothing && !(eltype(ref) <: Union{Nothing,<:Any})
                        error($"Could not find a required library")
                    end
                    ref[] = val
                    if val !== nothing
                        $(esc(hook))
                    end
                end
            end
        end

        ref[]
    end
end


#
# CUDA toolkit
#

export toolkit

abstract type AbstractToolkit end

struct ArtifactToolkit <: AbstractToolkit
    release::VersionNumber
    artifact::String
end

struct LocalToolkit <: AbstractToolkit
    release::VersionNumber  # approximate, from the CUDA runtime library
    dirs::Vector{String}
end

const __toolkit = Ref{AbstractToolkit}()

function toolkit()
    @initialize_ref __toolkit begin
        toolkit = nothing

        # load the driver library before anything else, because we may want to load a
        # forward-compatible alternative instead, and dlopening libcudart as part of
        # the discovery process below will irreversibly load the system version.
        CUDA.libcuda()

        # CI runs in a well-defined environment, so prefer a local CUDA installation there
        if getenv("CI", false) && !haskey(ENV, "JULIA_CUDA_USE_BINARYBUILDER")
            try
                toolkit = find_local_cuda()
            catch err
                isa(err, ErrorException) || rethrow()
                # no need to report here, we'll do so below
            end
        end

        if toolkit === nothing && getenv("JULIA_CUDA_USE_BINARYBUILDER", true)
            try
                toolkit = find_artifact_cuda()
            catch err
                isa(err, ErrorException) || rethrow()
                @warn "Unable to use CUDA from artifacts: $(err.msg)"
            end
        end

        # if the user didn't specifically request an artifact version, look for a local installation
        if toolkit === nothing && !haskey(ENV, "JULIA_CUDA_VERSION")
            try
                toolkit = find_local_cuda()
            catch err
                isa(err, ErrorException) || rethrow()
                @warn "Unable to use a local CUDA installation: $(err.msg)"
            end
        end

        if toolkit === nothing
            error("""No suitable CUDA installation available.
                     Please look at the warnings above for possible reasons.""")
        end

        toolkit
    end CUDA.__init_toolkit__()
    __toolkit[]::Union{ArtifactToolkit,LocalToolkit}
end

# workaround @artifact_str eagerness on unsupported platforms by passing a variable
function generic_artifact(id)
    dir = try
        @artifact_str(id)
    catch ex
        @debug "Could not load artifact '$id'" exception=(ex,catch_backtrace())
        return nothing
    end

    # sometimes artifact downloads fail (e.g. JuliaGPU/CUDA.jl#1003)
    if isempty(readdir(dir))
        error("""The artifact at $dir is empty.
                 This is probably caused by a failed download. Remove the directory and try again.""")
    end

    return dir
end
function cuda_artifact(id, cuda::VersionNumber)
    platform = Base.BinaryPlatforms.HostPlatform()
    platform.tags["cuda"] = "$(cuda.major).$(cuda.minor)"

    dir = try
        @artifact_str(id, platform)
    catch ex
        @debug "Could not load artifact '$id' for CUDA $(cuda)" exception=(ex,catch_backtrace())
        return nothing
    end

    # sometimes artifact downloads fail (e.g. JuliaGPU/CUDA.jl#1003)
    if isempty(readdir(dir))
        error("""The artifact at $dir is empty.
                 This is probably caused by a failed download. Remove the directory and try again.""")
    end

    return dir
end

# NOTE: we don't use autogenerated JLLs, because we have multiple artifacts and need to
#       decide at run time (i.e. not via package dependencies) which one to use.
const cuda_toolkits = [
    (release=v"11.8", preferred=true),
    (release=v"11.7", preferred=true),
    (release=v"11.6", preferred=true),
    (release=v"11.5", preferred=true),
    (release=v"11.4", preferred=true),
    (release=v"11.3", preferred=true),
    (release=v"11.2", preferred=true),
    (release=v"11.1", preferred=true),
    (release=v"11.0", preferred=true),
    (release=v"10.2", preferred=true),
]

function find_artifact_cuda()
    @debug "Trying to use artifacts..."

    # select artifacts based on CUDA compatibility
    if haskey(ENV, "JULIA_CUDA_VERSION")
        wanted = VersionNumber(ENV["JULIA_CUDA_VERSION"])   # misnomer: actually the release
        @debug "Selecting artifacts based on requested $wanted"
        candidate_toolkits = filter(cuda_toolkits) do toolkit
            toolkit.release == wanted
        end
        isempty(candidate_toolkits) &&
            error("""None of the available CUDA artifacts matches the requested release $wanted.
                     Please try again without setting the JULIA_CUDA_VERSION environment variable.""")
    else
        driver_release = CUDA.release()
        @debug "Selecting artifacts based on driver compatibility $driver_release"
        candidate_toolkits = filter(cuda_toolkits) do toolkit
            toolkit.preferred &&
                (toolkit.release <= driver_release ||
                 # CUDA 11: Enhanced Compatibility (aka. semver)
                 (driver_release >= v"11" &&
                  toolkit.release.major <= driver_release.major))
        end
        isempty(candidate_toolkits) &&
            error("""None of the available CUDA artifacts is compatible with your driver (for CUDA $driver_release).
                     Please try upgrading your NVIDIA driver.""")
    end

    # download and install
    artifact = nothing
    for cuda in sort(candidate_toolkits; rev=true, by=toolkit->toolkit.release)
        dir = cuda_artifact("CUDA", cuda.release)
        if dir !== nothing
            artifact = (release=cuda.release, dir)
            break
        end
    end
    if artifact === nothing
        error("""Could not find or download a compatible artifact for your platform ($(Base.BinaryPlatforms.host_triplet())).
                 If you think this is in error, please file an issue.""")
    end

    @debug "Using CUDA $(artifact.release) from an artifact at $(artifact.dir)"
    return ArtifactToolkit(artifact.release, artifact.dir)
end

function find_local_cuda()
    @debug "Trying to use local installation..."

    dirs = find_toolkit()

    let path = find_cuda_binary(dirs, "nvdisasm")
        if path === nothing
            error("""Could not find the nvdisasm binary.
                     If CUDA is installed, please make sure this binary is in your PATH.""")
        end
        __nvdisasm[] = path
    end

    cudart_versions = cuda_library_versions("cudart")
    let path = find_cuda_library(dirs, "cudart", cudart_versions)
        if path === nothing
            error("""Could not find the cudart library.
                     If CUDA is installed, please make sure this library is discoverable.""")
        end
        __libcudart[] = path
    end
    release = CUDA.runtime_version()

    @debug "Found local CUDA $(release) at $(join(dirs, ", "))"
    return LocalToolkit(release, dirs)
end


## properties

export toolkit_origin, toolkit_release

"""
    toolkit_origin()

Returns the origin of the CUDA toolkit in use (either :artifact, or :local).
"""
toolkit_origin() = toolkit_origin(toolkit())::Symbol
toolkit_origin(::ArtifactToolkit) = :artifact
toolkit_origin(::LocalToolkit) = :local

"""
    toolkit_release()

Returns the CUDA release version of the toolkit in use.
"""
toolkit_release() = toolkit().release::VersionNumber


## binaries

export ptxas, nvlink, nvdisasm, compute_sanitizer, has_compute_sanitizer

# pxtas: used for compiling PTX to SASS
const __ptxas = Ref{String}()
function ptxas()
    @initialize_ref __ptxas begin
        find_binary(toolkit(), "ptxas")
    end
end

# nvlink: used for linking additional libraries
const __nvlink = Ref{String}()
function nvlink()
    @initialize_ref __nvlink begin
        find_binary(toolkit(), "nvlink")
    end
end

# nvdisasm: used for reflection (decompiling SASS code)
const __nvdisasm = Ref{String}()
function nvdisasm()
    @initialize_ref __nvdisasm begin
        find_binary(toolkit(), "nvdisasm")
    end
end

# compute-santizer: used by the test suite
const __compute_sanitizer = Ref{Union{Nothing,String}}()
function compute_sanitizer(; throw_error::Bool=true)
    path = @initialize_ref __compute_sanitizer begin
        if toolkit_release() < v"11.0"
            nothing
        else
            find_binary(toolkit(), "compute-sanitizer"; optional=true)
        end
    end
    if path === nothing && throw_error
        error("This functionality is unavailabe as compute_sanitizer is missing.")
    end
    path
end
has_compute_sanitizer() = compute_sanitizer(throw_error=false) !== nothing

function artifact_binary(artifact_dir, name)
    path = joinpath(artifact_dir, "bin", Sys.iswindows() ? "$name.exe" : name)
    if !ispath(path)
        error("""Could not find binary '$name' in $artifact_dir!
                 This is a bug; please file an issue with a verbose directory listing of $artifact_dir
                 If this directory is empty, delete it and try again.""")
    end
    return path
end

function find_binary(cuda::ArtifactToolkit, name; optional=false)
    # NOTE: optional is ignored, and we'll error if not found
    artifact_binary(cuda.artifact, name)
end

function find_binary(cuda::LocalToolkit, name; optional=false)
    path = find_cuda_binary(cuda.dirs, name)
    if path !== nothing
        return path
    else
        optional || error("Could not find binary '$name' in your local CUDA installation.")
        return nothing
    end
end


## libraries

# XXX: we don't correctly model the dependencies of these libraries, and hack around them
#      by loading libcublasLt before libcublas, or CUDNN's sublibraries before libcudnn.
#      this is necessary (even if the dependent libraries are in the same directory)
#      to avoid a local toolkit from messing with our artifacts (JuliaGPU/CUDA.jl#609).

export libcudart, libcublas, libcusparse, libcufft, libcurand, libcusolver,
       libcusolvermg, has_cusolvermg, libcupti, has_cupti, libnvtx, has_nvtx

const __libcudart = Ref{String}()
function libcudart()
    @initialize_ref __libcudart begin
        find_library(toolkit(), "cudart")
    end
end

const __libcublaslt = Ref{Union{String,Nothing}}()
function libcublaslt()
    @initialize_ref __libcublaslt begin
        if toolkit_release() < v"10.1"
            nothing
        else
            find_library(toolkit(), "cublasLt")
        end
    end
end

const __libcublas = Ref{String}()
function libcublas()
    @initialize_ref __libcublas begin
        libcublaslt()
        find_library(toolkit(), "cublas")
    end CUDA.CUBLAS.__runtime_init__()
end

const __libcusparse = Ref{String}()
function libcusparse()
    @initialize_ref __libcusparse begin
        find_library(toolkit(), "cusparse")
    end
end

const __libcufft = Ref{String}()
function libcufft()
    @initialize_ref __libcufft begin
        find_library(toolkit(), "cufft")
    end
end

const __libcurand = Ref{String}()
function libcurand()
    @initialize_ref __libcurand begin
        find_library(toolkit(), "curand")
    end
end

const __libcusolver = Ref{String}()
function libcusolver()
    @initialize_ref __libcusolver begin
        find_library(toolkit(), "cusolver")
    end
end

const __libcusolverMg = Ref{Union{String,Nothing}}()
function libcusolvermg(; throw_error::Bool=true)
     path = @initialize_ref __libcusolverMg begin
        if toolkit_release() < v"10.1"
            nothing
        elseif toolkit_release() == v"10.2" && Sys.ARCH == :aarch64
            # special case: we don't have a libcusolvermg for 10.2 on aarch64
            nothing
        else
            find_library(toolkit(), "cusolverMg"; optional=true)
        end
    end
    if path === nothing && throw_error
        error("This functionality is unavailabe as cuSolverMg is missing.")
    end
    path
end
has_cusolvermg() = libcusolvermg(throw_error=false) !== nothing

const __libcupti = Ref{Union{String,Nothing}}()
function libcupti(; throw_error::Bool=true)
    path = @initialize_ref __libcupti begin
        find_library(toolkit(), "cupti"; optional=true)
    end
    if path === nothing && throw_error
        error("This functionality is unavailabe as CUPTI is missing.")
    end
    path
end
has_cupti() = libcupti(throw_error=false) !== nothing

const __libnvtx = Ref{Union{String,Nothing}}()
function libnvtx(; throw_error::Bool=true)
    path = @initialize_ref __libnvtx begin
        find_library(toolkit(), "nvToolsExt"; optional=true)
    end
    if path === nothing && throw_error
        error("This functionality is unavailabe as NVTX is missing.")
    end
    path
end
has_nvtx() = libnvtx(throw_error=false) !== nothing

function artifact_library(artifact, name, versions=[])
    # XXX: we don't want to consider multiple library names based on all candidate versions,
    #      since all that is known when building the artifact, but not saved anywhere.
    dir = joinpath(artifact, Sys.iswindows() ? "bin" : "lib")
    all_names = library_names(name, versions)
    for name in all_names
        path = joinpath(dir, name)
        ispath(path) && return path
    end

    # we should _always_ find libraries in artifacts
    error("""Could not find library '$name' in $artifact
             This is a bug; please file an issue with a verbose directory listing of $dir
             If this directory is empty, delete it and try again.""")
end

function find_library(cuda::ArtifactToolkit, name; optional=false)
    # NOTE: optional is ignored, and we'll error if not found
    versions = cuda_library_versions(name)
    path = artifact_library(cuda.artifact, name, versions)
    Libdl.dlopen(path)
    return path
end

function find_library(cuda::LocalToolkit, name; optional=false)
    versions = cuda_library_versions(name)
    path = find_cuda_library(cuda.dirs, name, versions)
    if path !== nothing
        Libdl.dlopen(path)
        return path
    else
        optional || error("Could not find library '$name' in your local CUDA installation.")
        return nothing
    end
end


## other

export libdevice, libcudadevrt

const __libdevice = Ref{String}()
function libdevice()
    @initialize_ref __libdevice begin
        find_libdevice(toolkit())
    end
end

function artifact_file(artifact_dir, name)
    path = joinpath(artifact_dir, name)
    if !ispath(path)
        error("""Could not find '$name' in $artifact_dir!
                 This is a bug; please file an issue with a verbose directory listing of $artifact_dir
                 If this directory is empty, delete it and try again.""")
    end
    return path
end

function find_libdevice(cuda::ArtifactToolkit)
    path = artifact_file(cuda.artifact, joinpath("share", "libdevice", "libdevice.10.bc"))
    if isfile(path)
        return path
    else
    end
end

function find_libdevice(cuda::LocalToolkit)
    path = find_libdevice(cuda.dirs)
    if path !== nothing
        return path
    else
        error("Could not find libdevice in your local CUDA installation.")
    end
end

const __libcudadevrt = Ref{String}()
function libcudadevrt()
    @initialize_ref __libcudadevrt begin
        find_libcudadevrt(toolkit())
    end
end

function artifact_static_library(artifact_dir, name)
    path = joinpath(artifact_dir, "lib", Sys.iswindows() ? "$name.lib" : "lib$name.a")
    if !ispath(path)
        error("""Could not find static library '$name' in $artifact_dir
                 This is a bug; please file an issue with a verbose directory listing of $artifact_dir
                 If this directory is empty, delete it and try again.""")
    end
    return path
end

find_libcudadevrt(cuda::ArtifactToolkit) = artifact_static_library(cuda.artifact, "cudadevrt")

function find_libcudadevrt(cuda::LocalToolkit)
    path = find_libcudadevrt(cuda.dirs)
    if path !== nothing
        return path
    else
        error("Could not find libcudadevrt in your local CUDA installation.")
    end
end


#
# NCCL
#

export libnccl, has_cnccl

const __libnccl = Ref{Union{String,Nothing}}()
function libnccl(; throw_error::Bool=true)
    path = @initialize_ref __libnccl begin
        find_nccl(toolkit(), "nccl", v"1")
    end
    if path === nothing && throw_error
        error("This functionality is unavailabe as NCCL is missing.")
    end
    path
end
has_nccl() = libnccl(throw_error=false) !== nothing

function find_nccl(cuda::ArtifactToolkit, name, version)
    artifact_dir = cuda_artifact("NCCL", cuda.release)
    if artifact_dir === nothing
        return nothing
    end
    path = artifact_library(artifact_dir, name, [version])

    @debug "Using NCCL library $name from an artifact at $(artifact_dir)"
    Libdl.dlopen(path)
    return path
end

function find_nccl(cuda::LocalToolkit, name, version)
    path = find_library(name, [version]; locations=cuda.dirs)
    if path === nothing
        return nothing
    end

    @debug "Using local NCCL library $name at $(path)"
    Libdl.dlopen(path)
    return path
end


#
# CUQUANTUM
#

export libcutensornet, has_cutensornet, libcustatevec, has_custatevec

const __libcutensornet = Ref{Union{String,Nothing}}()
function libcutensornet(; throw_error::Bool=true)
    path = @initialize_ref __libcutensornet begin
        # CUTENSORNET depends on CUTENSOR
        libcutensor(throw_error=throw_error)

        if CUDA.runtime_version() < v"11"
            # XXX: bound this using tags in the Artifact.toml?
            nothing
        else
            find_cutensornet(toolkit(), "cutensornet", v"0.1.0")
        end
    end
    if path === nothing && throw_error
        error("This functionality is unavailabe as CUTENSORNET is missing.")
    end
    return path
end
has_cutensornet() = has_cutensor() && libcutensornet(throw_error=false) !== nothing

const __libcustatevec = Ref{Union{String,Nothing}}()
function libcustatevec(; throw_error::Bool=true)
    path = @initialize_ref __libcustatevec begin

        if CUDA.runtime_version() < v"11"
            # XXX: bound this using tags in the Artifact.toml?
            nothing
        else
           find_custatevec(toolkit(), "custatevec", v"0.1.0")
        end
    end
    if path === nothing && throw_error
        error("This functionality is unavailabe as CUSTATEVEC is missing.")
    end
    return path
end
has_custatevec() = libcustatevec(throw_error=false) !== nothing

function find_cutensornet(cuda::ArtifactToolkit, name, version)
    artifact_dir = generic_artifact("cuQuantum")
    if artifact_dir === nothing
        return nothing
    end
    path = artifact_library(artifact_dir, name, [version])

    @debug "Using CUTENSORNET library $name from an artifact at $(artifact_dir)"
    Libdl.dlopen(path)
    return path
end

function find_cutensornet(cuda::LocalToolkit, name, version)
    path = find_library(name, [version]; locations=cuda.dirs)
    if path === nothing
        return nothing
    end

    @debug "Using local CUTENSORNET library $name at $(path)"
    Libdl.dlopen(path)
    return path
end

function find_custatevec(cuda::ArtifactToolkit, name, version)
    artifact_dir = cuda_artifact("cuQuantum", v"0.1.3")
    if artifact_dir === nothing
        return nothing
    end
    path = artifact_library(artifact_dir, name, [version])

    @debug "Using CUSTATEVEC library $name from an artifact at $(artifact_dir)"
    Libdl.dlopen(path)
    return path
end

function find_custatevec(cuda::LocalToolkit, name, version)
    path = find_library(name, [version]; locations=cuda.dirs)
    if path === nothing
        return nothing
    end

    @debug "Using local CUSTATEVEC library $name at $(path)"
    Libdl.dlopen(path)
    return path
end


#
# Utilities
#

export download_artifacts

"""
    download_artifacts()

Downloads the artifacts you will need to run CUDA.jl. This can be used to pre-populate the
artifacts directory from, e.g., a container build script.

If you want this function to not require a CUDA driver (which wouldn't be available from
said container build environment) be sure to set the `JULIA_CUDA_VERSION` environment
variable to an appropriate CUDA release number. This environment variable should then also
be set at run-time, and should be compatible with the NVIDIA driver that will be available
in that environment.

!!! warning

    This function is a temporary hack, and will be removed once CUDA.jl uses JLLs for
    downloading and installing artifacts.
"""
function download_artifacts()
    toolkit = find_artifact_cuda()
    cuda_artifact("CUDNN", toolkit.release)
    cuda_artifact("CUTENSOR", toolkit.release)
    cuda_artifact("NCCL", toolkit.release)

    generic_artifact("CUDA_compat")
    generic_artifact("cuQuantum")
end
