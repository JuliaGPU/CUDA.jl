<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CUDA driver · CUDA.jl</title><meta name="title" content="CUDA driver · CUDA.jl"/><meta property="og:title" content="CUDA driver · CUDA.jl"/><meta property="twitter:title" content="CUDA driver · CUDA.jl"/><meta name="description" content="Documentation for CUDA.jl."/><meta property="og:description" content="Documentation for CUDA.jl."/><meta property="twitter:description" content="Documentation for CUDA.jl."/><meta property="og:url" content="https://cuda.juliagpu.org/stable/lib/driver/"/><meta property="twitter:url" content="https://cuda.juliagpu.org/stable/lib/driver/"/><link rel="canonical" href="https://cuda.juliagpu.org/stable/lib/driver/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-154489943-2"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-154489943-2', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="CUDA.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CUDA.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/custom_structs/">Using custom structs</a></li><li><a class="tocitem" href="../../tutorials/performance/">Performance Tips</a></li></ul></li><li><span class="tocitem">Installation</span><ul><li><a class="tocitem" href="../../installation/overview/">Overview</a></li><li><a class="tocitem" href="../../installation/conditional/">Conditional use</a></li><li><a class="tocitem" href="../../installation/troubleshooting/">Troubleshooting</a></li></ul></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../../usage/overview/">Overview</a></li><li><a class="tocitem" href="../../usage/workflow/">Workflow</a></li><li><a class="tocitem" href="../../usage/array/">Array programming</a></li><li><a class="tocitem" href="../../usage/memory/">Memory management</a></li><li><a class="tocitem" href="../../usage/multitasking/">Tasks and threads</a></li><li><a class="tocitem" href="../../usage/multigpu/">Multiple GPUs</a></li></ul></li><li><span class="tocitem">Development</span><ul><li><a class="tocitem" href="../../development/profiling/">Benchmarking &amp; profiling</a></li><li><a class="tocitem" href="../../development/kernel/">Kernel programming</a></li><li><a class="tocitem" href="../../development/troubleshooting/">Troubleshooting</a></li><li><a class="tocitem" href="../../development/debugging/">Debugging</a></li></ul></li><li><span class="tocitem">API reference</span><ul><li><a class="tocitem" href="../../api/essentials/">Essentials</a></li><li><a class="tocitem" href="../../api/array/">Array programming</a></li><li><a class="tocitem" href="../../api/kernel/">Kernel programming</a></li><li><a class="tocitem" href="../../api/compiler/">Compiler</a></li></ul></li><li><span class="tocitem">Library reference</span><ul><li class="is-active"><a class="tocitem" href>CUDA driver</a><ul class="internal"><li><a class="tocitem" href="#Error-Handling"><span>Error Handling</span></a></li><li><a class="tocitem" href="#Version-Management"><span>Version Management</span></a></li><li><a class="tocitem" href="#Device-Management"><span>Device Management</span></a></li><li><a class="tocitem" href="#Context-Management"><span>Context Management</span></a></li><li><a class="tocitem" href="#Module-Management"><span>Module Management</span></a></li><li><a class="tocitem" href="#Memory-Management"><span>Memory Management</span></a></li><li><a class="tocitem" href="#Stream-Management"><span>Stream Management</span></a></li><li><a class="tocitem" href="#Event-Management"><span>Event Management</span></a></li><li><a class="tocitem" href="#Execution-Control"><span>Execution Control</span></a></li><li><a class="tocitem" href="#Profiler-Control"><span>Profiler Control</span></a></li><li><a class="tocitem" href="#Texture-Memory"><span>Texture Memory</span></a></li><li><a class="tocitem" href="#Occupancy-API"><span>Occupancy API</span></a></li><li><a class="tocitem" href="#Graph-Execution"><span>Graph Execution</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../faq/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library reference</a></li><li class="is-active"><a href>CUDA driver</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CUDA driver</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGPU/CUDA.jl/blob/master/docs/src/lib/driver.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="CUDA-driver"><a class="docs-heading-anchor" href="#CUDA-driver">CUDA driver</a><a id="CUDA-driver-1"></a><a class="docs-heading-anchor-permalink" href="#CUDA-driver" title="Permalink"></a></h1><p>This section lists the package&#39;s public functionality that directly corresponds to functionality of the CUDA driver API. In general, the abstractions stay close to those of the CUDA driver API, so for more information on certain library calls you can consult the <a href="http://docs.nvidia.com/cuda/cuda-driver-api/">CUDA driver API reference</a>.</p><p>The documentation is grouped according to the modules of the driver API.</p><h2 id="Error-Handling"><a class="docs-heading-anchor" href="#Error-Handling">Error Handling</a><a id="Error-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Handling" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CuError" href="#CUDA.CuError"><code>CUDA.CuError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CuError(code)</code></pre><p>Create a CUDA error object with error code <code>code</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/error.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.name-Tuple{CuError}" href="#CUDA.name-Tuple{CuError}"><code>CUDA.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">name(err::CuError)</code></pre><p>Gets the string representation of an error code.</p><pre><code class="language-julia-repl hljs">julia&gt; err = CuError(CUDA.cudaError_enum(1))
CuError(CUDA_ERROR_INVALID_VALUE)

julia&gt; name(err)
&quot;ERROR_INVALID_VALUE&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/error.jl#L39-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.description-Tuple{CuError}" href="#CUDA.description-Tuple{CuError}"><code>CUDA.description</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">description(err::CuError)</code></pre><p>Gets the string description of an error code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/error.jl#L58-L62">source</a></section></article><h2 id="Version-Management"><a class="docs-heading-anchor" href="#Version-Management">Version Management</a><a id="Version-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Version-Management" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.driver_version-Tuple{}" href="#CUDA.driver_version-Tuple{}"><code>CUDA.driver_version</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">driver_version()</code></pre><p>Returns the latest version of CUDA supported by the loaded driver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/version.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.system_driver_version-Tuple{}" href="#CUDA.system_driver_version-Tuple{}"><code>CUDA.system_driver_version</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">system_driver_version()</code></pre><p>Returns the latest version of CUDA supported by the original system driver, or <code>nothing</code> if the driver was not upgraded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/version.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.runtime_version-Tuple{}" href="#CUDA.runtime_version-Tuple{}"><code>CUDA.runtime_version</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">runtime_version()</code></pre><p>Returns the CUDA Runtime version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/version.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.set_runtime_version!" href="#CUDA.set_runtime_version!"><code>CUDA.set_runtime_version!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">CUDA.set_runtime_version!([version::VersionNumber]; [local_toolkit::Bool])</code></pre><p>Configures the active project to use a specific CUDA toolkit version from a specific source.</p><p>If <code>local_toolkit</code> is set, the CUDA toolkit will be used from the local system, otherwise it will be downloaded from an artifact source. In the case of a local toolkit, <code>version</code> informs CUDA.jl which version that is (this may be useful if auto-detection fails). In the case of artifact sources, <code>version</code> controls which version will be downloaded and used.</p><p>When not specifying either the <code>version</code> or the <code>local_toolkit</code> argument, the default behavior will be used, which is to use the most recent compatible runtime available from an artifact source. Note that this will override any Preferences that may be configured in a higher-up depot; to clear preferences nondestructively, use <a href="#CUDA.reset_runtime_version!"><code>CUDA.reset_runtime_version!</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/version.jl#L53-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.reset_runtime_version!" href="#CUDA.reset_runtime_version!"><code>CUDA.reset_runtime_version!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">CUDA.reset_runtime_version!()</code></pre><p>Resets the CUDA version preferences in the active project to the default, which is to use the most recent compatible runtime available from an artifact source, unless a higher-up depot has configured a different preference. To force use of the default behavior for the local project, use <a href="#CUDA.set_runtime_version!"><code>CUDA.set_runtime_version!</code></a> with no arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/version.jl#L93-L100">source</a></section></article><h2 id="Device-Management"><a class="docs-heading-anchor" href="#Device-Management">Device Management</a><a id="Device-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Device-Management" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CuDevice" href="#CUDA.CuDevice"><code>CUDA.CuDevice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CuDevice(ordinal::Integer)</code></pre><p>Get a handle to a compute device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/devices.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.devices" href="#CUDA.devices"><code>CUDA.devices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">devices()</code></pre><p>Get an iterator for the compute devices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/devices.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.current_device" href="#CUDA.current_device"><code>CUDA.current_device</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">current_device()</code></pre><p>Returns the current device.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This is a low-level API, returning the current device as known to the CUDA driver. For most users, it is recommended to use the <a href="../../api/essentials/#CUDA.device"><code>device</code></a> method instead.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/devices.jl#L33-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.name-Tuple{CuDevice}" href="#CUDA.name-Tuple{CuDevice}"><code>CUDA.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">name(dev::CuDevice)</code></pre><p>Returns an identifier string for the device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/devices.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.totalmem-Tuple{CuDevice}" href="#CUDA.totalmem-Tuple{CuDevice}"><code>CUDA.totalmem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">totalmem(dev::CuDevice)</code></pre><p>Returns the total amount of memory (in bytes) on the device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/devices.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.attribute" href="#CUDA.attribute"><code>CUDA.attribute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">attribute(dev::CuDevice, code)</code></pre><p>Returns information about the device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/devices.jl#L159-L163">source</a></section><section><div><pre><code class="language-julia hljs">attribute(X, pool::CuMemoryPool, attr)</code></pre><p>Returns attribute <code>attr</code> about <code>pool</code>. The type of the returned value depends on the attribute, and as such must be passed as the <code>X</code> parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/pool.jl#L75-L80">source</a></section><section><div><pre><code class="language-julia hljs">attribute(X, ptr::Union{Ptr,CuPtr}, attr)</code></pre><p>Returns attribute <code>attr</code> about pointer <code>ptr</code>. The type of the returned value depends on the attribute, and as such must be passed as the <code>X</code> parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/memory.jl#L766-L771">source</a></section></article><p>Certain common attributes are exposed by additional convenience functions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.capability-Tuple{CuDevice}" href="#CUDA.capability-Tuple{CuDevice}"><code>CUDA.capability</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">capability(dev::CuDevice)</code></pre><p>Returns the compute capability of the device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/devices.jl#L179-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.warpsize-Tuple{CuDevice}" href="#CUDA.warpsize-Tuple{CuDevice}"><code>CUDA.warpsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">warpsize(dev::CuDevice)</code></pre><p>Returns the warp size (in threads) of the device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/devices.jl#L172-L176">source</a></section></article><h2 id="Context-Management"><a class="docs-heading-anchor" href="#Context-Management">Context Management</a><a id="Context-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Context-Management" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CuContext" href="#CUDA.CuContext"><code>CUDA.CuContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CuContext(dev::CuDevice, flags=CTX_SCHED_AUTO)
CuContext(f::Function, ...)</code></pre><p>Create a CUDA context for device. A context on the GPU is analogous to a process on the CPU, with its own distinct address space and allocated resources. When a context is destroyed, the system cleans up the resources allocated to it.</p><p>When you are done using the context, call <a href="#CUDA.unsafe_destroy!-Tuple{CuContext}"><code>CUDA.unsafe_destroy!</code></a> to mark it for deletion, or use do-block syntax with this constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/context.jl#L13-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.unsafe_destroy!-Tuple{CuContext}" href="#CUDA.unsafe_destroy!-Tuple{CuContext}"><code>CUDA.unsafe_destroy!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_destroy!(ctx::CuContext)</code></pre><p>Immediately destroy a context, freeing up all resources associated with it. This does not respect any users of the context, and might make other objects unusable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/context.jl#L90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.current_context" href="#CUDA.current_context"><code>CUDA.current_context</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">current_context()</code></pre><p>Returns the current context. Throws an undefined reference error if the current thread has no context bound to it, or if the bound context has been destroyed.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This is a low-level API, returning the current context as known to the CUDA driver. For most users, it is recommended to use the <a href="../../api/essentials/#CUDA.context"><code>context</code></a> method instead.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/context.jl#L51-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.activate-Tuple{CuContext}" href="#CUDA.activate-Tuple{CuContext}"><code>CUDA.activate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">activate(ctx::CuContext)</code></pre><p>Binds the specified CUDA context to the calling CPU thread.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/context.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.synchronize-Tuple{CuContext}" href="#CUDA.synchronize-Tuple{CuContext}"><code>CUDA.synchronize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">synchronize(ctx::Context)</code></pre><p>Block for the all operations on <code>ctx</code> to complete. This is a heavyweight operation, typically you only need to call <a href="#CUDA.synchronize-Tuple{CuContext}"><code>synchronize</code></a> which only synchronizes the stream associated with the current task.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/context.jl#L292-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.device_synchronize" href="#CUDA.device_synchronize"><code>CUDA.device_synchronize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">device_synchronize()</code></pre><p>Block for the all operations on <code>ctx</code> to complete. This is a heavyweight operation, typically you only need to call <a href="#CUDA.synchronize-Tuple{CuContext}"><code>synchronize</code></a> which only synchronizes the stream associated with the current task.</p><p>On the device, <code>device_synchronize</code> acts as a synchronization point for child grids in the context of dynamic parallelism.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/context.jl#L309-L318">source</a></section></article><h3 id="Primary-Context-Management"><a class="docs-heading-anchor" href="#Primary-Context-Management">Primary Context Management</a><a id="Primary-Context-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Primary-Context-Management" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CuPrimaryContext" href="#CUDA.CuPrimaryContext"><code>CUDA.CuPrimaryContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CuPrimaryContext(dev::CuDevice)</code></pre><p>Create a primary CUDA context for a given device.</p><p>Each primary context is unique per device and is shared with CUDA runtime API. It is meant for interoperability with (applications using) the runtime API.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/context.jl#L172-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CuContext-Tuple{CuPrimaryContext}" href="#CUDA.CuContext-Tuple{CuPrimaryContext}"><code>CUDA.CuContext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CuContext(pctx::CuPrimaryContext)</code></pre><p>Derive a context from a primary context.</p><p>Calling this function increases the reference count of the primary context. The returned context <em>should not</em> be free with the <code>unsafe_destroy!</code> function that&#39;s used with ordinary contexts. Instead, the refcount of the primary context should be decreased by calling <code>unsafe_release!</code>, or set to zero by calling <code>unsafe_reset!</code>. The easiest way to do this is by using the <code>do</code>-block syntax.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/context.jl#L184-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.isactive-Tuple{CuPrimaryContext}" href="#CUDA.isactive-Tuple{CuPrimaryContext}"><code>CUDA.isactive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isactive(pctx::CuPrimaryContext)</code></pre><p>Query whether a primary context is active.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/context.jl#L250-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.flags-Tuple{CuPrimaryContext}" href="#CUDA.flags-Tuple{CuPrimaryContext}"><code>CUDA.flags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flags(pctx::CuPrimaryContext)</code></pre><p>Query the flags of a primary context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/context.jl#L257-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.setflags!-Tuple{CuPrimaryContext, CUDA.CUctx_flags_enum}" href="#CUDA.setflags!-Tuple{CuPrimaryContext, CUDA.CUctx_flags_enum}"><code>CUDA.setflags!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setflags!(pctx::CuPrimaryContext)</code></pre><p>Set the flags of a primary context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/context.jl#L264-L268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.unsafe_reset!-Tuple{CuPrimaryContext}" href="#CUDA.unsafe_reset!-Tuple{CuPrimaryContext}"><code>CUDA.unsafe_reset!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_reset!(pctx::CuPrimaryContext)</code></pre><p>Explicitly destroys and cleans up all resources associated with a device&#39;s primary context in the current process. Note that this forcibly invalidates all contexts derived from this primary context, and as a result outstanding resources might become invalid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/context.jl#L226-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.unsafe_release!-Tuple{CuPrimaryContext}" href="#CUDA.unsafe_release!-Tuple{CuPrimaryContext}"><code>CUDA.unsafe_release!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CUDA.unsafe_release!(pctx::CuPrimaryContext)</code></pre><p>Lower the refcount of a context, possibly freeing up all resources associated with it. This does not respect any users of the context, and might make other objects unusable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/context.jl#L210-L215">source</a></section></article><h2 id="Module-Management"><a class="docs-heading-anchor" href="#Module-Management">Module Management</a><a id="Module-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Management" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CuModule" href="#CUDA.CuModule"><code>CUDA.CuModule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CuModule(data, options::Dict{CUjit_option,Any})
CuModuleFile(path, options::Dict{CUjit_option,Any})</code></pre><p>Create a CUDA module from a data, or a file containing data. The data may be PTX code, a CUBIN, or a FATBIN.</p><p>The <code>options</code> is an optional dictionary of JIT options and their respective value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/module.jl#L35-L43">source</a></section></article><h3 id="Function-Management"><a class="docs-heading-anchor" href="#Function-Management">Function Management</a><a id="Function-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Management" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CuFunction" href="#CUDA.CuFunction"><code>CUDA.CuFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CuFunction(mod::CuModule, name::String)</code></pre><p>Acquires a function handle from a named function in a module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/module/function.jl#L7-L11">source</a></section></article><h3 id="Global-Variable-Management"><a class="docs-heading-anchor" href="#Global-Variable-Management">Global Variable Management</a><a id="Global-Variable-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Global-Variable-Management" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CuGlobal" href="#CUDA.CuGlobal"><code>CUDA.CuGlobal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CuGlobal{T}(mod::CuModule, name::String)</code></pre><p>Acquires a typed global variable handle from a named global in a module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/module/global.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eltype-Tuple{CuGlobal}" href="#Base.eltype-Tuple{CuGlobal}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eltype(var::CuGlobal)</code></pre><p>Return the element type of a global variable object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/module/global.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{CuGlobal}" href="#Base.getindex-Tuple{CuGlobal}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.getindex(var::CuGlobal)</code></pre><p>Return the current value of a global variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/module/global.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.setindex!-Union{Tuple{T}, Tuple{CuGlobal{T}, T}} where T" href="#Base.setindex!-Union{Tuple{T}, Tuple{CuGlobal{T}, T}} where T"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.setindex(var::CuGlobal{T}, val::T)</code></pre><p>Set the value of a global variable to <code>val</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/module/global.jl#L59-L63">source</a></section></article><h3 id="Linker"><a class="docs-heading-anchor" href="#Linker">Linker</a><a id="Linker-1"></a><a class="docs-heading-anchor-permalink" href="#Linker" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CuLink" href="#CUDA.CuLink"><code>CUDA.CuLink</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CuLink()</code></pre><p>Creates a pending JIT linker invocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/module/linker.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.add_data!" href="#CUDA.add_data!"><code>CUDA.add_data!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_data!(link::CuLink, name::String, code::String)</code></pre><p>Add PTX code to a pending link operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/module/linker.jl#L63-L67">source</a></section><section><div><pre><code class="language-julia hljs">add_data!(link::CuLink, name::String, data::Vector{UInt8})</code></pre><p>Add object code to a pending link operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/module/linker.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.add_file!" href="#CUDA.add_file!"><code>CUDA.add_file!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_file!(link::CuLink, path::String, typ::CUjitInputType)</code></pre><p>Add data from a file to a link operation. The argument <code>typ</code> indicates the type of the contained data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/module/linker.jl#L110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CuLinkImage" href="#CUDA.CuLinkImage"><code>CUDA.CuLinkImage</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The result of a linking operation.</p><p>This object keeps its parent linker object alive, as destroying a linker destroys linked images too.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/module/linker.jl#L122-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.complete" href="#CUDA.complete"><code>CUDA.complete</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">complete(link::CuLink)</code></pre><p>Complete a pending linker invocation, returning an output image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/module/linker.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CuModule-Tuple{CuLinkImage, Vararg{Any}}" href="#CUDA.CuModule-Tuple{CuLinkImage, Vararg{Any}}"><code>CUDA.CuModule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CuModule(img::CuLinkImage, ...)</code></pre><p>Create a CUDA module from a completed linking operation. Options from <code>CuModule</code> apply.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/module/linker.jl#L166-L170">source</a></section></article><h2 id="Memory-Management"><a class="docs-heading-anchor" href="#Memory-Management">Memory Management</a><a id="Memory-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Management" title="Permalink"></a></h2><p>Different kinds of memory objects can be created, representing different kinds of memory that the CUDA toolkit supports. Each of these memory objects can be allocated by calling <code>alloc</code> with the type of memory as first argument, and freed by calling <code>free</code>. Certain kinds of memory have specific methods defined.</p><h3 id="Device-memory"><a class="docs-heading-anchor" href="#Device-memory">Device memory</a><a id="Device-memory-1"></a><a class="docs-heading-anchor-permalink" href="#Device-memory" title="Permalink"></a></h3><p>This memory is accessible only by the GPU, and is the most common kind of memory used in CUDA programming.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.DeviceMemory" href="#CUDA.DeviceMemory"><code>CUDA.DeviceMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DeviceMemory</code></pre><p>Device memory residing on the GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/memory.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.alloc-Tuple{Type{CUDA.DeviceMemory}, Integer}" href="#CUDA.alloc-Tuple{Type{CUDA.DeviceMemory}, Integer}"><code>CUDA.alloc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc(DeviceMemory, bytesize::Integer;
      [async=false], [stream::CuStream], [pool::CuMemoryPool])</code></pre><p>Allocate <code>bytesize</code> bytes of memory on the device. This memory is only accessible on the GPU, and requires explicit calls to <code>unsafe_copyto!</code>, which wraps <code>cuMemcpy</code>, for access on the CPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/memory.jl#L53-L60">source</a></section></article><h3 id="Unified-memory"><a class="docs-heading-anchor" href="#Unified-memory">Unified memory</a><a id="Unified-memory-1"></a><a class="docs-heading-anchor-permalink" href="#Unified-memory" title="Permalink"></a></h3><p>Unified memory is accessible by both the CPU and the GPU, and is managed by the CUDA runtime. It is automatically migrated between the CPU and the GPU as needed, which simplifies programming but can lead to performance issues if not used carefully.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.UnifiedMemory" href="#CUDA.UnifiedMemory"><code>CUDA.UnifiedMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnifiedMemory</code></pre><p>Unified memory that is accessible on both the CPU and GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/memory.jl#L194-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.alloc-Tuple{Type{CUDA.UnifiedMemory}, Integer, CUDA.CUmemAttach_flags_enum}" href="#CUDA.alloc-Tuple{Type{CUDA.UnifiedMemory}, Integer, CUDA.CUmemAttach_flags_enum}"><code>CUDA.alloc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc(UnifiedMemory, bytesize::Integer, [flags::CUmemAttach_flags])</code></pre><p>Allocate <code>bytesize</code> bytes of unified memory. This memory is accessible from both the CPU and GPU, with the CUDA driver automatically copying upon first access.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/memory.jl#L221-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.prefetch-Tuple{CUDA.UnifiedMemory, Integer}" href="#CUDA.prefetch-Tuple{CUDA.UnifiedMemory, Integer}"><code>CUDA.prefetch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prefetch(::UnifiedMemory, [bytes::Integer]; [device::CuDevice], [stream::CuStream])</code></pre><p>Prefetches memory to the specified destination device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/memory.jl#L245-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.advise-Tuple{CUDA.UnifiedMemory, CUDA.CUmem_advise_enum, Integer}" href="#CUDA.advise-Tuple{CUDA.UnifiedMemory, CUDA.CUmem_advise_enum, Integer}"><code>CUDA.advise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">advise(::UnifiedMemory, advice::CUDA.CUmem_advise, [bytes::Integer]; [device::CuDevice])</code></pre><p>Advise about the usage of a given memory range.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/memory.jl#L259-L263">source</a></section></article><h3 id="Host-memory"><a class="docs-heading-anchor" href="#Host-memory">Host memory</a><a id="Host-memory-1"></a><a class="docs-heading-anchor-permalink" href="#Host-memory" title="Permalink"></a></h3><p>Host memory resides on the CPU, but is accessible by the GPU via the PCI bus. This is the slowest kind of memory, but is useful for communicating between running kernels and the host (e.g., to update counters or flags).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.HostMemory" href="#CUDA.HostMemory"><code>CUDA.HostMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HostMemory</code></pre><p>Pinned memory residing on the CPU, possibly accessible on the GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/memory.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.alloc-Tuple{Type{CUDA.HostMemory}, Integer, Any}" href="#CUDA.alloc-Tuple{Type{CUDA.HostMemory}, Integer, Any}"><code>CUDA.alloc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc(HostMemory, bytesize::Integer, [flags])</code></pre><p>Allocate <code>bytesize</code> bytes of page-locked memory on the host. This memory is accessible from the CPU, and makes it possible to perform faster memory copies to the GPU. Furthermore, if <code>flags</code> is set to <code>MEMHOSTALLOC_DEVICEMAP</code> the memory is also accessible from the GPU. These accesses are direct, and go through the PCI bus. If <code>flags</code> is set to <code>MEMHOSTALLOC_PORTABLE</code>, the memory is considered mapped by all CUDA contexts, not just the one that created the memory, which is useful if the memory needs to be accessed from multiple devices. Multiple <code>flags</code> can be set at one time using a bytewise <code>OR</code>:</p><pre><code class="nohighlight hljs">flags = MEMHOSTALLOC_PORTABLE | MEMHOSTALLOC_DEVICEMAP</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/memory.jl#L130-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.register-Tuple{Type{CUDA.HostMemory}, Ptr, Integer, Any}" href="#CUDA.register-Tuple{Type{CUDA.HostMemory}, Ptr, Integer, Any}"><code>CUDA.register</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">register(HostMemory, ptr::Ptr, bytesize::Integer, [flags])</code></pre><p>Page-lock the host memory pointed to by <code>ptr</code>. Subsequent transfers to and from devices will be faster, and can be executed asynchronously. If the <code>MEMHOSTREGISTER_DEVICEMAP</code> flag is specified, the buffer will also be accessible directly from the GPU. These accesses are direct, and go through the PCI bus. If the <code>MEMHOSTREGISTER_PORTABLE</code> flag is specified, any CUDA context can access the memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/memory.jl#L158-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.unregister-Tuple{CUDA.HostMemory}" href="#CUDA.unregister-Tuple{CUDA.HostMemory}"><code>CUDA.unregister</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unregister(::HostMemory)</code></pre><p>Unregisters a memory range that was registered with <a href="#CUDA.register-Tuple{Type{CUDA.HostMemory}, Ptr, Integer, Any}"><code>register</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/memory.jl#L175-L179">source</a></section></article><h3 id="Array-memory"><a class="docs-heading-anchor" href="#Array-memory">Array memory</a><a id="Array-memory-1"></a><a class="docs-heading-anchor-permalink" href="#Array-memory" title="Permalink"></a></h3><p>Array memory is a special kind of memory that is optimized for 2D and 3D access patterns. The memory is opaquely managed by the CUDA runtime, and is typically only used on combination with texture intrinsics.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.ArrayMemory" href="#CUDA.ArrayMemory"><code>CUDA.ArrayMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArrayMemory</code></pre><p>Array memory residing on the GPU, possibly in a specially-formatted way.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/memory.jl#L273-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.alloc-Union{Tuple{T}, Tuple{Type{CUDA.ArrayMemory{T}}, Tuple{Vararg{Int64, N}} where N}} where T" href="#CUDA.alloc-Union{Tuple{T}, Tuple{Type{CUDA.ArrayMemory{T}}, Tuple{Vararg{Int64, N}} where N}} where T"><code>CUDA.alloc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc(ArrayMemory, dims::Dims)</code></pre><p>Allocate array memory with dimensions <code>dims</code>. The memory is accessible on the GPU, but can only be used in conjunction with special intrinsics (e.g., texture intrinsics).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/memory.jl#L302-L307">source</a></section></article><h3 id="Pointers"><a class="docs-heading-anchor" href="#Pointers">Pointers</a><a id="Pointers-1"></a><a class="docs-heading-anchor-permalink" href="#Pointers" title="Permalink"></a></h3><p>To work with these buffers, you need to <code>convert</code> them to a <code>Ptr</code>, <code>CuPtr</code>, or in the case of <code>ArrayMemory</code> an <code>CuArrayPtr</code>. You can then use common Julia methods on these pointers, such as <code>unsafe_copyto!</code>. CUDA.jl also provides some specialized functionality that does not match standard Julia functionality:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.unsafe_copy2d!" href="#CUDA.unsafe_copy2d!"><code>CUDA.unsafe_copy2d!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsafe_copy2d!(dst, dstTyp, src, srcTyp, width, height=1;
               dstPos=(1,1), dstPitch=0,
               srcPos=(1,1), srcPitch=0,
               async=false, stream=nothing)</code></pre><p>Perform a 2D memory copy between pointers <code>src</code> and <code>dst</code>, at respectively position <code>srcPos</code> and <code>dstPos</code> (1-indexed). Pitch can be specified for both the source and destination; consult the CUDA documentation for more details. This call is executed asynchronously if <code>async</code> is set, otherwise <code>stream</code> is synchronized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/memory.jl#L464-L474">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.unsafe_copy3d!" href="#CUDA.unsafe_copy3d!"><code>CUDA.unsafe_copy3d!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsafe_copy3d!(dst, dstTyp, src, srcTyp, width, height=1, depth=1;
               dstPos=(1,1,1), dstPitch=0, dstHeight=0,
               srcPos=(1,1,1), srcPitch=0, srcHeight=0,
               async=false, stream=nothing)</code></pre><p>Perform a 3D memory copy between pointers <code>src</code> and <code>dst</code>, at respectively position <code>srcPos</code> and <code>dstPos</code> (1-indexed). Both pitch and height can be specified for both the source and destination; consult the CUDA documentation for more details. This call is executed asynchronously if <code>async</code> is set, otherwise <code>stream</code> is synchronized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/memory.jl#L547-L557">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.memset" href="#CUDA.memset"><code>CUDA.memset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">memset(mem::CuPtr, value::Union{UInt8,UInt16,UInt32}, len::Integer; [stream::CuStream])</code></pre><p>Initialize device memory by copying <code>val</code> for <code>len</code> times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/memory.jl#L387-L391">source</a></section></article><h3 id="Other"><a class="docs-heading-anchor" href="#Other">Other</a><a id="Other-1"></a><a class="docs-heading-anchor-permalink" href="#Other" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.free_memory" href="#CUDA.free_memory"><code>CUDA.free_memory</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">free_memory()</code></pre><p>Returns the free amount of memory (in bytes), available for allocation by the CUDA context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/memory.jl#L863-L867">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.total_memory" href="#CUDA.total_memory"><code>CUDA.total_memory</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">total_memory()</code></pre><p>Returns the total amount of memory (in bytes), available for allocation by the CUDA context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/memory.jl#L870-L874">source</a></section></article><h2 id="Stream-Management"><a class="docs-heading-anchor" href="#Stream-Management">Stream Management</a><a id="Stream-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Stream-Management" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CuStream" href="#CUDA.CuStream"><code>CUDA.CuStream</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CuStream(; flags=STREAM_DEFAULT, priority=nothing)</code></pre><p>Create a CUDA stream.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/stream.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.isdone-Tuple{CuStream}" href="#CUDA.isdone-Tuple{CuStream}"><code>CUDA.isdone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isdone(s::CuStream)</code></pre><p>Return <code>false</code> if a stream is busy (has task running or queued) and <code>true</code> if that stream is free.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/stream.jl#L121-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.priority_range" href="#CUDA.priority_range"><code>CUDA.priority_range</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">priority_range()</code></pre><p>Return the valid range of stream priorities as a <code>StepRange</code> (with step size  1). The lower bound of the range denotes the least priority (typically 0), with the upper bound representing the greatest possible priority (typically -1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/stream.jl#L148-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.priority" href="#CUDA.priority"><code>CUDA.priority</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">priority_range(s::CuStream)</code></pre><p>Return the priority of a stream <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/stream.jl#L164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.synchronize-Tuple{CuStream}" href="#CUDA.synchronize-Tuple{CuStream}"><code>CUDA.synchronize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">synchronize([stream::CuStream])</code></pre><p>Wait until <code>stream</code> has finished executing, with <code>stream</code> defaulting to the stream associated with the current Julia task.</p><p>See also: <a href="#CUDA.device_synchronize"><code>device_synchronize</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/stream.jl#L138-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.@sync" href="#CUDA.@sync"><code>CUDA.@sync</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@sync [blocking=false] ex</code></pre><p>Run expression <code>ex</code> and synchronize the GPU afterwards.</p><p>The <code>blocking</code> keyword argument determines how synchronization is performed. By default, non-blocking synchronization will be used, which gives other Julia tasks a chance to run while waiting for the GPU to finish. This may increase latency, so for short operations, or when benchmaring code that does not use multiple tasks, it may be beneficial to use blocking synchronization instead by setting <code>blocking=true</code>. Blocking synchronization can also be enabled globally by changing the <code>nonblocking_synchronization</code> preference.</p><p>See also: <a href="#CUDA.synchronize-Tuple{CuContext}"><code>synchronize</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/src/utilities.jl#L1-L14">source</a></section></article><p>For specific use cases, special streams are available:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.default_stream" href="#CUDA.default_stream"><code>CUDA.default_stream</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">default_stream()</code></pre><p>Return the default stream.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is generally better to use <code>stream()</code> to get a stream object that&#39;s local to the current task. That way, operations scheduled in other tasks can overlap.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/stream.jl#L41-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.legacy_stream" href="#CUDA.legacy_stream"><code>CUDA.legacy_stream</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">legacy_stream()</code></pre><p>Return a special object to use use an implicit stream with legacy synchronization behavior.</p><p>You can use this stream to perform operations that should block on all streams (with the exception of streams created with <code>STREAM_NON_BLOCKING</code>). This matches the old pre-CUDA 7 global stream behavior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/stream.jl#L53-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.per_thread_stream" href="#CUDA.per_thread_stream"><code>CUDA.per_thread_stream</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">per_thread_stream()</code></pre><p>Return a special object to use an implicit stream with per-thread synchronization behavior. This stream object is normally meant to be used with APIs that do not have per-thread versions of their APIs (i.e. without a <code>ptsz</code> or <code>ptds</code> suffix).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is generally not needed to use this type of stream. With CUDA.jl, each task already gets its own non-blocking stream, and multithreading in Julia is typically accomplished using tasks.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/stream.jl#L64-L76">source</a></section></article><h2 id="Event-Management"><a class="docs-heading-anchor" href="#Event-Management">Event Management</a><a id="Event-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Event-Management" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CuEvent" href="#CUDA.CuEvent"><code>CUDA.CuEvent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CuEvent()</code></pre><p>Create a new CUDA event.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/events.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.record" href="#CUDA.record"><code>CUDA.record</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">record(e::CuEvent, [stream::CuStream])</code></pre><p>Record an event on a stream.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/events.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.synchronize-Tuple{CuEvent}" href="#CUDA.synchronize-Tuple{CuEvent}"><code>CUDA.synchronize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">synchronize(e::CuEvent)</code></pre><p>Waits for an event to complete.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/events.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.isdone-Tuple{CuEvent}" href="#CUDA.isdone-Tuple{CuEvent}"><code>CUDA.isdone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isdone(e::CuEvent)</code></pre><p>Return <code>false</code> if there is outstanding work preceding the most recent call to <code>record(e)</code> and <code>true</code> if all captured work has been completed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/events.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.wait-Tuple{CuEvent}" href="#CUDA.wait-Tuple{CuEvent}"><code>CUDA.wait</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wait(e::CuEvent, [stream::CuStream])</code></pre><p>Make a stream wait on a event. This only makes the stream wait, and not the host; use <a href="#CUDA.synchronize-Tuple{CuEvent}"><code>synchronize(::CuEvent)</code></a> for that.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/events.jl#L71-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.elapsed" href="#CUDA.elapsed"><code>CUDA.elapsed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elapsed(start::CuEvent, stop::CuEvent)</code></pre><p>Computes the elapsed time between two events (in seconds).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/events.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.@elapsed" href="#CUDA.@elapsed"><code>CUDA.@elapsed</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@elapsed [blocking=false] ex</code></pre><p>A macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute on the GPU, as a floating-point number.</p><p>See also: <a href="#CUDA.@sync"><code>@sync</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/events.jl#L91-L98">source</a></section></article><h2 id="Execution-Control"><a class="docs-heading-anchor" href="#Execution-Control">Execution Control</a><a id="Execution-Control-1"></a><a class="docs-heading-anchor-permalink" href="#Execution-Control" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CuDim3" href="#CUDA.CuDim3"><code>CUDA.CuDim3</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CuDim3(x)

CuDim3((x,))
CuDim3((x, y))
CuDim3((x, y, x))</code></pre><p>A type used to specify dimensions, consisting of 3 integers for respectively the <code>x</code>, <code>y</code> and <code>z</code> dimension. Unspecified dimensions default to <code>1</code>.</p><p>Often accepted as argument through the <code>CuDim</code> type alias, eg. in the case of <a href="#CUDA.cudacall"><code>cudacall</code></a> or <a href="#CUDA.launch"><code>CUDA.launch</code></a>, allowing to pass dimensions as a plain integer or a tuple without having to construct an explicit <code>CuDim3</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/types.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.cudacall" href="#CUDA.cudacall"><code>CUDA.cudacall</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cudacall(f, types, values...; blocks::CuDim, threads::CuDim,
         cooperative=false, shmem=0, stream=stream())</code></pre><p><code>ccall</code>-like interface for launching a CUDA function <code>f</code> on a GPU.</p><p>For example:</p><pre><code class="nohighlight hljs">vadd = CuFunction(md, &quot;vadd&quot;)
a = rand(Float32, 10)
b = rand(Float32, 10)
ad = alloc(CUDA.DeviceMemory, 10*sizeof(Float32))
unsafe_copyto!(ad, convert(Ptr{Cvoid}, a), 10*sizeof(Float32)))
bd = alloc(CUDA.DeviceMemory, 10*sizeof(Float32))
unsafe_copyto!(bd, convert(Ptr{Cvoid}, b), 10*sizeof(Float32)))
c = zeros(Float32, 10)
cd = alloc(CUDA.DeviceMemory, 10*sizeof(Float32))

cudacall(vadd, (CuPtr{Cfloat},CuPtr{Cfloat},CuPtr{Cfloat}), ad, bd, cd; threads=10)
unsafe_copyto!(convert(Ptr{Cvoid}, c), cd, 10*sizeof(Float32)))</code></pre><p>The <code>blocks</code> and <code>threads</code> arguments control the launch configuration, and should both consist of either an integer, or a tuple of 1 to 3 integers (omitted dimensions default to 1). The <code>types</code> argument can contain both a tuple of types, and a tuple type, the latter being slightly faster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/execution.jl#L156-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.launch" href="#CUDA.launch"><code>CUDA.launch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">launch(f::CuFunction; args...; blocks::CuDim=1, threads::CuDim=1,
       cooperative=false, shmem=0, stream=stream())</code></pre><p>Low-level call to launch a CUDA function <code>f</code> on the GPU, using <code>blocks</code> and <code>threads</code> as respectively the grid and block configuration. Dynamic shared memory is allocated according to <code>shmem</code>, and the kernel is launched on stream <code>stream</code>.</p><p>Arguments to a kernel should either be bitstype, in which case they will be copied to the internal kernel parameter buffer, or a pointer to device memory.</p><p>This is a low-level call, prefer to use <a href="#CUDA.cudacall"><code>cudacall</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/execution.jl#L39-L51">source</a></section><section><div><pre><code class="language-julia hljs">launch(exec::CuGraphExec, [stream::CuStream])</code></pre><p>Launches an executable graph, by default in the currently-active stream.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/graph.jl#L138-L142">source</a></section></article><h2 id="Profiler-Control"><a class="docs-heading-anchor" href="#Profiler-Control">Profiler Control</a><a id="Profiler-Control-1"></a><a class="docs-heading-anchor-permalink" href="#Profiler-Control" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.@profile" href="#CUDA.@profile"><code>CUDA.@profile</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@profile [trace=false] [raw=false] code...
@profile external=true code...</code></pre><p>Profile the GPU execution of <code>code</code>.</p><p>There are two modes of operation, depending on whether <code>external</code> is <code>true</code> or <code>false</code>. The default value depends on whether Julia is being run under an external profiler.</p><p><strong>Integrated profiler (<code>external=false</code>, the default)</strong></p><p>In this mode, CUDA.jl will profile the execution of <code>code</code> and display the result. By default, a summary of host and device-side execution will be show, including any NVTX events. To display a chronological trace of the captured activity instead, <code>trace</code> can be set to <code>true</code>. Trace output will include an ID column that can be used to match host-side and device-side activity. If <code>raw</code> is <code>true</code>, all data will always be included, even if it may not be relevant. The output will be written to <code>io</code>, which defaults to <code>stdout</code>.</p><p>Slow operations will be highlighted in the output: Entries colored in yellow are among the slowest 25%, while entries colored in red are among the slowest 5% of all operations.</p><p>!!! compat &quot;Julia 1.9&quot; This functionality is only available on Julia 1.9 and later.</p><p>!!! compat &quot;CUDA 11.2&quot; Older versions of CUDA, before 11.2, contain bugs that may prevent     the <code>CUDA.@profile</code> macro to work. It is recommended to use a newer runtime.</p><p><strong>External profilers (<code>external=true</code>, when an external profiler is detected)</strong></p><p>For more advanced profiling, it is possible to use an external profiling tool, such as NSight Systems or NSight Compute. When doing so, it is often advisable to only enable the profiler for the specific code region of interest. This can be done by wrapping the code with <code>CUDA.@profile external=true</code>, which used to be the only way to use this macro.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/src/profile.jl#L3-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.Profile.start" href="#CUDA.Profile.start"><code>CUDA.Profile.start</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">start()</code></pre><p>Enables profile collection by the active profiling tool for the current context. If profiling is already enabled, then this call has no effect.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/src/profile.jl#L206-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.Profile.stop" href="#CUDA.Profile.stop"><code>CUDA.Profile.stop</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stop()</code></pre><p>Disables profile collection by the active profiling tool for the current context. If profiling is already disabled, then this call has no effect.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/src/profile.jl#L221-L226">source</a></section></article><h2 id="Texture-Memory"><a class="docs-heading-anchor" href="#Texture-Memory">Texture Memory</a><a id="Texture-Memory-1"></a><a class="docs-heading-anchor-permalink" href="#Texture-Memory" title="Permalink"></a></h2><p>Textures are represented by objects of type <code>CuTexture</code> which are bound to some underlying memory, either <code>CuArray</code>s or <code>CuTextureArray</code>s:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CuTexture" href="#CUDA.CuTexture"><code>CUDA.CuTexture</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CuTexture{T,N,P}</code></pre><p><code>N</code>-dimensional texture object with elements of type <code>T</code>. These objects do not store data themselves, but are bounds to another source of device memory. Texture objects can be passed to CUDA kernels, where they will be accessible through the <a href="../../api/kernel/#CUDA.CuDeviceTexture"><code>CuDeviceTexture</code></a> type.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Experimental API. Subject to change without deprecation.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/src/texture.jl#L142-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CuTexture-Tuple{Any}" href="#CUDA.CuTexture-Tuple{Any}"><code>CUDA.CuTexture</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CuTexture{T,N,P}(parent::P; address_mode, filter_mode, normalized_coordinates)</code></pre><p>Construct a <code>N</code>-dimensional texture object with elements of type <code>T</code> as stored in <code>parent</code>.</p><p>Several keyword arguments alter the behavior of texture objects:</p><ul><li><code>address_mode</code> (wrap, <em>clamp</em>, mirror): how out-of-bounds values are accessed. Can be specified as a value for all dimensions, or as a tuple of <code>N</code> entries.</li><li><code>interpolation</code> (<em>nearest neighbour</em>, linear, bilinear): how non-integral indices are fetched. Nearest-neighbour fetches a single value, others interpolate between multiple.</li><li><code>normalized_coordinates</code> (true, <em>false</em>): whether indices are expected to fall in the normalized <code>[0:1)</code> range.</li></ul><p>!!! warning Experimental API. Subject to change without deprecation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/src/texture.jl#L161-L176">source</a></section><section><div><pre><code class="language-julia hljs">CuTexture(x::CuTextureArray{T,N})</code></pre><p>Create a <code>N</code>-dimensional texture object withelements of type <code>T</code> that will be read from <code>x</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Experimental API. Subject to change without deprecation.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/src/texture.jl#L293-L300">source</a></section><section><div><pre><code class="language-julia hljs">CuTexture(x::CuArray{T,N})</code></pre><p>Create a <code>N</code>-dimensional texture object that reads from a <code>CuArray</code>.</p><p>Note that it is necessary the their memory is well aligned and strided (good pitch). Currently, that is not being enforced.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Experimental API. Subject to change without deprecation.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/src/texture.jl#L304-L314">source</a></section></article><p>You can create <code>CuTextureArray</code> objects from both host and device memory:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CuTextureArray" href="#CUDA.CuTextureArray"><code>CUDA.CuTextureArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CuTextureArray{T,N}(undef, dims)</code></pre><p><code>N</code>-dimensional dense texture array with elements of type <code>T</code>. These arrays are optimized for texture fetching, and are only meant to be used as a source for <a href="#CUDA.CuTexture"><code>CuTexture{T,N,P}</code></a> objects.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Experimental API. Subject to change without deprecation.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/src/texture.jl#L14-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CuTextureArray-Tuple{Any}" href="#CUDA.CuTextureArray-Tuple{Any}"><code>CUDA.CuTextureArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CuTextureArray(A::AbstractArray)</code></pre><p>Allocate and initialize a texture array from host memory in <code>A</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Experimental API. Subject to change without deprecation.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/src/texture.jl#L70-L77">source</a></section><section><div><pre><code class="language-julia hljs">CuTextureArray(A::CuArray)</code></pre><p>Allocate and initialize a texture array from device memory in <code>A</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Experimental API. Subject to change without deprecation.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/src/texture.jl#L84-L91">source</a></section></article><h2 id="Occupancy-API"><a class="docs-heading-anchor" href="#Occupancy-API">Occupancy API</a><a id="Occupancy-API-1"></a><a class="docs-heading-anchor-permalink" href="#Occupancy-API" title="Permalink"></a></h2><p>The occupancy API can be used to figure out an appropriate launch configuration for a compiled kernel (represented as a <code>CuFunction</code>) on the current device:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.launch_configuration" href="#CUDA.launch_configuration"><code>CUDA.launch_configuration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">launch_configuration(fun::CuFunction; shmem=0, max_threads=0)</code></pre><p>Calculate a suggested launch configuration for kernel <code>fun</code> requiring <code>shmem</code> bytes of dynamic shared memory. Returns a tuple with a suggested amount of threads, and the minimal amount of blocks to reach maximal occupancy. Optionally, the maximum amount of threads can be constrained using <code>max_threads</code>.</p><p>In the case of a variable amount of shared memory, pass a callable object for <code>shmem</code> instead, taking a single integer representing the block size and returning the amount of dynamic shared memory for that configuration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/occupancy.jl#L44-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.active_blocks" href="#CUDA.active_blocks"><code>CUDA.active_blocks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">active_blocks(fun::CuFunction, threads; shmem=0)</code></pre><p>Calculate the maximum number of active blocks per multiprocessor when running <code>threads</code> threads of a kernel <code>fun</code> requiring <code>shmem</code> bytes of dynamic shared memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/occupancy.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.occupancy" href="#CUDA.occupancy"><code>CUDA.occupancy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">occupancy(fun::CuFunction, threads; shmem=0)</code></pre><p>Calculate the theoretical occupancy of launching <code>threads</code> threads of a kernel <code>fun</code> requiring <code>shmem</code> bytes of dynamic shared memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/occupancy.jl#L15-L21">source</a></section></article><h2 id="Graph-Execution"><a class="docs-heading-anchor" href="#Graph-Execution">Graph Execution</a><a id="Graph-Execution-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-Execution" title="Permalink"></a></h2><p>CUDA graphs can be easily recorded and executed using the high-level <code>@captured</code> macro:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.@captured" href="#CUDA.@captured"><code>CUDA.@captured</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">for ...
    @captured begin
        # code that executes several kernels or CUDA operations
    end
end</code></pre><p>A convenience macro for recording a graph of CUDA operations and automatically cache and update the execution. This can improve performance when executing kernels in a loop, where the launch overhead might dominate the execution.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>For this to be effective, the kernels and operations executed inside of the captured region should not signficantly change across iterations of the loop. It is allowed to, e.g., change kernel arguments or inputs to operations, as this will be processed by updating the cached executable graph. However, significant changes will result in an instantiation of the graph from scratch, which is an expensive operation.</p></div></div><p>See also: <a href="#CUDA.capture"><code>capture</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/graph.jl#L185-L205">source</a></section></article><p>Low-level operations are available too:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.CuGraph" href="#CUDA.CuGraph"><code>CUDA.CuGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CuGraph([flags])</code></pre><p>Create an empty graph for use with low-level graph operations. If you want to create a graph while directly recording operations, use <a href="#CUDA.capture"><code>capture</code></a>. For a high-level interface that also automatically executes the graph, use the <a href="#CUDA.@captured"><code>@captured</code></a> macro.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/graph.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.capture" href="#CUDA.capture"><code>CUDA.capture</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">capture([flags], [throw_error::Bool=true]) do
    ...
end</code></pre><p>Capture a graph of CUDA operations. The returned graph can then be instantiated and executed repeatedly for improved performance.</p><p>Note that many operations, like initial kernel compilation or memory allocations, cannot be captured. To work around this, you can set the <code>throw_error</code> keyword to false, which will cause this function to return <code>nothing</code> if such a failure happens. You can then try to evaluate the function in a regular way, and re-record afterwards.</p><p>See also: <a href="#CUDA.instantiate"><code>instantiate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/graph.jl#L57-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.instantiate" href="#CUDA.instantiate"><code>CUDA.instantiate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">instantiate(graph::CuGraph)</code></pre><p>Creates an executable graph from a graph. This graph can then be launched, or updated with an other graph.</p><p>See also: <a href="#CUDA.launch"><code>launch</code></a>, <a href="#CUDA.update"><code>update</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/graph.jl#L120-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.launch-Tuple{CuGraphExec}" href="#CUDA.launch-Tuple{CuGraphExec}"><code>CUDA.launch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">launch(f::CuFunction; args...; blocks::CuDim=1, threads::CuDim=1,
       cooperative=false, shmem=0, stream=stream())</code></pre><p>Low-level call to launch a CUDA function <code>f</code> on the GPU, using <code>blocks</code> and <code>threads</code> as respectively the grid and block configuration. Dynamic shared memory is allocated according to <code>shmem</code>, and the kernel is launched on stream <code>stream</code>.</p><p>Arguments to a kernel should either be bitstype, in which case they will be copied to the internal kernel parameter buffer, or a pointer to device memory.</p><p>This is a low-level call, prefer to use <a href="#CUDA.cudacall"><code>cudacall</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/execution.jl#L39-L51">source</a></section><section><div><pre><code class="language-julia hljs">launch(exec::CuGraphExec, [stream::CuStream])</code></pre><p>Launches an executable graph, by default in the currently-active stream.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/graph.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDA.update" href="#CUDA.update"><code>CUDA.update</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update(exec::CuGraphExec, graph::CuGraph; [throw_error::Bool=true])</code></pre><p>Check whether an executable graph can be updated with a graph and perform the update if possible. Returns a boolean indicating whether the update was successful. Unless <code>throw_error</code> is set to false, also throws an error if the update failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/CUDA.jl/blob/1c62a825255abb12eeef8163790b087b455570e1/lib/cudadrv/graph.jl#L147-L153">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../api/compiler/">« Compiler</a><a class="docs-footer-nextpage" href="../../faq/">FAQ »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Wednesday 15 May 2024 14:28">Wednesday 15 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
